[["index.html", "GEOG0030: Geocomputation Module Introduction Welcome Moodle Module overview Troubleshooting Acknowledgements", " GEOG0030: Geocomputation Justin van Dijk Last modified: 2023-01-27 Module Introduction Last modified: 2023-01-27 Welcome Welcome to Geocomputation. This module will introduce you both to the principles of spatial analysis as well as provide you with a comprehensive introduction to the use of programming. Over the next ten weeks, you will learn about the theory, methods and tools of spatial analysis through relevant case studies. We will start by using QGIS before moving to the R programming language. You will learn how to find, manage and clean spatial, demographic and socioeconomic datasets, and then analyse them using core spatial and statistical analysis techniques. Moodle Moodle is the central point of contact for GEOG0030 and it is where all important information will be communicated such as key module and assessment information. This workbook contains links to all reading material as well as the content of all computer tutorials Module overview The topics covered over the next ten weeks are: Week Section Topic 1 Foundational Concepts Geocomputation: An Introduction 2 Foundational Concepts GIScience and GIS software 3 Foundational Concepts Cartography and Visualisation 4 Foundational Concepts Programming for Data Analysis 5 Foundational Concepts Programming for Spatial Analysis Reading week Reading week 6 Core Spatial Analysis Analysing Spatial Patterns I: Geometric Operations and Spatial Queries 7 Core Spatial Analysis Analysing Spatial Patterns II: Spatial Autocorrelation 8 Core Spatial Analysis Analysing Spatial Patterns III: Point Pattern Analysis 9 Advanced Spatial Analysis Rasters, Zonal Statistics and Interpolation 10 Advanced Spatial Analysis Transport Network Analysis Troubleshooting Spatial analysis can yield fascinating insights into geographical relationships, albeit at times it can be challenging, particularly when we combine this with learning how to program at the same time. You will most likely encounter many error messages, experience software crashes, and spend hours to identify bugs in your code. However, the rewards of learning how to programmatically solve complex spatial problems will be very much worth it in the end. If you need specific assistance with this course please: Ask a question at the end of a lecture or during the computer practical. Attend the Department’s Coding Therapy sessions that are run on a weekly basis. Check the Moodle assessment tab for queries relating to this module’s assessment. If after pursuing all these avenues you still need help, you can book into our office hours. You can use an office hour to discuss a geographical concept in relation to the material, assessment or for any personal matters relevant to the completion of the module. Acknowledgements This year’s workbook is updated and compiled using: The GEOG0030: Geocomputation 2021-2021 workbook as created and compiled by Dr Jo Wilkin. The GEOG0030: Geocomputation 2021-2022 workbook. The datasets used in this workbook contain: Crime data obtained from data.police.uk (Open Government Licence) National Statistics data © Crown copyright and database right [2015] (Open Government Licence) Ordnance Survey data © Crown copyright and database right [2015] Public Health England © Crown copyright 2021 "],["geocomputation-an-introduction.html", "1 Geocomputation: An Introduction 1.1 Lecture slides 1.2 Reading list 1.3 Getting started 1.4 Software 1.5 Before you leave", " 1 Geocomputation: An Introduction This week’s lecture provided you with a thorough introduction on Geocomputation, outlining how and why it is different to a traditional GIScience course. We set the scene for the remainder of the module and explained how the foundational concepts that you will learn in the first half of term sit within the overall module. This week we start easy by setting up our work environment and set up the software that we will need over the coming weeks. 1.1 Lecture slides The slides for this week’s lecture can be downloaded here: [Link]. 1.2 Reading list Essential readings Brundson, C. and Comber, A. 2020. Opening practice: Supporting reproducibility and critical spatial data science. Journal of Geographical Systems 23: 477–496. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 1: Geographic Information: Science, Systems, and Society. [Link] Singleton, A. and Arribas-Bel, D. 2019. Geographic Data Science. Geographical Analysis. [Link] Suggested readings Miller, H. and Goodchild, M. 2015. Data-driven geography. GeoJournal 80: 449–461. [Link] Goodchild, M. 2009. Geographic information systems and science: Today and tomorrow. Annals of GIS 15(1): 3-9. [Link] Worobey, M. et al. 2022. The Huanan Seafood Wholesale Market in Wuhan was the early epicenter of the COVID-19 pandemic. Science 377(6609): 951-959. [Link] 1.3 Getting started Over the next few weeks, we will be taking a closer look at many of the foundational concepts that will ultimately enable you to confidently and competently analyse spatial data using both programming and GIS software. You will further learn how to plan, structure and conduct your own spatial analysis using programming – whilst making decisions on how to best present your work, which is a crucial aspect of any type of investigation but of particular relevance to your dissertation. To help with this, we highly recommend that you try to stay organised with your work, including taking notes and making yourself a coding handbook. We would also suggest to list the different datasets you come across - and importantly, the scales and different projections you use them at - more on this over the next weeks. Finally, you should also make notes about the different spatial analysis techniques you come across, including the different properties they assess and parameters they require to run. 1.4 Software This course primarily uses the R programming language, although we start by using QGIS in the next two weeks to give you a basic foundation in the principles of spatial analysis. Note Please follow the instructions below to install both R and QGIS onto your own personal computer. If you cannot install the software on your personal computer or you are not planning to bring your own laptop to the computer practicals, please refer to the UCL Desktop and RStudio Server section below. Please make sure that you have access to a working installation of QGIS and R (including relevant packages) before the first hands-on practical session next week. 1.4.1 QGIS Installation QGIS is an open-source graphic user interface GIS with many community developed add-on packages (or plugins) that provide additional functionality to the software. You can download and install QGIS on your personal machine by going to the QGIS website: [Link]. Note We recommend installing the Long Term Release (QGIS 3.22 LTR) as this version should be the most stable version. For Windows users: the QGIS installation may be a little slow. After installation, start QGIS to see if the installation was successful and no errors are shown after start up. 1.4.2 R and RStudio Installation R is both a programming language and software environment - in the form of RStudio- originally designed for statistical computing and graphics. R’s great strength is that it is open-source, can be used on any computer operating system, and is free for anyone to use and contribute to. Because of this, it is rapidly becoming the statistical language of choice for many academics and has a very large user community with people constantly contributing new packages to carry out all manner of statistical, graphical, and importantly for us, geographical tasks. Installing R takes a few relatively simple steps involving two programmes. First there is the R programme itself. Follow these steps to get it installed on your computer: Navigate in your browser to your nearest CRAN mirror: [Link] If you use a Windows computer, click on Download R for Windows. Then click on base. Download and install R 4.2.x for Windows. If you use a Mac computer, click on Download R for macOS and download and install R-4.2.x.pkg That is it! You now have installed the latest version of R on your own machine. However, to make working with R a little bit easier we also need to install something called an Integrated Development Environment (IDE). We will use RStudio: Navigate to the official webpage of RStudio: [Link] Download and install RStudio Desktop on your computer (free version!) After this, start RStudio to see if the installation was successful and no errors are shown after start up. 1.4.3 UCL Desktop and RStudio Server As an alternative to installing QGIS and R with RStudio onto your personal device, there are some other options. Firstly, both programmes are available through Desktop@UCL Anywhere as well as all UCL computers on campus. In case of R, there is also an RStudio server version available which you can access through your web browser: [Link] You should be able to log in with your normal UCL username and password. After logging in, you should see the RStudio interface appear. Figure 1.1: The RStudio Server interface. Note If it is the first time you log on to RStudio server you may only see the RStudio interface appear once you have clicked on the start a new session button. More importantly: if you are not on campus, RStudio server will only work with an active Virtual Private Network (VPN) connection that links your personal computer into UCL’s network. Details on setting up a VPN connection can be found in UCL’s VPN connection guides: [Link] 1.4.4 R package installation Now we have installed or have access to QGIS and R, we need to customise R. Many useful R function come in packages, these are free libraries of code written and made available by other by R users. This includes packages specifically developed for data cleaning, data wrangling, visualisation, mapping, and spatial analysis. To save us some time, we will install all R packages that we will need over the next ten weeks in one go. Now copy and paste the following code into the console. You can execute the code by hitting Enter. This may take a while. # install all packages that we need install.packages(c(&#39;tidyverse&#39;,&#39;sf&#39;,&#39;tmap&#39;,&#39;osmdata&#39;,&#39;RColorBrewer&#39;,&#39;janitor&#39;,&#39;spdep&#39;,&#39;dbscan&#39;,&#39;raster&#39;,&#39;spatstat&#39;,&#39;spatstat.core&#39;,&#39;geodist&#39;,&#39;gstat&#39;,&#39;dodgr&#39;)) Once you have installed the packages, we need to check whether we can in fact load them into our R session. Copy and paste the following code into the console, and executed by hitting Enter again. # load all packages library(tidyverse) library(sf) library(tmap) library(osmdata) library(RColorBrewer) library(janitor) library(spdep) library(dbscan) library(raster) library(spatstat) library(gstat) library(dodgr) You will see some information printed to your console but as long as you do not get a message that is similar to Error: package or namespace load failed for &lt;packagename&gt; or Error: package '&lt;packagename' could not be loaded all should be fine. Tip Even if you have used R or RStudio Server before and already installed some of the packages in the above list, do re-install all packages to make sure you have the latest versions. Legacy installations that have not been updated may lay lead to problems when going through the tutorials. 1.4.5 A note on ArcGIS ArcGIS Pro (previously ArcMap) is the main commercial GIS software that you may have already used - or seen/heard about through other modules or even job adverts. We do not use ArcGIS Pro in our Practicals for several reasons: Computing requirements for ArcGIS Pro are substantial and it only operates on the Windows Operating System. For Mac users, using ArcGIS Pro (and ArcMap) would require using either a Virtual Machine or running a copy of Windows OS on a separate partition of your hard drive. It is proprietary software, which means you need a license to use the software. For those of us in education, the University covers the cost of this license, but when you leave, you will need to pay for a personal license (around £100 for non-commercial use) to continue using the software and repeat any analysis you have used the software for. Whilst ArcPro can use pure Python (and even R) as a programming language within it through scripts and notebooks, it primarily relies on its own ArcPy and ArcGIS API for Python packages to run the in-built tools and analytical functions. To use these packages, you still need a license which makes it difficult to share your code with others if they do not have their own ArcGIS license. Recent developments in the ArcPro software, however, does make it an attractive tool for spatial data science and quantitative geography - it has cross-user functionality, from data analysts who like to use a tool called Notebooks for their code development, to those focused more on cartography and visualisation with in-built bridges to Adobe’s Creative Suite. We therefore do not want to put you off looking into ArcGIS in the future, but for this course, we want to ensure the reproducibility of your work. Note This also means that the analysis you will be doing for your coursework assignment must be completed in R and QGIS. Specific guidance on the coursework assignment and permitted software will be made available at the end of Reading Week. 1.5 Before you leave You should now be all ready to go with the computer practicals the coming week. That is it for this week! "],["giscience-and-gis-software.html", "2 GIScience and GIS software 2.1 Lecture slides 2.2 Reading list 2.3 Simple digitisation of spatial features 2.4 Population change in London 2.5 Assignment 2.6 Before you leave", " 2 GIScience and GIS software This week’s lecture introduced you to foundational concepts associated with GIScience and GIS software, with particular emphasis on the representation of spatial data and sample design. Out of all our foundational concepts you will come across in the next four weeks, this is probably the most substantial to get to grips with and has both significant theoretical and practical aspects to its learning. The practical component of the week puts some of these learnings into practice, starting with a short digitisation excercise followed by a simple visualisation of London’s population over time. 2.1 Lecture slides The slides for this week’s lecture can be downloaded here: [Link]. 2.2 Reading list Essential readings Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 2: The Nature of Geographic Data. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 3: Representing Geography. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 7: Geographic Data Modeling. [Link] Suggested readings Goodchild, M. and Haining, R. 2005. GIS and spatial data analysis: Converging perspectives. Papers in Regional Science 83(1): 363–385. [Link] Schurr, C., Müller, M. and Imhof, N. 2020. Who makes geographical knowledge? The gender of Geography’s gatekeepers. The Professional Geographer 72(3): 317-331. [Link] Yuan, M. 2001. Representing complex geographic phenomena in GIS. Cartography and Geographic Information Science 28(2): 83-96. [Link] 2.3 Simple digitisation of spatial features To get spatial features in a digital form, they need to be digitised. Let’s take what should be a straight-forward example of digitising the River Thames in London. Figure 2.1: The Thames. We are going to use a very simple online tool that allows us to create digital data and export the data we create as raw files. Head to geojson.io. In the bottom left-hand corner, select Satellite Streets as your map option. Next, click on the Draw Linestring tool which you can find on the right hand side of the screen. You can hover over the icons to get the names of each tool. Now digitise the river Thames. Simply click from a starting point on the left- or right-hand side of the map, and digitise the river. Once you are done, double-click your final point to end your line. You can click on the line and select Info in the pop-up screen to find out how long the line is. You can export your data using the Save menu. Questions How easy did you find it to digitise the data and what decisions did you make in your own “sample scheme”? How close together are your clicks between lines? Did you sacrifice detail over expediency or did you spend perhaps a little too long trying to capture ever small bend in the river? How well do you think your line represents the River Thames? 2.4 Population change in London The second part of this practical will introduces you to attribute joins followed by creating a choropleth map. You will be using different types of joins throughout this module, and probably the rest of your career, so it is incredibly important that you understand how they work. Note The datasets you will create in this practical will be used in next week’s practical, so make sure to follow every step and save your data carefully. When using spatial data, there is generally a very specific workflow that you will need to go through and, believe it or not, the majority of this is not actually focused on analysing your data. Along with the idea that 80% of data is geographic data, the second most often-quoted GIS-related unreferenced ‘fact’ is that anyone working with spatial data will spend 80% of their time simply finding, retrieving, managing and processing the data before any analysis can be done. One of the reasons behind this need for a substantial amount of processing is that the data you often need to use is almost never in the format that you require for analysis. For example, for our investigation, there is not a ‘ready-made’ spatial population dataset (i.e. population shapefile) we can download to explore population change across England: Figure 2.2: Alas a quick Google search shows that finding a shapefile of England’s population is not straightforward. Instead, we need to go and find the raw datasets and create the data layers that we want. As a result, before beginning any spatial analysis project, it is best-practice to think through what end product you will ultimately need for your analysis. A typical spatial analysis workflow usually looks something like this: Identify the data you need to complete your analysis i.e. answer your research questions. This includes thinking through the scale, coverage and currency of your dataset. Find the data that matches your requirements, e.g. is it openly and easily available? Download the data and store it in the correct location. Clean the data. This may be done before or after ingesting your data into your chosen software programme. Load the data into your chosen software programme. Transform and process the data. This may require re-projection, creating joins between datasets, calculating new fields and applying selections. Analyse your data using appropriate methods. Visualise your data and results with graphs and maps. Communicate your results. As you can see, the analysis and visualisation part comes quite late in the overall spatial analysis workflow - and instead, the workflow is very top-heavy with data management. However, very often in GIS-related courses you will be given pre-processed datasets. Because data management is an essential part of your workflow, we are clean (the majority of) our data from the get-go. This will help you understand the processes that you will need to go through in the future as you search for and download your own data, as well as deal with the data first-hand before loading it into our GIS software. 2.4.1 Setting the scene For this practical, we will investigate how the population in London has changed over time. Understanding population change - over time and space - is spatial analysis at its most fundamental. We can understand a lot just from where population is growing or decreasing, including thinking through the impacts of these changes on the provision of housing, education, health and transport infrastructure. We can also see first-hand the impact of wider socio-economic processes, such as urbanisation. Today we will look at population in London in 2011, 2015, and 2019 at the Ward scale that we can use within our future analysis projects, starting next week. Note We will use the population dataset to normalise other datasets. Why? When we record events created by humans, there is often a population bias: simply, more people in an area will by probability lead to a higher occurrence of said event, such as crime. We will look at this in greater detail next week. 2.4.2 Finding data In the UK, finding authoritative data on population and Administrative Geography boundaries is increasingly straight-forward. Over the last decade, the UK government has opened up many of its datasets as part of an Open Data precedent that began in 2010 with the creation of data.gov.uk and the Open Government Licence (the terms and conditions for using data). Data.gov.uk is the UK government’s central database that contains open data that the central government, local authorities and public bodies publish. This includes, for example, aggregated census and health data – and even government spending. In addition to this central database, there are other authoritative databases run by the government and/or respective public bodies that contain either a specific type of data (e.g. census data, crime data) or a specific collection of datasets (e.g. health data from the NHS, data about London). Some portals are less up-to-date than others, so it is wise to double-check with the ‘originators’ of the data to see if there are more recent versions. For our practical, we will access data from two portals: For our administrative boundaries, we will download the spatial data from the London Datastore (which is exactly what it sounds like). For population, we will download attribute data from the Office of National Statistics (ONS). 2.4.3 Housekeeping Before we download our data, it is important to establish an organised file systems that we will use throughout the module: Create a GEOG0030 folder in your Documents folder on your computer. Within your GEOG0030 folder, create the following subfolders: Folder name Purpose data To store both raw data sets and final outputs. maps To save the maps you produce during your tutorials. Within your data folder, create the following subfolders: Folder name Purpose raw To store all your raw data files that have not yet been processed. output To store all your final data files that have been processed and analysed, potentially ready to be mapped. 2.4.4 Downloading data We will start by downloading the administrative geography boundaries: Navigate to the relevant page on the London Datastore: [Link]. Download all three zipfiles to your computer: statistical-gis-boundaries-london.zip, London-wards-2014.zip and London-wards-2018.zip. The first dataset contains all levels of London’s administrative boundaries. In descending size order: Borough, Ward, Middle layer Super Output Area (MSOA), Lower layer Super Output Area (LSOA), and Output Area (OA) based on the 2011 Census. The second dataset contains an updated version of the Ward boundaries, as of 2014. The third dataset contains yet another updated version of the Ward boundaries, as of 2018. As we will be looking at population data for 2015 and 2019, it is best practice to use those boundaries that are most reflective of the ‘geography’ at the time; therefore, we will use these 2014 / 2018 Ward boundaries for our 2015 / 2019 population dataset, respectively. Tip Once downloaded, you will need to unzip all files before you can use them. To unzip the file, you can use the built-in functionality of your computer’s operating system. For Windows: right click on the zip file, select Extract All, and then follow the instructions. For Mac OS: double-click on the the zip file and it should unzip automatically. Once unzipped, you will find two folders: Esri and MapInfo. These folders contain the same data but in different data formats: Esri shapefile and MapInfo TAB. Note MapInfo is another proprietary GIS software, which has historically been used in public sectors services in the UK and abroad, although has generally been replaced by either Esri’s ecosystem or open-source software GIS. Now open your GEOG0030/data/raw/ folder and create a new folder called boundaries. Within this folder, create three new folders: 2011, 2014 and 2018. Copy the entire contents of Esri folder of each year into their respective year folder. We do not want to add the additional Esri folder as a step in our filesystem, i.e. your file paths should read: GEOG0030/data/raw/boundaries/2011 for the 2011 boundaries, GEOG0030/data/raw/boundaries/2014 for the 2014 boundaries, and GEOG0030/data/raw/boundaries/2018 for the 2018 boundaries. Figure 2.3: Your setup should look something like this. We now have our administrative geography files ready for use. Note Administrative geographies are a way of dividing the country into smaller sub-divisions or areas that correspond with the area of responsibility of local authorities and government bodies. These administrative sub-divisions and their associated geography have several important uses, including assigning electoral constituencies, defining jurisdiction of courts, planning public healthcare provision, as well as what we are concerned with: used as a mechanism for collecting census data and assigning the resulting datasets to a specific administrative unit. These geographies are updated as populations evolve and as a result, the boundaries of the administrative geographies are subject to either periodic or occasional change. The UK has quite a complex administrative geography, particularly due to having several countries within one overriding administration and then multiple ways of dividing the countries according to specific applications. More details on the administrative geographies of the UK can be found on the website of the Office for National Statistics. For our population datasets, we will use the ONS mid-year estimates (MYE). These population datasets are estimates that are based on the 2011 census count and then updated with estimated population growth. They are released once a year, with a delay of a year. Today we will use the data for 2011, 2015, and 2019. Navigate to the Ward level datasets: [Link] When you navigate to this page, you will find multiple choices of data to download. We will need to download the estimates for 2011, 2015 and 2019. Click to download each of the zipfiles. Choose the revised versions for 2015 and the (Census-based) 2011 Wards edition for 2011. In your GEOG0030/data/raw/ folder, create a new folder called population, unzip your downloaded files, and copy the three spreadsheets to the newly created population folder. Rename the files you donwloaded to: MYE_ward_2011.xls, MYE_ward_2015.xls, and MYE_ward_2019.xlsx. Now it is time to do some quite extensive data cleaning and preparation. 2.4.5 Cleaning data When you open up any of the Ward spreadsheets in Excel =, you will notice that there are several worksheets contained in this workbook. However, we are only interested in the total population tab. We therefore need to copy over the data from the 2011, 2015 and 2019 datasets into separate csv files. 2.4.5.1 London population in 2011 Open the 2011 Ward spreadsheet in Excel. Click on the Mid-2011 Persons tab and have a look at the data. As you should be able to see, we have a set of different fields (e.g. Ward Code, Ward Name), including population counts. Because we do not need all the data in the spreadsheet, we will extract only the data we need for our analysis. This means we need the total population (All Ages) data, alongside some identifying information that distinguishes each record from one another. Here we can see that both Ward Code and Ward Name suit this requirement. We can also think that the Local Authority column might be of use, so we also keep this information. Create a new Excel spreadsheet Excel and from the Mid-2011 Persons spreadsheet, copy over all cells from columns A to D and rows 4 to 636 into this new spreadsheet. Row 636 denotes the end of the Greater London Wards (i.e. the end of the Westminster Local Authority) which are kept (in most scenarios) at the top of the spreadsheet as their Ward Codes are the first in sequential order. Before we go any further, we need to format our data. First, we want to rename our fields to remove the spaces and superscript formatting. Re-title the fields as follows: ward_code, ward_name, local_authority and pop2011. One further bit of formatting that you must do before saving your data is to format our population field. At the moment, you will see that there are commas separating the thousands within our values. If we leave these commas in our values, QGIS will read them as decimal points, creating decimal values of our population. There are many points at which we could solve this issue, but the easiest point is now - we will strip our population values of the commas and set them to integer (whole numbers) values. To format the pop2011 column, select the entire column and right-click on the D cell. Click on Format Cells and set the Cells to Number with 0 decimal places. You should see that the commas are now removed from your population values. Save your spreadsheet into your output folder as ward_population_2011.csv. 2.4.5.2 London population in 2015 Open the 2015 Ward spreadsheet in Excel. As you will see again, there are plenty of worksheets available and we want to select the Mid-2015 Persons tab. We now need to copy over the data from our 2015 dataset to a new spreadsheet again. However, at first instance, you will notice that the City of London (CoL) Wards are missing from this dataset. Then if you scroll to the end of the London Local Authorities, i.e. to the bottom of Westminster, what you should notice is that the final row for the Westminster data is in fact row 575 - this suggests we are missing the data fror some Local Authorities (LAs). We need to determine which ones are missing and try to find them in the 2015 spreadsheet. With this in mind, start by copying over all cells from columns A to D and rows 5 to 575 into a new spreadsheet. If you were to compare the names of the London Boroughs that we have now copied with the full list, you would notice that we are missing City of London, Hackney, Kensington and Chelsea, and Tower Hamlets. If we head back to the original 2015 raw dataset, we can actually find this data (as well as the City of London) further down in the spreadsheet. It seems like these LAs had their codes revised in the 2014 revision and are no longer in the same order as the 2011 dataset. Locate the data for the City of London, Hackney, Kensington and Chelsea and Tower Hamlets and copy this over into our new spreadsheet. Double-check that you now have in total 637 Wards within your dataset. Remember to rename the fields as above, but change your population field to pop2015. Also, remember to reformat the values in your pop2015 column. Once complete, save your spreadsheet into your output folder as ward_population_2015.csv. 2.4.5.3 London population in 2019 Open the 2019 Ward spreadsheet in Excel. This time we are interested in the Mid-2019 Persons tab. This time the data that we are interested in can be found in columns A, B, D and G. Because the columns that we want are not positioned next to one another, start by hiding columns C, E and F. You can do this by right-clicking on the colums you want to hide and selecting Hide. Next, copy the data from row 5 to the final row for the Westminster data for columns A, B, D and G over into a new spreadsheet. If you look at the total rows that we have copied over, we have even fewer Wards than the 2015 dataset. This time we are not only missing data for City of London, Hackney, Kensington and Chelsea, Tower Hamlets but also for Bexley, Croydon, Redbridge, and Southwark. Copy over the remaining Wards for these Local Authorities/Boroughs. Once you’ve copied them over - you should now have 640 Wards. Delete columns C, E and F and rename the remaining fields as you have done previously. Also, remember to reformat the values in your pop2019 column. Once complete, save your spreadsheet into your output folder as ward_population_2019.csv. You should now have your three population csv datasets in your output folder. We are now (finally) ready to start using our data within QGIS. 2.4.6 Using QGIS to map our population data 2.4.6.1 Setting up a project We will now use QGIS to create population maps for the Wards in London across our three time periods. To achieve this, we need to join our table data to our spatial datasets and then map our populations for our visual analysis. Because, as we have seen above, we have issues with the number of Wards and changes in boundaries across our three years, we will not (for now) complete any quantitative analysis of these population changes - this would require significant additional processing that we do not have time for today. Note Data interoperability is a key issue that you will face in spatial analysis, particularly when it comes to Administrative Geographies. Start QGIS. Let’s start a new project. Click on Project -&gt; New. Save your project as w2-pop-analysis. Remember to save your work throughout the practical. Before we get started with adding data, we will first set the Coordinate Reference System of our Project. Click on Project -&gt; Properties – CRS. In the Filter box, type British National Grid. Select OSGB 1936 / British National Grid - EPSG:27700 and click Apply. Click OK. Note We will explain CRSs and using CRSs in GIS software in more detail next week. 2.4.6.2 Adding layers We will first focus on loading and joining the 2011 datasets. Click on Layer -&gt; Add Layer -&gt; Add Vector Layer. With File select as your source type, click on the small three dots button and navigate to your 2011 boundary files. Here, we will select the London_Ward.shp dataset. Click on the .shp file of this dataset and click Open. Then click Add. You may need to close the box after adding the layer. We can take a moment just to look at our Ward data - and recognise the shape of London. Can you see the City of London in the dataset? It has the smallest Wards in the entire London area. With the dataset loaded, we can now explore it in a little more detail. We want to check out two things about our data: first, its Properties and secondly, its Attribute Table. Right-click on the London_Ward layer and open the Attribute Table and look at how the attributes are stored and presented in the table. Explore the different buttons in the Attribute Table and see if you can figure out what they mean. Once done, close the Attribute Table. Right-click on the London_Ward layer and select Properties. Click through the different tabs and see what they contain. Keep the Properties box open. Before adding our population data, we can make a quick map of the Wards in London - we can add labels and change the symbolisation of our Wards. In the Properties box, click on the Symbology tab - this is where we can change how our data layer looks. For example, here we can change the line and fill colour of our Wards utilising either the default options available or clicking on Simple Fill and changing these properties directly. Keep the overall styling to a Single Symbol for now - we will get back to this once we have added the population data. You can also click on the Labels tab - and set the Labels option to Single labels. QGIS will default to the NAME column within our data. You can change the properties of these labels using the options available. Change the font to Futura and size 8 and under the add a small buffer to the labels by selecting Draw text bufer under the Buffer tab. You can click Apply to see what your labels look like. Please note that the background colour may differ. Figure 2.4: It looks incredibly busy. Click OK once you are done changing the Symbology and Label style of your data to return to the main window. Note The main strength of a GUI GIS system is that is really helps us understand how we can visualise spatial data. Even with just these two shapefiles loaded, we can understand two key concepts of using spatial data within GIS. The first, and this is only really relevant to GUI GIS systems, is that each layer can either be turned on or off, to make it visible or not (try clicking the tick box to the left of each layer). This is probably a feature you are used to working with if you have played with interactive web mapping applications before! The second concept is the order in which your layers are drawn – and this is relevant for both GUI GIS and when using plotting libraries such as ggplot2 or tmap in RStudio. Your layers will be drawn depending on the order in which your layers are either tabled (as in a GUI GIS) or ‘called’ in your function in code. Being aware of this need for ‘order’ is important when we shift to using RStudio and tmap to plot our maps, as if you do not layer your data correctly in your code, your map will end up not looking as you hoped! For us using QGIS right now, the layers will be drawn from bottom to top. At the moment, we only have one layer loaded, so we do not need to worry about our order right now - but as we add in our 2015 and 2018 Ward files, it is useful to know about this order as we will need to display them individually to export them at the end. 2.4.6.3 Conducting an attribute join We are now going to join our 2011 population data to our 2011 shapefile. First, we need to add the 2011 population data to our project. Click on Layer -&gt; Add Layer -&gt; Add Delimited Text Layer. Click on the three dots button again and navigate to your 2011 population data in your working folder. Your file format should be set to csv. You should have the following boxes clicked under the Record and Field options menu: Decimal separator is comma, First record has field names, Detect field types and Discard empty fields. QGIS does many of these by default, but do double-check! Set the Geometry to No geometry (attribute only table) under the Geometry Definition menu. Then click Add and Close. You should now see a table added to your Layers box. We can now join this table data to our spatial data using an Attribute Join. Note An attribute join is one of two types of data joins you will use in spatial analysis (the other is a spatial join, which we will look at later on in the module). An attribute join essentially allows you to join two datasets together, as long as they share a common attribute to facilitate the ‘matching’ of rows: Essentially you need a single unique identifying ID field for your records within both datasets: this can be a code, a name or any other string of information. In spatial analysis, we always oin our table data to our shape data (One way to think about it as attaching the table data to each shape). As a result, your target layer is always the shapefile (or spatial data) whereas your join layer is the table data. These are known as the left- and right-side tables when working with code. To make a join work, you need to make sure your ID field is correct across both datasets, i.e. no typos or spelling mistakes. Computers can only follow instructions, so they do not know that St. Thomas in one dataset is that same as St Thomas in another, or even Saint Thomas! It will be looking for an exact match! As a result, whilst in our datasets we have kept both the name and code for both the boundary data and the population data, when creating the join, we will always prefer to use the CODE over their names. Unlike names, codes reduce the likelihood of error and mismatch because they do not rely on understanding spelling! Common errors, such as adding in spaces or using 0 instead O (and vice versa) can still happen – but it is less likely. To make our join work, we need to check that we have a matching UID across both our datasets. We therefore need to look at the tables of both datasets and check what attributes we have that could be used for this possible match. Open up the Attribute Tables of each layer and check what fields we have that could be used for the join. We can see that both our respective “code” fields have the same codes (ward_code and GSS_code) so we can use these to create our joins. Right-click on your London_Ward layer -&gt; Properties and then click on the Joins tab. Click on the + button. Make sure the Join Layer is set to ward_population_2011. Set the Join field to ward_code. Set the Target field to GSS_code. Click the Joined Fields box and click to only select the pop2011 field. Click on the Custom Field Name Prefix and remove the pre-entered text to leave it blank. Click on OK. Click on Apply in the main Join tab and then click OK to return to the main QGIS window. We can now check to see if our join has worked by opening up our London_Ward Attribute Table and looking to see if our Wards now have a Population field attached to it. Right-click on the London_Ward layer and open the Attribute Table and check that the population data column has been added to the table. As long as it has joined, you can move forward with the next steps. If your join has not worked, try the steps again - and if you are still struggling, do let us know. Note Now, the join that you have created between your Ward and population datasets in only held in QGIS’s memory. If you were to close the programme now, you would lose this join and have to repeat it the next time you opened QGIS. To prevent this from happening, we need to export our dataset to a new shapefile - and then re-add this to the map. Let’s do this now: Right-click on your London_Ward shapefile and click Export -&gt; Save Features As…. The format should be set to an ESRI shapefile. Then click on the three dots buttons and navigate to your output folder and enter: ward_population_2011 as your file name. Check that the CRS is British National Grid. Leave the remaining fields as selected, but check that the Add saved file to map is checked. Click OK. You should now see our new shapefile add itself to our map. You can now remove the original London_Ward and ward_population_2011 datasets from our Layers box (Right-click on the layers and opt for Remove Layer…). The final thing we would like to do with this dataset is to style our dataset by our newly added population field to show population distribution around London. To do this, again right-click on the Layer -&gt; Properties -&gt; Symbology. This time, we want to style our data using a Graduated symbology. Change this option in the tab and then choose pop2011 as your column. We can then change the color ramp to suit our aesthetic preferences - Viridis seems to be the cool colour scheme at the moment, and we will choose to invert our ramp as well. The final thing we need to do is classify our data - what this simply means is to decide how to group the values in our dataset together to create the graduated representation. We will be looking at this in later weeks, but for now, we will use the Natural Breaks option. Click on the drop-down next to Mode, select Natural Breaks, change it to 7 classes and then click Classify. Finally click Apply to style your dataset. Tip Understanding what classification is appropriate to visualise your data is an important step within spatial analysis and visualisation, and something you will learn more about in the following weeks. Overall, they should be determined by understanding your data’s distribution and match your visualisation accordingly. Feel free to explore using the different options with your dataset at the moment – the results are almost instantaneous using QGIS, which makes it a good playground to see how certain parameters or settings can change your output. You should now be looking at something like this: Figure 2.5: Your result. You will be able to see that we have some missing data - and this is for several Wards within the City of London. This is because census data is only recorded for 8 out of the 25 Wards and therefore we have no data for the remaining Wards. As a result, these Wards are left blank, i.e. white, to represent a NODATA value. Note One thing to flag is that NODATA means no data - whereas 0, particularly in a scenario like this, would be an actual numeric value. It is important to remember this when processing and visualising data, to make sure you do not represent a NODATA value incorrectly. 2.4.7 Exporting map for visual analysis To export your map select only the map layers you want to export and then opt for Project -&gt; Import/Export -&gt; Export to Image and save your final map in your maps folder. You may want to create a folder for these maps titled w02. Next week, we will look at how to style our maps using the main map conventions (adding North Arrows, Scale Bars and Legends) but for now a simple picture will do. 2.5 Assignment You now need to repeat the entire process for your 2015 and 2019 datasets. Remember, you need to: Load the respective Ward dataset as a Vector Layer. Load the respective Population dataset as a Delimited Text File Layer (remember the settings!). Join the two datasets together using the Join tool in the Ward dataset Properties box. Export your joined dataset into a new dataset within your output folder. Style your data appropriately. Export your maps as an image to your maps folder. To make visual comparisons against our three datasets, theoretically we would need to standardise the breaks at which our classification schemes are set at. To set all three datasets to the same breaks, you can do the following: Right-click on the ward_population_2019 dataset and navigate to the Symbology tab. Double-click on the Values for the smallest classification group and set the Lower value to 141 (this is the lowest figure across our datasets, found in the 2015 data). Click OK, then click Apply, then click OK to return to the main QGIS screen. Right-click again on the ward_population_2019 dataset but this time, click on Styles -&gt; Copy Styles -&gt; Symbology. Now right-click on the ward_population_2015 file, but this time after clicking on Styles -&gt; Paste Style -&gt; Symbology. You should now see the classification breaks in the 2015 dataset change to match those in the 2019 data. Repeat this for the 2011 dataset as well. The final thing you need to do is to now change the classification column in the Symbology tab for the 2015 and 2011 datasets back to their original columns and press Apply. You will see when you first load up their Symbology options this is set to pop2019, which of course does not exist within this dataset. 2.6 Before you leave Save your project so you can go back to it if you need to, other than that that is it for this week! "],["cartography-and-visualisation.html", "3 Cartography and Visualisation 3.1 Lecture slides 3.2 Reading list 3.3 Crime in London I 3.4 Assignment 3.5 Before you leave", " 3 Cartography and Visualisation This week’s lecture has given you an in-depth introduction into how we can create a successful map, including understanding map projections, cartographic conventions and issues faced with the analysis of aggregated data at areal units. The practical component of the week puts some of these learnings into practice as we analyse crime rates within London at two different scales. 3.1 Lecture slides The slides for this week’s lecture can be downloaded here: [Link]. 3.2 Reading list Essential readings Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 4: Georeferencing. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; Systems, Chapter 11: Cartography and Map Production. [Link] Wong, D. 2009. Modifiable Areal Unit Problem. International Encyclopedia of Human Geography 169-174. [Link] Suggested readings Longley, P. et al. 2015. Geographic Information Science &amp; systems, Chapter 12: Geovisualization. [Link] Usery, L. and Seong, J. 2001. All equal-area map projections are created equal, but some are more equal than others. Cartography and Geographic Information Science 28(3): 183-194. [Link] 3.3 Crime in London I Over the next few weeks, we will look to model driving factors behind crime across London from both a statistical and spatial perspective. As Reid et al. (2018) argue: Spatial analysis can be employed in both an exploratory and well as a more confirmatory manner with the primary purpose of identifying how certain community or ecological factors (such as population characteristics or the built environment) influence the spatial patterns of crime. Against this background, we are actually going to answer a very simple question today: does our perception of crime (and its distribution) in London vary at different scales? Here we are looking to test whether we would make the ecological fallacy mistake of assuming patterns at the Ward level are the same at the Borough level by looking to directly account for the impact of the Modifiable Area Unit Problem within our results. To test this, we will use these two administrative geographies to aggregate crime data for London in 2020. Here we will be looking specifically at a specific type of crime: Theft from a person. 3.3.1 Finding our datasets As we saw last week, accessing data within the UK, and specifically for London, is relatively straight-forward - you simply need to know which data portal contains the dataset you want! Note The datasets you will create in this practical will be used in other practicals, so make sure to follow every step and export your data into your output folder at the end. The practical will also introduce you to point-in-polygon counts. You will be using this type of analysis throughout this module, so it is incredibly important that you understand how they work – even as seemingly simple as they may be! 3.3.1.1 Crime data For our crime data, we will use data directly from the Police Data Portal, which you can find at https://data.police.uk/. This Data Portal allows you to access and generate tabular data for crime recorded in the U.K. across different the different Police Forces since 2017. In total, there are 45 territorial police forces (TPF) and 3 special police forces (SPF) of the United Kingdom. Each TPF covers a specific area in the UK (e.g. the “West Midlands Police Force”), whilst the SPFs are cross-jurisdiction and cover specific types of crime, such as the British Transport Police. Therefore, when we want to download data for a specific area, we need to know which Police Force covers our area interest. When you look to download crime data for London, for example, there are two territorial police forces working within the city and its greater metropolitan area: The Metropolitan Police Force (The Met), which covers nearly the entire London area, including Greater London The City of London (CoL) Police, which covers the City of London. The Met has no jurisdiction in the CoL. You therefore need to decide if you want to include an analysis of crime in the City of London or not - we will in our current study. 3.3.1.2 Population data We know that if we want to study a phenomena like crime and aggregate it to an areal unit, we will need to normalise this by our population. Luckily, we already sorted out our Ward population dataset last week (i.e. ward_population_2019.shp). In addition to our Ward level dataset, we also want to generate the same type of shapefile for our London Boroughs, i.e. a borough_population_2019.shp, utilising the same approach as last week, joining our population table data to our Borough shape data. To do this, we need to know where to get both our required datasets from - fortunately, you already have a Borough shapefile in your raw/boundaries/2011 folder. Therefore, it is just a case of tracking down the same Mid-Year Estimates (MYE) for London Boroughs as we did for the Wards. Note Because the boundaries of the London Boroughs have not been changed since 1965, we can get away with using the 2011 shapefile instead of having to download a more up to date version. 3.3.2 Downloading data As outlined above, to get going with our analysis, we need to download both the population data for our Boroughs and the 2020 crime data for our two police forces in London. Let us tackle the population data first. 3.3.2.1 Borough population Through a quick search, we can find our Borough population table data pretty much in the same place as our Ward data - however it is a separate spreadsheet to download. Navigate to the data on the website of the Office for National Statistics: [Link]. Download the Mid-2019: April 2020 local authority district codes .xls file. Open the dataset in your spreadsheet editing software and navigate to the MYE2-Persons tab. Now extract: Code, Name, Geography and All ages data for all London Boroughs. You should have a total of 33 Boroughs. Once you have your 33 Boroughs separated from the rest of the data, copy the columns (Code, Name, Geography and All ages) and respective data for each Borough into a new csv. Remember to format the field names. Like last week, also remember to make sure that the All ages field is recognised as a numeric field. Save as a new csv in your output folder: borough_population_2019.csv. 3.3.2.2 Ward population As mentioned above, you should already have a ward_population_2019.shp file within your output data folder. 3.3.2.3 Crime data Normally, we would now head to the Police Data Portal and download our crime data. However, the manual processing that is required is too exhaustive to do manually - and far (far!) easier to do using programming. As such you can download a pre-filtered spreadsheet instead. Unzip the download and copy the csv into a new folder in your raw data folder called: crime. File download File Type Link Theft from persons in 2020 csv Download Note When mapping the data from the provided longitude and latitude coordinates, it is important to know that these locations represent the approximate location of a crime — not the exact place that it happened. This displacement occurs to preserve anonymity of the individuals involved. The process by how this displacement occurs is standardised. There is a list of anonymous map points to which the exact location of each crime is compared against this master list to find the nearest map point. The co-ordinates of the actual crime are then replaced with the co-ordinates of the map point. Each map point is specifically chosen to avoid associating that point with an exact household. Interestingly enough, the police also convert the data from their recorded BNG eastings and northings into WGS84 latitude and longitude. 3.3.3 Using QGIS to map our crime data 3.3.3.1 Setting up a project Start QGIS Click on Project -&gt; New. Save your project as w3-crime-analysis. Remember to save your work throughout the practical. Before we get started with adding data, we will first set the Coordinate Reference System of our Project. Click on Project -&gt; Properties – CRS. In the Filter box, type British National Grid. Select OSGB 1936 / British National Grid - EPSG:27700 and click Apply. Click OK. Now we have our Project CRS set, we are ready to start loading and processing our data. 3.3.3.2 Adding layers Click on Layer -&gt; Add Layer -&gt; Add Vector Layer. With File select as your source type, click on the small three dots button and navigate to your ward_population_2019.shp in your output folder. Click on the .shp file of this dataset and click Open. Then click Add. You may need to close the box after adding the layer. We now need to create our Borough population shapefile - and to do so, we need to repeat exactly the same process as last week in terms of joining our table data to our shapefile. You should now be able to do this, so we will not provide you with detailed instructions. Remember, you need to: Load the respective Borough dataset as a Vector Layer found in your raw/boundaries/2011 data folder: London_Borough_Excluding_MHW.shp. Load the respective population dataset that you just created as a Delimited Text File Layer. Remember the settings, including no geometry! Join the two datasets together using the Join tool in the Borough dataset Properties box. Remember which fields to use, which to add, and to remove the prefix. Export your joined dataset into a new dataset within your output folder: borough_population_2019.shp. Make sure this dataset is loaded into your Layers / Added to the map. Remove the original Borough and population data layers. Once this is done, we are ready to load and map our crime data. We will load this data using the Delimited Text File Layer option you would have used just now to load the Borough population - but this time, we will be adding point coordinates to map our crime data as points. Click on Layer -&gt; Add Layer -&gt; Add Delimited Text File Layer. With File select as your source type, click on the small three dots button and navigate to your crime_theft_2020.csv in your raw/crime folder. Click on the .csv file of this dataset and click Open. In Record and Fields Options tick Decimal separator is comma, First record has field names, Detect field types and Discard empty fields. Under Geometry Definition, select Point coordinates and set the X field to Longitude and the Y field to Latitude. The Geometry CRS should be: EPSG:4326 - WGS84. Click Add. Note You may be wondering whether we are not using the incorrect CRS for our data. As you click Add, you should have gotten a a pop-up from QGIS asking about transformations - they are the mathematical algorithms that convert data from one CRS to another. And this is exactly what QGIS is trying to do. QGIS knows that the Project CRS is BNG but the Layer you are trying to add has a WGS84 CRS. QGIS is asking you what transformation it should use to project the Layer in the Project CRS. This is because one key strength of QGIS is that it can project data “on the fly”. What this means is that QGIS will automatically convert all Layers to the Project CRS once it knows which transformation you would like to use so that they will all be rendered in the correct position with respect to each other. However, you must note that this transformation is only temporary in nature and as a result, it is not a full reprojection of our data. More details on this can be found in QGIS’ user manual section on working with projections. For now, let us use the on-the-fly projection and accept QGIS’ default value by clicking OK. This transformation should be built-in to your QGIS transformation library, whereas some of the more accurate options would need installation. You should now see your crime dataset displayed on the map. Figure 3.1: Borough map with crime data. We can test the ‘temporary’ nature of the projection by looking at the CRS of the crime_theft_2020 layer: Right-click on the crime_theft_2020 layer then select Properties -&gt; Information and then look at the associated CRS. You should see that the CRS of the layer is still WGS84. We want to make sure our analysis is as accurate and efficient as possible, so it is best to reproject our data into the same CRS as our administrative datasets, i.e. British National Grid. This also means we will have the dataset to use in other projects, just in case. Back in the main QGIS window, click on Vector -&gt; Data Management Tools -&gt; Reproject Layer. Fill in the parameters as follows: Input Layer: crime_theft_2020 Target CRS: Project CRS: EPSG: 27700 Reprojected: Click on the three buttons and Save to File to create a new data file. Save it in your output folder as crime_theft_2020_BNG.shp Click Run and then close the tool box. You should now see the new data layer added to your Layers. Note QGIS can at times be a little bit buggy so when it creates new data layers in your Layers box, it often automates the name, hence you might see your layer added as Reprojected. It does this with other management and analysis tools as well, so something to be aware of. Before moving on, let us do some housekeeping. Remove the original crime_theft_2020 dataset, only keeping the reprojected version. Rename the Reprojected dataset to crime_theft_2020. Now we have an organised Layers and project, we are ready to start our crime analysis. 3.3.3.3 Counting points-in-polygons The next step of our analysis is incredibly simple - as QGIS has an in-built tool for us to use. We will use the Count Points in Polygons in the Analysis toolset for Vector data to count how many crimes have occured in both our Wards and our Boroughs. We will then have our count statistic which we will need to normalise by our population data to create our crime rate final statistic. Let’s get going and first start with calculating the crime rate for the Borough scale: Click on Vector -&gt; Analysis Tools -&gt; Count Points in Polygons. Within the toolbox, select the parameters as follows: Polygons: borough_population_2019 Points: crime_theft_2020 (Note how both our data layers state the same CRS!) No weight field or class field Count field names: crimecount Click on the three dot button and Save to file: output -&gt; borough_crime_2020.shp Click Run and Close the box. You should now see a Count layer added to your Layers box. Click the checkbox next to crime_theft_2020 to hide the crime points layer for now. Right-click on the borough_crime_2020 layer and open the Attribute Table. You should now see a crimecount column next to your pop2019 column. You can look through the column to see the different levels of crime in the each Borough. You can also sort the column, from small to big, big to small, like you would do in a spreadsheet software. Whilst it is great that we have ve got our crimecount, as we know, what we actually need is a crime rate to account for the different population sizes accross the Boroughs. To get our crime rate statistic, we are going to do our first bit of table manipulation in QGIS. With the Attribute Table of your Count layer still open, click on the pencil icon at the top left corner. This pencil switches on the Editing mode. The Editing mode allows you to edit both the Attribute Table values and the geometry of your data. When it comes to the Attribute Table, it means you can directly edit existing values in the table or create and add new fields to the table. Whilst you can actually do the latter outside of the Editing mode, this Editing mode means you can reverse any edits you make and they are not permanent just in case you make a mistake. Using the Editing mode is the safest approach to editing your table, however, it might not always be the approach you use when generating new fields. Let us go ahead and add a new field to contain our Crime Rate. Whilst in the Editing mode, click on New Field button (or Ctrl+W/CMD+W) and fill in the Field Parameters as follows: Name: crime_rate Comment: leave blank Type: Decimal number Length: 10 Precision: 0 Click OK, You should now see a new field added to our Attribute Table. Note Understanding how to add new fields and their parameters rely on you understanding the different data types we covered last week - and thinking through what sort of data type your field needs to contain. In our case, we will store our data as a decimal to enable our final calculation to produce a decimal (an integer/integer is likely to produce a decimal) but we will set the precision to 0 to have zero places after our decimal place when the data is used. That is because ultimately, we want our crime rate represented as an integer because, realistically, you cannot have half a crime. Calculating a decimal however will allow us to round-up within our calculations. The empty field has NULL populated for each row - so we need to find a way to give our Boroughs some crime rate data. To do this, we will calculate a simple Crime Rate using the Field Calculator tool provided by QGIS within the Attribute Table. We will create a crime rate that details the number of crimes per 10,000 people in the Borough. In most cases, a crime rate per person will create a decimal result less than 1 which not only will not be stored correctly by our crime_rate field but, for many people, a decimal value is hard to interpret and understand. Whilst still in the Editing mode, click on the Abacus button (Ctrl + I / Cmd + I), which is known as the Field Calculator. A new pop-up should load up. In the Field Calculator pop-up: Check the Update existing field box. Use the drop-down to select the crime_ratefield. In the Expression editor, add the following expression: ( “crimecount” / “pop2019” ) * 10000 You can type this in manually or use the Fields and Values selector in the box in the middle to add the fields into the editor. Once done, click OK. You should then return to the Attribute Table and see our newly populated crime_rate field - at the moment, we can see the resulting calculations stored as decimals. Click on the Save button to save these edits. Click again on the Pencil button to exit Editing mode - you should see the numbers turn to integers. Note On some computers and installations the numbers do not get changed to an integer, but remain a double. If this happens, create a new field directly in the Field Calculator. instead of ticking the Update existing field box you keep the Create a new field box ticked. Name the new field crime_rate_int, make sure the Output field type is set to Whole number (integer), and use the same expression as above to get the crime rate in a new column. Rename your Borough crime rate layer to Borough Crime Rate. Great! We now have our Borough crime rate dataset ready for mapping and analysis - we just now need to repeat this process to have our Ward dataset. So: repeat the above processes to create a crime_rate column within our Ward dataset ready for mapping and analysis. 3.3.3.4 Mapping our crime data Now you have both datasets ready, it is time to style the maps. Remember to use the Properties box to first symbolise your maps. Think through using the appropriate colour scheme - and perhaps have a look online for some examples if you do not want to use the defaults. Once you are happy with their symbolisation, we will turn them into proper publishable maps using QGIS’s Print Layout. If you have ever used ArcMap, this is similar to switch the view of your map canvas to a print layout within the main window - but in QGIS’s case, it loads up a new window. From the main QGIS window, click on Project -&gt; New Print Layout. In the small box that first appears, call your new print layout: crime_map_borough_ward. A new window should appear. Initially, when opening the print layout provides you with a blank canvas that represents the paper surface when using the print option. On the left-hand side of the window, you will find buttons beside the canvas to add print layout items: the current QGIS map canvas, text labels, images, legends, scale bars, basic shapes, arrows, attribute tables and HTML frames. In this toolbar you also find buttons to navigate, zoom in on an area and pan the view on the layout a well as buttons to select any layout item and to move the contents of the map item. On the right-hand side of the window, you will find two set of panels. The upper one holds the panels Items and Undo History and the lower holds the panels Layout, Item properties and Atlas generation. For our practical today, we’re most interested in the bottom panel as Layout will control the overall look of our map, whilst Item properties will allow us to customise the elements, such as Title or Legend, that we may add to our map. In the bottom part of the window, you can find a status bar with mouse position, current page number, a combo box to set the zoom level and the number of selected items if applicable. In the upper part of the window, you can find menus and other toolbars. All print layout tools are available in menus and as icons in a toolbar. Tip Working with maps in the Print Layout is simple but it can be a little fiddly and, to make more complicated maps, requires you to understand how to use certain aspects of Print Layout, such as locking items. If you get stuck, have a look at the training manual or the detailed documentation. To start with creating a map, you use the Add Map tool to draw a box in which a snapshot of the current active map you have displayed in your QGIS main window will be loaded. Click on the Add Map tool and draw a box in the first half of our map to load our current map. Note, you can move your map around and resize the box simply by clicking on it as you would in Word etc. Figure 3.2: Current active map in the Print Layout. As you can see, the map currently does not look that great - we could really do with zooming in, as we do not need all of the white space. With your map selected, head to the Items Properties panel and look for the Scale parameter. Here we can manually edit the scale of our map to find the right zoom level. Have a go at entering different values and see what level you think suits the size of your map. Keep a note of the scale, as we will need this for the second map we will add to our map layout - our Borough map. Next, in the same panel, if you would like, you can add a frame to your map - this will draw a box (of your selected formatting) around the current map. In the same panel, note down the size of your map - we want to make sure the next map we add is of the same size. Note, if you need to move the position of the map within the box, look for the Move Item Content tool on the left-hand side toolbar. Once you are done, finally click on the Lock Layers and Lock Style for layers. By locking the Layers (and their symbology) in our map, it means we can change our data/map in our main QGIS window without changing the map in the Print Layout - as we will see in a minute when adding our Borough crime rate map. If we do not lock our layers, our map would automatically update to whatever is next displayed in the main QGIS window. Now we have added our first map to our Map Layout, we want to add a Legend for this specific map. Click on the Add Legend tool and again, draw a box on your map in which your legend will appear. As you will see, your Legend auto-generates an entry for every layer in our Layers box in the main QGIS application: In Item Properties, uncheck auto-update - this stops QGIS automatically populating your legend and enables you to customise your legend. First, let us rename our Layer in the legend to: Ward Crime Rate (per 10,000 people). Next, we want to remove all other Layers, using the - button We can also customise the Legend further, including type, size and alignment of font - go ahead and style your legend as you would prefer. Move the Legend to an appropriate part of the layout near your Ward crime rate map - resize if necessary. Now we are finished with the Ward map, we want to make sure we do not change any aspect of its layout. To do so, we need to lock both the Map and Legend in the Items panel - this prevents us accidentally moving items in our layout. Note, this is different to locking your layers in the Items Properties as we did earlier. In the Items panel, click the Lock check box for both our map and legend. Once locked, we can now start to add our Borough map. In the main QGIS window, uncheck your Ward Crime Rate layer and make sure your Borough Crime Rate layer is now visible. Return to the Print Layout window. Repeat the process above of adding a map to the window - this time, you should now see your Borough map loaded in the box (and you should see no changes to your Ward map). Place your Borough map next to your Ward map - use the snap grids to help. Set your Borough map to the same zoom level as your Ward map. Make sure your Borough map is the same size as your Ward map. Set your Borough map to the same extent as your Ward map (extra neatness!). Add a frame if you want. Lock your layer and its symbology in the Items Properties once ready and the lock your layer in the Items panel. We now just need to add a second legend for our Borough map. If we had standardised our values across our two maps, then we would only need to use one legend. However, in this case, as there is a difference in the values, we need to have two legends. Repeat the process as above to add a Legend for our Borough map. Remember to re-title the Legend to make it more legible/informative. Match the same formatting for a clean look. Once complete, lock these two items in the Items panel as well. Now we have our two maps ready, we can add our main map elements: Title Orientation Data Source We will not at this time add anything else - an inset map could be nice, but this requires additional data that we do not have at the moment. Any other map elements would also probably make our design look too busy. Using the tools on the left-hand tool bar: Add a scale bar: use the Item Properties to adjust the Style, number of segments, font, etc. Add a north arrow: draw a box to generate the arrow and then use the Item Properties to adjust.. Add a title at the top of the page, and subtitles above the individual maps. Finally add a box detailing our data sources, you can copy and paste the following: Contains National Statistics data © Crown copyright and database right [2015] (Open Government Licence). Contains Ordnance Survey data © Crown copyright and database right [2015]. Crime data obtained from data.police.uk (Open Government Licence). Once you have added these properties in, you should have something that looks a little like this: Figure 3.3: Crime rates in London boroughs and Wards. Note that the numbers in the legend may differ from the numbers in your own legend. The only thing outstanding is to export our map to a file. Go to Layout -&gt; Export as Image and then save it in your maps folder as London_2020_Crime-Rate.png. 3.4 Assignment Looking at the maps you have created, how does your perception of crime (and its distribution) in London vary at different scales? At the moment, we have looked at the crime rate as an amount, therefore we use a sequential colour scheme that shows, predominantly, where the crime rate is the highest. As an alternative, we could use a diverging colour scheme that could show us where the crime rate is lower and/or higher than a critical mid-point, such as the average crime rate across the Wards or Borough. Create a map of crime in London, at both the Borough and Ward level, that shows for each administrative geography the percentage difference from the overall mean crime rate. Tips You will need to start by calculating the average crime rate for both datasets and subsequently calculate the difference from these values for each geography. All calculations can be done using the field calculator in QGIS, but will require some thinking about the right expression. 3.5 Before you leave That is us all done. Remember to save your project and export your Ward and Borough shapefiles to your output folder! "],["programming-for-data-analysis.html", "4 Programming for Data Analysis 4.1 Lecture slides 4.2 Reading list 4.3 Programming 4.4 Programming in R 4.5 RStudio console 4.6 Simple analysis 4.7 Crime in London II 4.8 Assignment 4.9 Want more? [Optional] 4.10 Before you leave", " 4 Programming for Data Analysis This week’s content introduces you to the foundational concepts associated with Programming for Data Analysis. We will cover some general principles of programming as well how we can use R and RStudio effectively for data analysis by continuing to look at crime in London. 4.1 Lecture slides The slides for this week’s lecture can be downloaded here: [Link]. 4.2 Reading list Essential readings Hadley, W. 2017. R for Data Science. Chapter 4: Workflow: basics. [Link] Hadley, W. 2017. R for Data Science. Chapter 5: Data transformation. [Link] Hadley, W. 2017. R for Data Science. Chapter 6: Workflow: scripts. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 1: Introduction. [Link] Suggested readings Arribas-Bel, D. et al. 2021. Open data products - A framework for creating valuable analysis ready data. Journal of Geographical Systems 23: 497-514. [Link] 4.3 Programming Programming is our most fundamental way of interacting with a computer - it was how computers were first built and operated - and for a long time, the Command Line Interface (CLI) was our primary way of using computers before our Graphical User Interface (GUI) Operating Systems (OS) and software became mainstream. Nowadays, the majority of us use our computers through clicking instead of typing. However, programming and computer code underpin every single application that we use on our computers. Programming is used for endless purposes and applications, ranging from software engineering and application development, to creating websites and managing databases at substantial scales. To help with this diversity of applications, multiple types of programming languages have developed - Wikipedia, for example, has a list of 50 different types of languages, although there is some overlap between many of these and some are used for incredibly niche activities. In general, the main programming languages that people focus on learning at the moment include: Figure 4.1: Top 10 programming languages and their applications according to DZone in 2017. 4.4 Programming in R We will be using R and RStudio in this module as the main tool to complete specific tasks we need to do for our data analysis. There are a lot of alternative tools out there that you can use to achieve the same outcomes (as you have seen with QGIS, and no doubt had experience of using some statistics/spreadsheet software) but we choose to use this tool because it provides us with many advantages over these other tools. What is important to understand is that R and RStudio are two different things: R is our programming language, which we need to understand in terms of general principles, syntax and structure. RStudio is our Integrated Development Environment (IDE), which we need to understand in terms of functionality and workflow. An IDE is simply a complicated way of saying “a place where I write and build scripts and execute my code”. As you may know already, R is a free and open-source programming language, that originally was created to focus on statistical analysis. In conjunction with the development of R as a language, the same community created the RStudio IDE to execute this statistical programming. Together, R and RStudio have grown into an incredibly success partnership of analytical programming language and analysis software - and is widely used for academic research as well as in the commercial sector. As a result, it has a huge and active contributor community which constantly adds functionality to the language and software, making it an incredibly useful tool for many purposes and applications beyond statistical analysis. Unlike traditional statistical analysis programmes you may have used such as Microsoft Excel or even ArcGIS Online, within the RStudio IDE, the user has to type commands to get it to execute tasks such as loading in a dataset or performing a calculation. We primarily do this by building up a script, that provides a record of what you have done, whilst also enabling the straightforward repetition of tasks. We can also use the R Console to execute simple instructions that do not need repeating such as installing libraries or quickly viewing data (we will get to this in a second). In addition, R, its various graphic-oriented “packages” and RStudio are capable of making graphs, charts and maps through just a few lines of code (you might notice a Plots window to your right in your RStudio window) - which can then be easily modified and tweaked by making slight changes to the script if mistakes are spotted. Unfortunately, command-line computing can also be off-putting at first. It is easy to make mistakes that are not always obvious to detect and thus debug. Nevertheless, there are good reasons to stick with R and RStudio. These include: It is broadly intuitive with a strong focus on publishable-quality graphics. It is ‘intelligent’ and offers in-built good practice; it tends to stick to statistical conventions and present data in sensible ways. It is free, cross-platform, customisable and extendable with a whole swathe of packages/libraries (‘add ons’) including those for discrete choice, multilevel and longitudinal regression, mapping, spatial statistics, spatial regression, and geostatistics. It is well respected and used at the world’s largest technology companies (including Google, Microsoft and Facebook, and at hundreds of other companies). It offers a transferable skill that shows to potential employers experience both of statistics and of computing. The intention of the practical elements of this week is to provide a thorough introduction to RStudio to get you started: The basic programming principles behind R. Loading in data from csv files, filtering and subsetting it into smaller chunks and joining them together. Calculating a number of statistics for data exploration and checking. Creating basic and more complex plots in order to visualise the distributions values within a dataset. What you should remember is that R has a steep learning curve, but the benefits of using it are well worth the effort. The best way to really learn R is to take the basic code provided in tutorials and experiment with changing parameters - such as the colour of points in a graph - to really get ‘under the hood’ of the software. 4.4.1 The RStudio interface You should all have access to some form of R on your personal computer, or through Desktop@UCL Anywhere or the RStudio Server. If not, please refer to the Geocomputation: An Introduction section. Go ahead and open RStudio and we will first take a quick tour of the various components of the RStudio environment interface and how and when to use them. RStudio has various windows that you use for different purposes - and you can customise its layout dependent on your preference. When you first open RStudio, it should look a little something like this: Figure 4.2: RStudio on RStudio Server. The main windows (panel/pane) to keep focused on for now are: Console: where we write “one-off” code, such as installing libraries/packages, as well as running quick views or plots of our data. Files: where our files are stored on our computer system, also helpful for general file management. Environment: where our variables are recorded; we can find out a lot about our variables by looking at the environment window, including data structure, data type(s) and the fields and ‘attributes’ of our variables. Plots: where the outputs of our graphs, charts and maps are shown Help: where you can search for help, e.g. by typing in a function to find out its parameters. You may also have your Script Window open, which is where we build up and write code, to a) keep a record of our work, b) enable us to repeat and re-run code again, often with different parameters. We will not use this window until we get to the final practical instructions. We will see how we use these windows as we progress through this tutorial and understand in more detail what we mean by words such as ‘attributes’ (do not get confused here with the Attribute Table for QGIS) and data structures. 4.5 RStudio console We will first start off with using RStudio’s console to test out some of R’s in-built functionality by creating a few variables as well as a dummy dataset that we will be able to analyse - and to get familiar with writing code. Tip You might need to click on the console window to get it to expand; you can then drag it to take up a larger space in your RStudio window. In your RStudio console, you should see a prompt sign &gt; on the left hand side. This is where we can directly interact with R. Anything that appears as red in the command line means it is an error (or a warning) so you will likely need to correct your code. If you just a &gt; it means you can type in your next line, a + means that you have not finished the previous line of code. As will become clear, + signs often appear if you do not close brackets or you did not properly finish your command in a way that R expected. In your console, let us go ahead and conduct some quick maths. At their most basic, all programming languages can be used like calculators. 4.5.1 Command Input Type in 10 * 12 into the console. # conduct some maths 10 * 12 ## [1] 120 Once you press return, you should see the answer of 120 returned below. 4.5.2 Storing variables Rather than use ‘raw’ or ‘standalone’ numbers and values, we primarily want to use variables that store these values (or groups of them) under a memorable name for easy reference later. In R terminology this is called creating an object and this object becomes stored as a variable. The &lt;- symbol is used to assign the value to the variable name you have given. Let us create two variables for experimenting with. Type in ten &lt;- 10 into the console and execute. # store a variable ten &lt;- 10 You have just created your first variable. You will see nothing is returned in the console, but if you check your environment window it has now appeared as a new variable that contains the associated value. Type in twelve &lt;- 12 into the console and execute. # store a variable twelve &lt;- 12 Once again, you will see nothing returned to the console but do check your environment window for your variable. We have now stored two numbers into our environment and given them variable names for easy reference. R stores these objects as variables in your computer’s RAM so they can be processed quickly. Without saving your environment (we will come onto this below), these variables would be lost if you close R. Now we have our variables, we can go ahead and execute the same simple multiplication: Type in ten * twelve into the console and execute. # conduct some maths using our variables ten * twelve ## [1] 120 You should see the output in the console of 120. Whilst this maths may look trivial, it is, in fact, extremely powerful as it shows how these variables can be treated in the same way as the values they contain. Next, type in ten * twelve * 8 into the console and execute. # conduct some more maths with variables and raw values ten * twelve * 8 ## [1] 960 You should get an answer of 960. As you can see, we can mix variables with raw values without any problems. We can also store the output of variable calculations as a new variable. Type output &lt;- ten * twelve * 8 into the console and execute. # conduct some maths and store it as output output &lt;- ten * twelve * 8 Because we are storing the output of our maths to a new variable, the answer is not returned to the screen. 4.5.3 Accessing and returning variables We can ask our computer to return this output by simply typing it into the console. You should see we get the same value as the earlier equation. # return the variable output ## [1] 960 4.5.4 Variables of different data types We can also store variables of different data types, not just numbers but text as well. Type in str_variable &lt;- \"This is our first string variable\" into the console and execute. # store a variable str_variable &lt;- &quot;This is our 1st string variable&quot; We have just stored our sentence made from a combination of characters, including letters and numbers. A variable that stores “words” (that may be sentences, or codes, or file names), is known as a string. A string is always denoted by the use of quotation marks (\"\" or ''). Type in str_variable into the console and execute. # return the variable str_variable ## [1] &quot;This is our 1st string variable&quot; You should see our entire sentence returned,enclosed in quotation marks (\"\"). Again, by simply entering our variable into the console, we have asked R to return our variable to us. 4.5.5 Calling functions on our variables We can also call a function on our variable. This use of call is a very specific programming term and generally what you use to say “use” a function. What it simply means is that we will use a specific function to do something to our variable. For example, we can also ask R to print our variable, which will give us the same output as accessing it directly via the console. Type in print(str_variable) into the console and execute. # print str_variable to the screen print(str_variable) ## [1] &quot;This is our 1st string variable&quot; We have just used our first function: print(). This function actively finds the variable and then returns this to our screen. You can type ?print into the console to find out more about the print() function. # gain access to the documentation for our print function ?print This can be used with any function to get access to their documentation which is essential to know how to use the function correctly and understand its output. Note In many cases, a function will take more than one argument or parameter, so it is important to know what you need to provide the function with in order for it to work. For now, we are using functions that only need one required argument although most functions will also have several optional or default parameters. 4.5.6 Returning functions When a function provides an output, such as this, it is known as returning. Not all functions will return an output to your screen, so often we require a print() statement or another type of returning function to check whether the function was successful or not. More on this later. 4.5.7 Examining our variables using functions Within the base R language, there are various functions that have been written to help us examine and find out information about our variables. For example, we can use the typeof() function to check what data type our variable is. Type in typeof(str_variable) into the console and execute. # call the typeof() function on str_variable to return the data type of our variable typeof(str_variable) ## [1] &quot;character&quot; You should see the answer: character. As evident, our str_variable is a character data type. We can try testing this out on one of our earlier variables too. Type in typeof(ten) into the console and execute. # call the typeof() function on ten variable to return the data type of our # variable typeof(ten) ## [1] &quot;double&quot; You should see the answer: double. As evident, our ten is a double data type. For high-level objects that involve (more complicated) data structures, such as when we load a csv into R as a data frame, we are also able to check what class our object is: Type in class(str_variable) into the console and execute. # call the class() function on str_variable to return the class of our object class(str_variable) ## [1] &quot;character&quot; In this case, you will get the same answer because in R both its class and type are the same: a character. In other programming languages, you might have had string returned instead, but this effectively means the same thing. Type in class(ten) into the console and execute. # call the class() function on ten to return the class of our object class(ten) ## [1] &quot;numeric&quot; In this case, you will get a different answer because the class of this variable is numeric. This is because the class of numeric objects can contain either doubles (decimals) or integers (whole numbers). We can test this by asking whether our ten variable is an integer or not. Type in is.integer(ten) into the console and execute. # test our ten variable by asking if it is an integer is.integer(ten) ## [1] FALSE You should see we get the answer FALSE: as we know from our earlier typeof() function our variable ten is stored as a double and therefore cannot be an integer. Note Whilst knowing how to distinguish between different data types might not seem important now, the difference of a double versus an integer can quite easily lead to unexpected errors. We can also ask how long our variable is. in this case, we will find out how many different sets of characters (strings) are stored in our variable, str_variable. Type in length(str_variable) into the console and execute. # call the length() function on str_variable to return the length of our # variable length(str_variable) ## [1] 1 You should get the answer 1 because we only have one set of characters. We can also ask how long each set of characters is within our variable, i.e. ask how long the string contained by our variable is. Type in nchar(str_variable) into the console and execute. # call the nchar() function on str_variable to return the length of each of our # elements within our variable nchar(str_variable) ## [1] 31 You should get an answer of 31. 4.5.8 Creating a two-element object Let us go ahead and test these two ‘length’ functions a little further by creating a new variable to store two string sets within our object, i.e. our variable will hold two elements. Type in two_str_variable &lt;- c(\"This is our second variable\", \"It has two parts to it\") into the console and execute. # store a new variable with two items using the c() function two_str_variable &lt;- c(&quot;This is our second string variable&quot;, &quot;It has two parts to it&quot;) In this piece of code, we have created a new variable using the c() function in R, that stands for combine values into a vector or list. We have provided that function with two sets of strings, using a comma to separate our two strings - all contained within the function’s brackets (()). You should now see a new variable in your environment window which tells us it is a) chr: characters, b) contains two items, and c) lists those items. Let us now try both our length() and nchar() on our new variable and see what the results are. # call the length() function length(two_str_variable) ## [1] 2 # call the nchar() function nchar(two_str_variable) ## [1] 34 22 You should notice that the length() function now returned a 2 and the nchar() function returned two values of 34 and 22. There is one final function that we often want to use with our variables when we are first exploring them, which is attributes(). Because our current variables are very simple, they do not have any attributes but it is a really useful function, which we will come across later on. # call the attributes() function attributes(two_str_variable) ## NULL Note In addition to make notes about the functions you are coming across in the workshop, you should notice that with each line of code in the examples, an additional comment is used to explain what the code does. Comments are denoted using the hash symbol #. This comments out that particular line so that R ignores it when the code is run. These comments will help you in future when you return to scripts a week or so after writing the code as well as help others understand what is going on when sharing your code. It is good practice to get into writing comments as you code and not leave it to do retrospectively. Whilst we are using the console, using comments is not necessary but as we start to build up a script later on, you will find them essential to help understand your workflow in the future. 4.6 Simple analysis The objects we created and played with above are very simple but the real power of R comes when we can begin to execute functions on more complex objects. R accepts four main types of data structures: vectors, matrices, data frames, and lists. These data structures are essential because they allow us to apply common statistical functions. We are going to explore these data structures with some of dummy data on the total number of pages and publication dates of the various editions of Geographic Information Systems and Science (GISS) book by Longley et al. and use these for a brief analysis: Book Edition Year of Publication Total Number of Pages 1st 2001 454 2nd 2005 517 3rd 2011 560 4th 2015 477 4.6.1 Housekeeping First, let us clear up our workspace and remove our current variables. Type rm(ten, twelve, output, str_variable, two_str_variable) into the console and execute. # clear our workspace rm(ten, twelve, output, str_variable, two_str_variable) You should now see we no longer have any variables in our window. We just used the rm() function to remove these variables from our environment and free up some RAM. Keeping a clear workspace is another recommendation of good practice moving forward. Of course, we do not want to get rid of any variables we might need to use later but removing any variables we no longer need (such as test variables) will help you understand and manage your code and your working environment. 4.6.2 Atomic vectors The first complex data object we will create is a vector. A vector is the most common and basic data structure in R. Vectors are a collection of elements that are mostly of either character, logical integer or numeric data types. Technically, vectors can be one of two types: Atomic vectors (all elements are of the same data type) Lists (elements can be of different data types) Although in practice the term “vector” most commonly refers to the atomic types and not to lists. Let us create our first official “complex” vector, detailing the different total page numbers for GISS. Type giss_page_no &lt;- c(454, 517, 560, 477) into the console and execute. # store our total number of pages, in chronological order, as a variable giss_page_no &lt;- c(454, 517, 560, 477) Type print(giss_page_no) into the console and execute to check the results. # print our giss_page_no variable print(giss_page_no) ## [1] 454 517 560 477 We can see we have our total number of pages collected together in a single vector. We could if we want, execute some statistical functions on our vector object. # calculate the arithmetic mean on our variable mean(giss_page_no) ## [1] 502 # calculate the median on our variable median(giss_page_no) ## [1] 497 # calculate the range numbers of our variable range(giss_page_no) ## [1] 454 560 We have now completed our first set of descriptive statistics in R. Let us see how we can build on our vector object by adding in a second vector object that details the relevant years of our book. Note that the total number of pages are entered in a specific order to correspond to these publishing dates (i.e. chronological) and therefore we will need to enter the publication year in the same order. Type giss_year &lt;- c(2001, 2005, 2011, 2015) into the console and execute. # store our publication years, in chronological order, as a variable giss_year &lt;- c(2001, 2005, 2011, 2015) Type print(giss_year) into the console and execute. # print our giss_year variable print(giss_year) ## [1] 2001 2005 2011 2015 Of course, on their own, the two vectors do not mean much but we can use the same c() function that we used earlier to combine the two together to create a matrix. 4.6.3 Matrices In R, a matrix is simply an extension of the numeric or character vectors. They are not a separate type of object per se but simply a vector that has two dimensions. That is they contain both rows and columns. As with atomic vectors, the elements of a matrix must be of the same data type. As both our page numbers and our years are numeric, we can add them together to create a matrix using the matrix() function. Type giss_year_nos &lt;- matrix(c(giss_year, giss_page_no), ncol=2) into the console and execute. # create a new matrix from our two vectors with two columns giss_year_nos &lt;- matrix(c(giss_year, giss_page_no), ncol = 2) # note the inclusion of a new argument to our matrix: ncol=2 this stands for # &#39;number of columns&#39; and we want two Type print(giss_year_nos) into the console and execute to check the result. print(giss_year_nos) ## [,1] [,2] ## [1,] 2001 454 ## [2,] 2005 517 ## [3,] 2011 560 ## [4,] 2015 477 The thing about matrices is that, for us, they do not have a huge amount of use. If we were to look at this matrix in isolation from what we know it represents, we would not really know what to do with it. As a result, we tend to primarily use Data Frames in R as they offer the opportunity to add field names to our columns to help with their interpretation. Note The function we just used above, matrix(), was the first function that we used that took more than one argument. In this case, the arguments the matrix needed to run were: What data or dataset should be stored in the matrix. How many columns (ncol=) do we need to store our data in. For any function, there will be mandatory arguments (i.e. it will not run without these) or optional arguments (i.e. it will run without these, as the default to this argument has been set usually to FALSE, 0 or NULL). These are normally documented in the documentation, including details on the format the function expects these arguments to be in. Understanding how to find out what object and data type a variable is essential therefore to knowing whether it can be used within a function or whether we will need to transform our variable into a different data structure to be used for that specific function. 4.6.4 Dataframes A data frame is an extremely important data type in R. It is pretty much the de-facto data structure for most tabular data and the data structure we use for statistics. It also is the underlying structure to the table data (what we would call the attribute table in Q-GIS) that we associate with spatial data, more on this next week. A data frame is a special type of list where every element of the list will have the same length (i.e. data frame is a “rectangular” list), Essentially, a data frame is constructed from columns (which represent a list) and rows (which represents a corresponding element on each list). Each column will have the same amount of entries - even if, for that row, for example, the entry is simply NULL. Data frames can have additional attributes such as rownames(), which can be useful for annotating data, like subject_id or sample_id or UID. In statistics, they are often not used but in spatial analysis, these IDs can be essential to join data together. Some additional information on data frames: They are usually created by read.csv() and read.table(), i.e. when importing the data into R. You can also create a new data frame with data.frame() function, e.g. a matrix can be converted to a data frame. You can find out the number of rows and columns with nrow() and ncol(), respectively. Rownames are often automatically generated and look like X1, X2, …, Xn. Consistency in numbering of rownames may not be honoured when rows are reshuffled or subset. Let us go ahead and create a new data frame from our matrix. Type giss_df &lt;- data.frame(giss_year_nos) into the console and execute. # create a new dataframe from our matrix giss_df &lt;- data.frame(giss_year_nos) We now have a data frame, we can use the View() function in R. Still in your console, type: View(giss_df) # view our data frame View(giss_df) You should now see a table pop-up as a new tab on your script window. It is now starting to look like the table we are trying to create, but we need to do something about the fieldnames. X1 and X2 are not very informative. 4.6.5 Column names We can rename our data frame column field names by using the names() function. Before we do this, have a read of what the names() function does. Still in your console, type: ?names # get the help documentation for the names function `?`(names) As you can see, the function will get or set the names of an object, with renaming occurring by using the following syntax: names(x) &lt;- value The value itself needs to be a character vector of up to the same length as x, or NULL. We have two columns in our data frame, so we need to parse our names() function with a character vector with two elements. In the console, we shall enter two lines of code, one after another. First our character vector with our new names, new_names &lt;- c(\"year\", \"page_nos\"), and then the names() function containing this vector for renaming, names(giss_df) &lt;- new_names: # create a vector with our new column names new_names &lt;- c(&quot;year&quot;, &quot;page_nos&quot;) # rename our columns with our next names names(giss_df) &lt;- new_names You can go and check your data frame again and see the new names using either View() function or by clicking on the tab at the top. 4.6.6 Adding columns We are still missing one final column from our data frame: our edition of the textbook column. As this is a character data type, we would not have been able to add this directly to our matrix. This is because data frames can take different data types, unlike matrices - so let us go ahead and add the edition as a new column. To do so, we follow a similar process of creating a vector with our editions listed in chronological order, but then add this to our data frame by storing this vector as a new column in our data frame. We use the $ sign with our code that gives us “access” to the data frame’s column - we then specify the column edition, which whilst it does not exist at the moment, will be created from our code that assigns our edition variable to this column. Type and execute edition &lt;- c(\"1st\", \"2nd\", \"3rd\", \"4th\"). Then store this vector as a new column in our data frame under the column name edition by typing and executing giss_df$edition &lt;- edition: # create a vector with our editions edition &lt;- c(&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;) # add this vector as a new column to our data frame giss_df$edition &lt;- edition Again, you can go and check your data frame and see the new column using either View() function or by clicking on the tab at the top or by typing giss_df in your console window. # inspect giss_df ## year page_nos edition ## 1 2001 454 1st ## 2 2005 517 2nd ## 3 2011 560 3rd ## 4 2015 477 4th Now we have our data frame, let us find out a little about it. We can first return the dimensions (the size) of our data frame by using the dim() function. In your console, type dim(giss_df) and execute. # check our data frame dimensions dim(giss_df) ## [1] 4 3 We can see we have four rows and three columns. We can also finally use our attributes() function to get the attributes of our data frame. In your console, type attributes(giss_df) and execute: # check our data frame attributes attributes(giss_df) ## $names ## [1] &quot;year&quot; &quot;page_nos&quot; &quot;edition&quot; ## ## $row.names ## [1] 1 2 3 4 ## ## $class ## [1] &quot;data.frame&quot; Tips R is case-sensitive so you need to make sure that you capitalise everything correctly if required. The spaces between the words do not matter but the positions of the commas and brackets do. Remember, if you find the prompt, &gt;, is replaced with a + it is because the command is incomplete. If necessary, hit the escape (esc) key and try again. It is important to come up with good names for your objects. In the case of the majority of our variables, we used a underscore _ to separate the words. It is good practice to keep the object names as short as possible but they still need to be easy to read and clear what they are referring to. Be aware: you cannot start an object name with a number! If you press the up arrow in the command line you will be able to edit the previous lines of code you have inputted. 4.7 Crime in London II During Week 1’s computer tutorial, we already installed several R libraries. One of these libraries was called the tidyverse. The tidyverse is a collection of packages that are specifically designed for data wrangling, management, cleaning, analysis and visualisation within RStudio. Whilst in many cases different packages work all slightly differently, all packages of the tidyverse share the underlying design philosophy, grammar, and data structures. The tidyverse itself is treated and loaded as a single package, but this means if you load the tidyverse package within your script (through library(tidyverse)), you will directly have access to all the functions that are part of each of the packages that are within the overall tidyverse. This means you do not have to load each package separately. For more information have a look at https://www.tidyverse.org/. There are some specific functions in the tidyverse suite of packages that will help us cleaning and preparing our datasets now and in the future, which is one of the main reasons for using this library. Some of the most important and useful functions, from the tidyr and dplyr packages, are: Package Function Use to dplyr select select columns dplyr filter select rows dplyr mutate transform or recode variables dplyr summarise summarise data dplyr group by group data into subgroups for further processing tidyr pivot_longer convert data from wide format to long format tidyr pivot_wider convert long format dataset to wide format These functions all complete very fundamental tasks that we need to manipulate and wrangle our data. Note The code you just ran asked R to load all functions of the tidyverse. However: these functions are only available for the duration of your R sessions. When you restart your R session, you will have to load these functions again if you want to use them. Another thing to be aware of when it comes to using functions in these additional libraries, is that sometimes these functions share a name with a function form one of the base R packages. For instance, there exists a select() function within in the stats package that conducts linear filtering on a time series. However, after we load the tidyverse package and we would type select() this function will select columns from a data frame. We therefore sometimes need to specify which library we want to use this function from, and this can be done with a simple command (library::function) in our code: stats::select to filter that time series and dplyr::select to select columns in a dataframe 4.7.1 Starting a project In the previous section, R may have seemed fairly labour-intensive. We had to enter all our data manually and each line of code had to be written into the command line. Fortunately this is not routinely the case. In RStudio, we can use scripts to build up our code that we can run repeatedly and save for future use. Before we start a new script, we first want to set up ourselves ready for the rest of our practicals by creating a new project. To put it succinctly, projects in RStudio keep all the files associated with a project together: input data, R scripts, analytical results, figures, etc.. This means we can easily keep track of all data, input and output, whilst still creating standalone scripts for each bit of processing analysis we do. It also makes dealing with directories and paths a whole lot easier; particularly if you have followed the folder structure that was advised at the start of the module. Click on File -&gt; New Project -&gt; Existing Directory and browse to your GEOG0030 folder. Click on Create Project. You should now see your main window switch to this new project and if you check your Files window, you should now see a new R Project called GEOG0030. Note Please ensure that folder names and file names do not contain spaces or special characters such as * . \" / \\ [ ] : ; | = , &lt; ? &gt; &amp; $ # ! ' { } ( ). Different operating systems and programming languages deal differently with spaces and special characters and as such including these in your folder names and file names can cause many problems and unexpected errors. As an alternative to using white space you can use an underscore _ if you like. 4.7.2 Setting up a script For the majority of our analysis work, we will type our code within a script and not the console. Let us create our first script. Click on File -&gt; New File -&gt; R Script. This should give you a blank document that looks a bit like the command line. The difference is that anything you type here can be saved as a script and re-run at a later date. Figure 4.3: Creating a new script. Save your script as: wk4-csv-processing.r. Through our name, we know now that our script was created in Week 4 of Geocomputation and the code it will contain is something to do with csv processing. This will help us a lot in the future when we come to find code that we need for other projects. The first bit of code you will want to add to any script is to add a title. This title should give any reader a quick understanding of what your code achieves. When writing a script it is important to keep notes about what each step is doing. To do this, the hash (#) symbol is put before any code. This comments out that particular line so that R ignores it when the script is run. Let us go ahead and give our script a title - and maybe some additional information: # Combining Police Data csv&#39;s from 2020 into a single csv # Followed by analysis of data on monthly basis # Date: January 2023 # Author: Justin Now we have our title, the second bit of code we want to include in our script is to load our libraries (i.e. the installed packages we want to use in our script): # libraries library(tidyverse) By loading simply the tidyverse we gain access to several useful functions. However, when developing a script you will realise that you may need to load more libraries as you go along. When you do this, always add your library to the top of your script. If you ever share your script, it helps the person you are sharing with to recognise quickly if they need to install any additional packages prior to running the code It also means your libraries do not get lost in the multiple lines of code you are writing. We are now ready to run these first two lines of code. Remember to save your script. 4.7.3 Running a script There are two main ways to run a script in RStudio: all at once or by line/chunk. It can be advantageous to pursue with the second option as you first start out to build your script as it allows you to test your code interactively. To run line-by-line By clicking: Select the line or chunk of code you want to run, then click on Code and choose Run selected lines. By key commands: Select the line or chunk of code you want to run and then hold Ctl or Cmd and press Return. To run the whole script By clicking: Click on Run on the top-right of the scripting window and choose Run All. By key commands: Hold Option plus Ctl or Cmd and R. Stopping a script from running If you are running a script that seems to be stuck (for whatever reason) or you notice some of your code is wrong, you will need to interrupt R. To do so, click on Session -&gt; Interrupt R. If this does not work, you may end up needing to Terminate R but this may lose any unsaved progress. 4.7.4 Crime data Where last week we provided you with a crime dataset, this week you will download and prepare the dataset yourself. Start by navigating to data.police.uk. And click on Downloads. Under the data range select January 2020 to December 2020. Under the Custom download tab select Metropolitan Police Service and City of London Police. Leave all other settings and click on Generate file. Figure 4.4: Downloading our crime data. It may take a few minutes for the download to be generated, so be patient. Once the Download now button appears, you can download the 2020 crime dataset. Once downloaded, unzip the file. You will notice that the zip file contains 12 individual folders, one for each month in 2020. Each folder contains two files: one containing the data for the Metropolitan Police Service and one for the City of London Police. Create a new folder named all_crime in your data/raw/crime directory and copy all 12 folders containing our data to this new folder. Figure 4.5: Your data folder should now look something like this. 4.7.4.1 Reading data into R We are now ready to get started with using the crime data csv's currently sat in our all_crime folder. To do so, we need to first figure out how to import the csv and understand the data structure it will be in after importing. To read in a csv into R requires the use of a very simple function from the tidyverse library: read_csv(). We can look at the help documentation to understand what we need to provide the function (or rather the optional arguments), but as we just want to load single csv, we will go ahead and just use the function with a simple parameter. # read in a single csv from our crime data crime_csv &lt;- read_csv(&quot;data/raw/crime/all_crime/2020-01/2020-01-metropolitan-street.csv&quot;) Note If using a Windows machine, you will need to substitute your forward-slashes (/) with two backslashes (\\\\) whenever you are dealing with file paths! We can explore the csv we have just loaded as our new crime_csv variable and understand the class, attributes and dimensions of our variable. # check class class(crime_csv) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # check dimensions dim(crime_csv) ## [1] 90979 12 We have found out our variable is a data frame, containing 90,979 rows and 12 columns. We however do not want just the single csv and instead what to combine all our csv's in our all_crime folder into a single data frame - so how do we do this? This will be the most complicated section of code you will come across today, and we will use some functions that you have not seen before. Copy the following code below into your script, then execute. # read in all files and append all rows to a single data frame all_crime_df &lt;- list.files(path = &quot;data/raw/crime/all_crime/&quot;, full.names = TRUE, recursive = TRUE) %&gt;% lapply(read_csv) %&gt;% bind_rows This might take a little time to process (or might not), as we have a lot of data to get through. You should see a new data frame appear in your global environment called all_crime_df, for which we now have 1,187,847 observations! Note It is a little difficult to explain the code above without going into too much detail and at this stage you are not expected to fully understand what is happening here, but essentially what the code does is: List all the files found in the data path: data/raw/crime/all_crime/ Read each of these as a csv by “applying” the read_csv() function to all files. Binding all rows of all individual data frames together in a single data frame. These three different actions are combined by using something called a pipe (%&gt;% or |&gt;), which we will explain in more detail in later weeks. 4.7.4.2 Inspecting data in R We can now have a look at our large dataframe in more detail. # understand our all_crime_df cols, rows and print the first five rows ncol(all_crime_df) ## [1] 12 nrow(all_crime_df) ## [1] 1187847 head(all_crime_df) ## # A tibble: 6 × 12 ## Crime …¹ Month Repor…² Falls…³ Longi…⁴ Latit…⁵ Locat…⁶ LSOA …⁷ LSOA …⁸ Crime…⁹ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37c663d… 2020… City o… City o… -0.106 51.5 On or … E01000… Camden… Theft … ## 2 5b89923… 2020… City o… City o… -0.118 51.5 On or … E01000… Camden… Drugs ## 3 0717268… 2020… City o… City o… -0.112 51.5 On or … E01000… Camden… Other … ## 4 14e02a6… 2020… City o… City o… -0.111 51.5 On or … E01000… Camden… Other … ## 5 fb3350c… 2020… City o… City o… -0.113 51.5 On or … E01000… Camden… Other … ## 6 &lt;NA&gt; 2020… City o… City o… -0.0976 51.5 On or … E01000… City o… Anti-s… ## # … with 2 more variables: `Last outcome category` &lt;chr&gt;, Context &lt;lgl&gt;, and ## # abbreviated variable names ¹​`Crime ID`, ²​`Reported by`, ³​`Falls within`, ## # ⁴​Longitude, ⁵​Latitude, ⁶​Location, ⁷​`LSOA code`, ⁸​`LSOA name`, ⁹​`Crime type` You should now see with have the same number of columns as our previous single csv, but with many more rows. You can also see that the head() function provides us with the first five rows of our data frame. You can conversely use tail() to provide the last five rows. For now in our analysis, we only want to extract the theft crime in our data frame - so we will want to filter our data based on the Crime type column. However, as we can see, we have a space in our field name for Crime type and, in fact, many of the other fields. As we want to avoid having spaces in our field names when coding, we need to rename our fields. Rename the field names, just as we did with our GIS table earlier: # create a new vector containing updated no space / no capital field names no_space_names &lt;- c(&quot;crime_id&quot;, &quot;month&quot;, &quot;reported_by&quot;, &quot;falls_within&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;location&quot;, &quot;lsoa_code&quot;, &quot;lsoa_name&quot;, &quot;crime_type&quot;, &quot;last_outcome_category&quot;, &quot;context&quot;) # rename our df field names using these new names names(all_crime_df) &lt;- no_space_names We now have our dataframe ready for filtering. To do so, we will use the filter() function from the dplyr package: # filter all_crime_df to contain only theft, store as a new variable: # all_theft_df all_theft_df &lt;- dplyr::filter(all_crime_df, crime_type == &quot;Theft from the person&quot;) You should now see the new variable appear in your environment with 31,578 observations. Note Although not necessary per se because R uses the function from the package that got loaded latest, it is a good idea to specify that we want to use filter() from the dplyr package instead of the default stats library so to avoid any confusing errors. We now want to do some further housekeeping and create on final data frame that will allow us to analyse crime in London by month. To do so, we want to count how many thefts occur each month in London. Fortunately, dplyr has another function that will do this for us, known simply as count(). When you go ahead and search the documentation to understand the count() function, you will see that there is only one function called count() at the moment, i.e. the one in the dplyr library, so we do not need to use the additional syntax we used above. Let us go ahead and count the number of thefts in London by month: # count in the all_theft_df the number of crimes by month and store as a new # dataframe theft_month_df &lt;- count(all_theft_df, month) We have stored the output of our count() function to a new data frame: theft_month_df. Go ahead and look at the data frame to see the output: it is a very simple table containing simply the month and n, i.e. the number of thefts occurring per month. We can and should go ahead and rename this column to help with our interpretation of the data frame. We will use a quick approach to do this, that uses selection of the precise column to rename only the second column: # rename the second column of our new data frame to crime_totals names(theft_month_df)[2] &lt;- &quot;crime_totals&quot; This selection is made through the [2] element of code added after the names() function we have used earlier. We will look more at selection, slicing and indexing during next week’s tutorial. 4.8 Assignment Now we have prepared our dataset, we can conduct some analysis: What was the average number of crimes per month in London in 2020? What was the median number of crimes per month in London in 2020? What were the minimum and maximum values of crime in London in 2020? Besides descriptive statistics, it would be really useful to generate a simple chart. Use the documentation of the barplot() function to create the barplot below: Note Do not forget to save your script so you can go back to it at a later time. When you close R and are asked if you want to save your workspace: this is not necessary. Saving the workspace will keep any variables generated during your current session saved and available in a future session, but so will re-running your script. 4.9 Want more? [Optional] 4.9.1 Data visualisation The graphs and figures we have made so far are rather basic. Although possible with the basic R installation, there are easier and better ways to make nice visualisations. For this we can turn to other R packages that have been developed. In fact, there are many hundreds of packages in R each designed for a specific purpose, some of which you can use to create plots in R. One of those packages is called ggplot2. The ggplot2 package is an implementation of the Grammar of Graphics (Wilkinson 2005) - a general scheme for data visualisation that breaks up graphs into semantic components such as scales and layers. ggplot2 can serve as a replacement for the base graphics in R and contains a number of default options that match good visualisation practice. You provide the data, tell ggplot2 how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details. An excellent introduction to ggplot2 can be found in the online, freely available book R for Data Science; written by Hadley Wickham, core developer of ggplot2 and the tidyverse. Have a particularly close look at Chapter 3: Data visualisation: [Link]. 4.9.2 Reproducible research The book Data Skills for Reproducible Research provides an excellent overview of skills needed for reproducible and open research using the statistical programming language R and tidyverse packages. To get started: have a look at Chapter 2: Reproducible Workflows, Chapter 7: Data Wrangling, and Chapter 8: Iterations and Functions. Another great tool is found in the targets package. The targets package is a Make-like pipeline tool for Statistics and data science in R. With targets, you can maintain a reproducible workflow without repeating yourself. To get started: have a look at the Walkthrough chapter to see targets in action. 4.10 Before you leave We have managed to take a dataset of over one million records and clean and filter it to create a barplot on theft crime in London. Of course, there is a lot more research and exploratory data analysis that can be done, but this first chart is certainly a step in the right direction. Next week, we will be doing a lot more with our dataset - including a lot more data wrangling and of course spatial analysis, but hopefully this week has shown you want you can achieve with just a few lines of code. That concludes the tutorial for this week! "],["programming-for-spatial-analysis.html", "5 Programming for Spatial Analysis 5.1 Reading list 5.2 Crime in London III 5.3 Assignment 5.4 Want more? [Optional] 5.5 Before you leave", " 5 Programming for Spatial Analysis This week we are going to look at how to use R and RStudio as a piece of GIS software. Like last week, we will be completing an analysis on our London theft crime dataset. However, rather than solely looking at changing crime rates over time, we will add a spatial component to our analysis: how has crime changed across our wards over the years. 5.1 Reading list Essential readings Longley, P. et al. 2015. Geographic Information Science &amp; systems, Chapter 13: Spatial Analysis. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 2: Geographic Data in R. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 3: Attribute data operations. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 8: Making maps with R. [Link] Suggested readings Poorthuis, A. and Zook, M. 2020. Being smarter about space: Drawing lessons from spatial science. Annals of the American Association of Geographers 110(2): 349-359. [Link] De Smith, M, Goodchild, M. and Longley, P. 2018. Geospatial analsyis. A Comprehensive guide to principles techniques and software tools. Chapter 9: Big Data and geospatial analysis. [Link] Radil, S. 2016. Spatial analysis of crime. The Handbook of Measurement Issues in Criminology and Criminal Justice 536-554. [Link] 5.2 Crime in London III To analyse crime by ward over time, we will go through several steps of data preparation (‘data wrangling’) before joining our data to ward polygons. We will start by taking our all_theft_df dataframe and wrangle it to produce a dataframe with a for each ward the number of crimes for each month of data. we then join this dataframe to our ward_population_2019 shapefile (which should still be sitting in your output folder) and then produce a crime rate for each month, for each ward. Lastly, we will create a map of the crime rate in London for January 2020 using the tmap library. 5.2.1 Data preparation Before we get started, we first need to head back to our script from last week, run our script - and then write our all_theft_df to a csv file. If you had saved your environment from last week, keeping your variables in memory, theoretically you would not need to export the data frame as you should have access to this variable within your new script but it would be good practice to write out the data and then load it back in. Open up your GEOG0030 RStudio project. Next open your script from last week: wk4-csv-processing.r. Run your full script up to and including the code that filters our large all_crime_df to only the all_theft_df. Scroll to the bottom of the script and enter the following code and execute: # write out the theft_crime_df to a csv within our raw crime data folder write.csv(all_theft_df, &quot;data/raw/crime/crime_theft_2020_london.csv&quot;, row.names = FALSE) Note If using a Windows machine, you will need to substitute your forward-slashes (/) with two backslashes (\\\\) whenever you are dealing with file paths! You should now see a new csv within your raw crime data folder (data/raw/crime). You can now save your wk4-csv-processing.r script and close the script. 5.2.2 Spatial analysis set up Open a new script within your GEOG0030 project and save this script as wk5-crime-spatial-processing.r. At the top of your script, add the following metadata (substitute accordingly): # Analysing crime in 2020 by month and ward # Date: January 2023 # Author: Justin Now let us add all of the libraries we will be using today to the top of our script: # libraries library(tidyverse) library(sf) library(tmap) # change tmap mode to plot tmap_mode(&quot;plot&quot;) You are already familiar with the tidyverse library, but now we adding sf to read and load our spatial data as well as tmap to visualise our spatial data. We are going to load both of the datasets we need today straight away: the crime_theft_2020_london.csv we have just exported and the ward_population_2019.shp we created in Week 3. First, let’s load our crime_theft_2020_london.csv into a dataframe called all_theft_df. # read in our crime_theft_2020_london csv from our raw crime data folder all_theft_df &lt;- read_csv(&quot;data/raw/crime/crime_theft_2020_london.csv&quot;) We can double-check what our csv looks like by either viewing our data or simply calling the head() function on our dataframe: # check the first five rows of our all_theft dataframe head(all_theft_df) ## # A tibble: 6 × 12 ## crime_id month repor…¹ falls…² longi…³ latit…⁴ locat…⁵ lsoa_…⁶ lsoa_…⁷ crime…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37c663d… 2020… City o… City o… -0.106 51.5 On or … E01000… Camden… Theft … ## 2 dcfa16f… 2020… City o… City o… -0.0941 51.5 On or … E01000… City o… Theft … ## 3 be9310e… 2020… City o… City o… -0.0945 51.5 On or … E01000… City o… Theft … ## 4 0cbb0c5… 2020… City o… City o… -0.0945 51.5 On or … E01000… City o… Theft … ## 5 aaafbcf… 2020… City o… City o… -0.0750 51.5 On or … E01000… City o… Theft … ## 6 8249cc1… 2020… City o… City o… -0.0750 51.5 On or … E01000… City o… Theft … ## # … with 2 more variables: last_outcome_category &lt;chr&gt;, context &lt;lgl&gt;, and ## # abbreviated variable names ¹​reported_by, ²​falls_within, ³​longitude, ## # ⁴​latitude, ⁵​location, ⁶​lsoa_code, ⁷​lsoa_name, ⁸​crime_type You should see these rows display in your console. Great, the dataset looks as we remember, with the different fields, including, importantly for this week, the LSOA code which we will use to process and join our data together. Next, let’s add our ward_population_2019.shp. We will store this as a variable called ward_population and use the sf library to load the data: # read in our ward_population_2019 shp from our output data folder ward_population &lt;- st_read(&quot;data/output/ward_population_2019.shp&quot;, stringsAsFactors = FALSE) ## Reading layer `ward_population_2019&#39; from data source ## `/Users/justinvandijk/Dropbox/UCL/Web/jtvandijk.github.io/GEOG0030/data/output/ward_population_2019.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 657 features and 7 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## Projected CRS: OSGB36 / British National Grid You should now see the ward_population variable appear in your environment window. 5.2.3 Interacting with spatial data As this is the first time we have loaded spatial data into R, let’s go for a little exploration of how we can interact with our spatial data frame. The first thing we want to do when we load spatial data is, of course, map it to if everything is in order. To do this, we can use a really simple command from R’s base library: plot(). As we do not necessarily want to plot this data everytime we run this script in the future, we can type this command into the console: # plot our ward_population data plot(ward_population) You should see your ward_population plot appear in your Plots window - as you will see, your ward dataset is plotted ‘thematically’ by each of the fields within the dataset, including our pop2019 field we created last week. Tip This plot() function is not to be used to make maps but can be used as a quick way of viewing our spatial data. We can also find out more information about our ward_population data. Let’s next check out our class of our data. Again, in the console type: # find out the class of our ward_population data class(ward_population) ## [1] &quot;sf&quot; &quot;data.frame&quot; We should see our data is an sf dataframe, which is great as it means we can utilise our tidyverse libraries with our ward_population. We can also use the attributes() function we looked at last week to find out a little more about the spatial part of our data frame: # find out the attributes of our ward_population data attributes(ward_population) ## $names ## [1] &quot;NAME&quot; &quot;GSS_CODE&quot; &quot;DISTRICT&quot; &quot;LAGSSCODE&quot; &quot;HECTARES&quot; ## [6] &quot;NONLD_AREA&quot; &quot;pop2019&quot; &quot;geometry&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 ## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 ## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 ## [145] 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 ## [163] 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 ## [181] 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 ## [199] 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 ## [217] 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 ## [235] 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 ## [253] 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 ## [271] 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 ## [289] 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 ## [307] 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 ## [325] 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 ## [343] 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 ## [361] 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 ## [379] 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 ## [397] 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 ## [415] 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 ## [433] 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 ## [451] 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 ## [469] 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 ## [487] 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 ## [505] 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 ## [523] 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 ## [541] 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 ## [559] 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 ## [577] 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 ## [595] 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 ## [613] 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 ## [631] 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 ## [649] 649 650 651 652 653 654 655 656 657 ## ## $class ## [1] &quot;sf&quot; &quot;data.frame&quot; ## ## $sf_column ## [1] &quot;geometry&quot; ## ## $agr ## NAME GSS_CODE DISTRICT LAGSSCODE HECTARES NONLD_AREA pop2019 ## &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## Levels: constant aggregate identity We can see how many rows we have, the names of our rows and a few more pieces of information about our ward_population data, for example, we can see that the specific $sf_column i.e. our spatial information) in our dataset is called geometry. We can investigate this column a little more by selecting this column within our console to return. In the console type: # get info about the geometry of our ward_population data ward_population$geometry ## Geometry set for 657 features ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## Projected CRS: OSGB36 / British National Grid ## First 5 geometries: You should see new information about our geometry column display in your console. From this selection we can find out the dataset’s: geometry type dimension bbox (bounding box) CRS (coordinate reference system) And also the first five geometries of our dataset. This is really useful as one of the first things we want to know about our spatial data is what coordinate system it is projected with. As we should know, our ward_population data was created and exported within British National Grid, therefore seeing the EPSG code of British National Grid - 27700 - as our CRS confirms to us that R has read in our dataset correctly. We could also actually find out this information using the st_crs() function from the sf library. # find out the CRS of our ward_population data st_crs(ward_population) ## Coordinate Reference System: ## User input: OSGB36 / British National Grid ## wkt: ## PROJCRS[&quot;OSGB36 / British National Grid&quot;, ## BASEGEOGCRS[&quot;OSGB36&quot;, ## DATUM[&quot;Ordnance Survey of Great Britain 1936&quot;, ## ELLIPSOID[&quot;Airy 1830&quot;,6377563.396,299.3249646, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4277]], ## CONVERSION[&quot;British National Grid&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,49, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-2, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996012717, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,400000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,-100000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United Kingdom (UK) - offshore to boundary of UKCS within 49°45&#39;N to 61°N and 9°W to 2°E; onshore Great Britain (England, Wales and Scotland). Isle of Man onshore.&quot;], ## BBOX[49.75,-9,61.01,2.01]], ## ID[&quot;EPSG&quot;,27700]] You notice that we actually get a lot more information about our CRS beyond simply the code using this function. This function is really important to us as users of spatial data as it allows us to retrieve and set the CRS of our spatial data when the data does not come with a .proj file but we do know what projection system should be used. The final thing we might want to do before we get started with our data analysis is to simply look at the data table part of our dataset, i.e. what we called the Attribute Table in QGIS, but here it is simply the table part of our data frame. To do so, you can either use the View() function in the console or click on the ward_population variable within our environment. 5.2.4 Getting our crime data in shape Now we have our data loaded, our next step is to process our data to create what we need as our final output for analysis: a spatial dataframe that contains a theft crime rate for each ward for each month in 2020. However, if we look at our all_theft_df, we do not have a field that contains the wards our crimes have occurred in. We only have two types of spatial or spatially-relevant data in our all_theft_df: The approximate WGS84 latitude and longitude. The Lower Super Output Area (LSOA) in which the crime it occurred. From Week 3’s practical, we know we can map our points using the coordinates and then provide a count by using a point-in-polygon (PIP) operation. However to do this for each month, we would need to filter our dataset for each month and repeat the PIP operation - when we know a little more advanced code, this might end up being quite simple, but for now we will try to see if we can solve it differently. 5.2.4.1 Attribute join To get the number of crimes that occurred in each ward, all we need to do is figure our which Ward our LSOAs fall within and then we can add this as an additional attribute or rather column to our all_theft_df. From a GIScience perspective, there are many ways to do this but the most straight forward is to use something called a look-up table. Look-up tables are an extremely common tool in database management and programming, providing a very simple approach to storing additional information about a feature (such as a row within a dataframe) in a separate table that can quite literally be “looked up” when needed for a specific application. In our case, we will actually join our look-up table to our current all_theft_df to get this information “hard-coded” to our dataframe for ease of use. To be able to do this, we therefore need to find a look-up table that contains a list of LSOAs in London and the wards in which they are contained. Lucky for us the Office for National Statistics provides this for us in their Open Geography Portal. They have a table that contains exactly what we’re looking for: Lower Layer Super Output Area (2011) to Ward (2018) Lookup in England and Wales v3. As the description on the website tells us: “This file is a best-fit lookup between 2011 lower layer super output areas, electoral wards/divisions and local authority districts in England and Wales as at 31 December 2018.” Download the ONS look-up table: [Link] Move this file in your data -&gt; raw -&gt; boundaries folder and rename to data/raw/boundaries/lsoa_ward_lookup.csv. Load the dataset using the read_csv() function. Do not worry if you have a few “parsing” failures, the table should still work fine. # read in our lsoa_ward_lookup csv from our raw boundaries data folder lsoa_ward_lookup &lt;- read_csv(&quot;data/raw/boundaries/lsoa_ward_lookup.csv&quot;) Now we have our lookup table, all we are going to do is extract the relevant ward name and code for each of the LSOAs in our all_theft_df. To do so, we’re going to use one of the join functions from the dplyr library. Note We have already learnt how to complete Attribute Joins in QGIS via the Joins tab in the Properties window so it should come of no surprise that we can do exactly the same process within R. To conduct a join between two dataframes (spatial or non-spatial, it does not matter), we use the same principles of selecting a unique but matching field within our dataframes to join them together. Within R, you have two options to complete a data frame join: The first is to use the base R library and its merge() function: By default the data frames are merged on the columns with names they both have, but you can also provide the columns to match separate by using the parameters: by.x and by.y. Your code would look something like: merge(x, y, by.x = \"xColName\", by.y = \"yColName\"), with x and y each representing a dataframe. The rows in the two data frames that match on the specified columns are extracted, and joined together. If there is more than one match, all possible matches contribute one row each, but you can also tell merge whether you want all rows, including ones without a match, or just rows that match, with the arguments all.x and all. The second option is to use the dplyr library: dplyr uses SQL database syntax for its join functions. There are four types of joins possible with the dplyr library. inner_join(): includes all rows that exist both within x and y. left_join(): includes all rows in x. right_join(): includes all rows in y. full_join(): includes all rows in x and y. Figuring out which one you need will be on a case by case basis. Again, if the join columns have the same name, all you need is left_join(x, y). If they do not have the same name, you need a by argument, such as left_join(x, y, by = c(\"xName\" = \"yName\")). Left of the equals is the column for the first data frame, right of the equals is the name of the column for the second data frame. As we have seen from the list of fields above, we know that we have at least two fields that should match across the datasets: our lsoa codes and lsoa names. We of course need to identify the precise fields that contain these values in each of our data frames, i.e. LSOA11CD and LSOA11NM in our lsoa_ward_lookup dataframe and lsoa_code and lsoa_name in our all_theft_df dataframe, but once we know what fields we can use, we can go ahead and join our two data frames together. We are going to need to make multiple joins between our tables as we have multiple entries of crime for the same LSOA. In addition, we are going to need to use a function that allows us to keep all rows in our all_theft_df dataframe, but we do not need to keep all rows in our lsoa_ward_lookup if those wards are not within our dataset. Let’s have a look in detail at how the four different types of joins from dplyr work: Figure 5.1: Different types of joins. It looks like we’re going to need to use our left_join() function as we want to join matching rows from our lsoa_ward_lookup dataframe to our all_theft_df dataframe but make sure to keep all rows in the latter. Create a join between our two dataframes and store as a new variable: # join lsoa_ward_lookup rows to the all_theft_df on our two lsoa code fields all_theft_ward_df &lt;- left_join(all_theft_df, lsoa_ward_lookup, by = c(lsoa_code = &quot;LSOA11CD&quot;)) Let’s go ahead and check our join to make sure that our LSOA codes and names match across our new dataframe. # check our join via the first five rows head(all_theft_ward_df) ## # A tibble: 6 × 19 ## crime_id month repor…¹ falls…² longi…³ latit…⁴ locat…⁵ lsoa_…⁶ lsoa_…⁷ crime…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 37c663d… 2020… City o… City o… -0.106 51.5 On or … E01000… Camden… Theft … ## 2 dcfa16f… 2020… City o… City o… -0.0941 51.5 On or … E01000… City o… Theft … ## 3 be9310e… 2020… City o… City o… -0.0945 51.5 On or … E01000… City o… Theft … ## 4 0cbb0c5… 2020… City o… City o… -0.0945 51.5 On or … E01000… City o… Theft … ## 5 aaafbcf… 2020… City o… City o… -0.0750 51.5 On or … E01000… City o… Theft … ## 6 8249cc1… 2020… City o… City o… -0.0750 51.5 On or … E01000… City o… Theft … ## # … with 9 more variables: last_outcome_category &lt;chr&gt;, context &lt;lgl&gt;, ## # LSOA11NM &lt;chr&gt;, WD18CD &lt;chr&gt;, WD18NM &lt;chr&gt;, WD18NMW &lt;chr&gt;, LAD18CD &lt;chr&gt;, ## # LAD18NM &lt;chr&gt;, FID &lt;dbl&gt;, and abbreviated variable names ¹​reported_by, ## # ²​falls_within, ³​longitude, ⁴​latitude, ⁵​location, ⁶​lsoa_code, ⁷​lsoa_name, ## # ⁸​crime_type You should now see that you have with 19 variables: 12 from all_theft_df, plus 7 from lsoa_ward_lookup. Now we have our joined dataset, we can move forward with some more data wrangling. Before we do this, it would be good if we could trim down our dataframe to only the relevant data that we need moving forward. To be able to ‘trim’ our data frame, we have two choices in terms of the code we might want to run. First, we could look to drop certain columns from our data frame. Alternatively, we could create a subset of the columns we want to keep from our data frame and store this as a new variable or simply overwrite the currently stored variable. To do either of these types of data transformation, we need to know more about how we can interact with a data frame in terms of indexing, selecting and slicing. 5.2.5 Data wrangling Everything we will be doing today as we progress with our data frame cleaning and processing relies on us understanding how to interact with and transform our data frame. This interaction itself relies on knowing about how indexing works in R as well as how to select and slice your data frame to extract the relevant cells, rows or columns and then manipulate them. Whilst there are traditional programming approaches to this using the base R library, dplyr is making this type of data wrangling much easier. The following video provides an excellent explanation from both a base R perspective as well as using the dplyr library. It also includes a good explanation about what our pipe function , %&gt;% or |&gt; , does. As you can see from the video, there are two common approaches to selection and slicing in R, which rely on indexing and/or field names in different ways. 5.2.5.1 Selection with base R The most basic approach to selecting and slicing within programming relies on the principle of using indexes within our data structures. Indexes actually apply to any type of data structure, from single atomic vectors to complicated data frames as we use here. Indexing is the numbering associated with each element of a data structure. For example, if we create a simple vector that stores several strings: # store a simple vector of strings simple_vector &lt;- c(&quot;Aa&quot;, &quot;Bb&quot;, &quot;Cc&quot;, &quot;Dd&quot;, &quot;Ee&quot;, &quot;Ff&quot;, &quot;Gg&quot;) R will assign each element (i.e. string) within this simple vector with a number: Aa = 1, Bb = 2, Cc = 3 and so on. Now we can go ahead and select each element by using the base selection syntax which is using square brackets after your element’s variable name, as so: # select the first element of our variable simple_vector[1] ## [1] &quot;Aa&quot; Which should return the first element, our first string containing Aa. You could change the number in the square brackets to any number up to 7 and you would return each specific element in our vector. However, say you do not want the first element of our vector but the second to fifth elements. To achieve this, we conduct what is known in programming as a slicing operation, where, using the [] syntax, we add a colon : to tell R where to start and where to end in creating a selection, known as a slice: # select the second to fifth element of our vector, creating a &#39;slice&#39; of our # vector simple_vector[2:5] ## [1] &quot;Bb&quot; &quot;Cc&quot; &quot;Dd&quot; &quot;Ee&quot; You should now see our 2nd to 5th elements returned. Now what is super cool about selection and slicing is that we can add in a simple - (minus) sign to essentially reverse our selection. So for example, we want to return everything but the 3rd element: # select everything but the third element of our vector simple_vector[-3] ## [1] &quot;Aa&quot; &quot;Bb&quot; &quot;Dd&quot; &quot;Ee&quot; &quot;Ff&quot; &quot;Gg&quot; And with a slice, we can use the minus to slice out parts of our vector, for example, remove the 2nd to the 5th elements (note the use of a minus sign for both): # select the second to fifth element of our vector, creating a &#39;slice&#39; of our # vector simple_vector[-2:-5] ## [1] &quot;Aa&quot; &quot;Ff&quot; &quot;Gg&quot; Note This use of square brackets for selection syntax is common across many programming languages, including Python, but there are often some differences you will need to be aware of if you pursue other languages. For example: Python always starts its index from 0! Whereas we can see here with R, our index starts at 1. R is unable to index the characters within strings. This is something you can do in Python, but in R, we will need to use a function such as substring(). We can also apply these selection techniques to data frames, but we will have a little more functionality as our data frames are made from both rows and columns. This means when it comes to selections, we can utilise an amended selection syntax that follows a specific format to select individual rows, columns, slices of each, or just a single cell: [rows, columns] There are many ways we can use this syntax, which we will show below using our lsoa_ward_lookup data frame. First, before looking through and executing these examples familiarise yourself with the lsoa_ward_lookup data frame: # view lsoa_ward_lookup dataframe View(lsoa_ward_lookup) To select a single column from your data frame, you can use one of two approaches. First we can follow the syntax above carefully and simply set our column parameter in our syntax above to the number 2: # select the 2nd column from the data frame lsoa_ward_lookup[, 2] You should see your second column display in your console. Second, we can actually select our column by only typing in the number (no need for the comma). By default, when there is only one argument present in the selection brackets, R will select the column from the data frame, not the row: # select the 2nd column from the data frame lsoa_ward_lookup[2] To select a specific row, we need to add in a comma after our number: # select the 2nd row from the data frame lsoa_ward_lookup[2, ] You should see your second row appear. Now, to select a specific cell in our data frame, we simply provide both arguments in our selection parameters: # select the value at the 2nd row and 2nd column in the data frame lsoa_ward_lookup[2, 2] What is also helpful in R is that we can select our columns by their field names by passing these field names to our selection brackets as a string. For a single column: # select the LSOA11NM column (2nd column) by name lsoa_ward_lookup[&quot;LSOA11NM&quot;] Or for more than one columns, we can supply a combined vector: # select the LSOA11CD (1st column) and LSOA11NM column (2nd column) by name lsoa_ward_lookup[c(&quot;LSOA11CD&quot;, &quot;LSOA11NM&quot;)] To retrieve our 2nd - 4th columns in our data frame, we can use: # select the 2nd to 4th columns from our data frame lsoa_ward_lookup[2:4] # select the 2nd to 4th columns from our data frame lsoa_ward_lookup[, 2:4] We can also apply the negative: # select everything but the 2nd to 4th columns from our data frame lsoa_ward_lookup[-2:-4] If you do not want a slide, we can also provide a combined list of the columns we want to extract: # select the 2nd, 3rd, 4th and 7th columns from our data frame lsoa_ward_lookup[c(2, 3, 4, 7)] We can apply this slicing approach to our rows: # select the 2nd to 4th rows from our data frame lsoa_ward_lookup[2:4, ] As well as a negative selection: # select everything but the 2nd to 4th rows from our data frame lsoa_ward_lookup[-2:-4, ] 5.2.5.2 Selection with dplyr Instead of using the square brackets [] syntax, we now have functions that we can use to select or slice our data frames accordingly: For columns, we use the select() function that enables us to select one or more columns using their column names. For rows, we use the slice() function that enables us to select one or more rows using their position (i.e. similar to the process above). For both functions, we can also use the negative - approach we saw in the base R approach to “reverse a selection”, e.g.: # select column 2 dplyr::select(lsoa_ward_lookup, 2) # select everything but column 2 dplyr::select(lsoa_ward_lookup, -2) # select LSOA11CD column, note no &#39;&#39; dplyr::select(lsoa_ward_lookup, LSOA11CD) # select everything but column 2, note no &#39;&#39; dplyr::select(lsoa_ward_lookup, -LSOA11CD) # select everything but column 2 dplyr::select(lsoa_ward_lookup, -LSOA11CD) In addition to these index-based functions, within dplyr, we also have filter() that enables us to easily filter rows within our data frame based on specific conditions (such as being a City of London ward). In addition, dplyr provides lots of functions that we can use directly with these selections to apply certain data wrangling processes to only specific parts of our data frame, such as mutate() or count(). Note We will be using quite a few of these functions in the remaining data wrangling section below - plus throughout our module, so it is highly recommend to download the dplyr cheat sheet to keep track of what functions we are using and why! As we have seen above, whilst there are two approaches to selection using either base R library or the dplyr library, we will continue to focus on using functions directly from the dplyr library to ensure efficiently and compatibility within our code. Within dplyr, as you also saw, whether we want to keep or drop columns, we always use the same function: select(). To use this function, we provide our function with a single or list of the columns we want to keep or if we want to drop them, we use the same approach, but add a - before our selection. Let’s see how we can extract just the relevant columns we will need for our future analysis. Note that we will overwrite our all_theft_ward_df variable. In your script, add the following code to extract only the relevant columns we need for our future analysis: # reduce our data frame using the select function all_theft_ward_df &lt;- dplyr::select(all_theft_ward_df, crime_id, month, longitude, latitude, lsoa_name, lsoa_code, crime_type, WD18CD, WD18NM) You should now see that your all_theft_ward_df data frame should only contain nine variables. You can go and view this data frame or call the head() function on the data in the console if youlike to check out this new formatting. 5.2.6 Improving your workflow Our current workflow looks good, we now have our data frame ready for use in wrangling but we could have done this a little more efficiently by using the pipe function %&gt;% (or |&gt;). A pipe is used to push the outcome of one function/process into another. When “piped”, we do not need to include the first “data frame” (or which data structure you are using) in the next function. The pipe “automates” this and pipes the results of the previous function directly into this function. It might sound a little confusing at first, but once you start using it, it really can make your code quicker and easier to write and run and it stops us having to create lots of additional variables to store outputs along the way. It also enabled the code we used last week to load/read all the csvs at once. In our workflow, we have so far: Joined our two data frames together. Removed the columns not needed for our future analysis. Let’s see how we can combine this process into a single line of code: Option 1: Original code, added pipe # join, then select all_theft_ward_df_speedy_1 &lt;- left_join(all_theft_df, lsoa_ward_lookup, by = c(lsoa_code = &quot;LSOA11CD&quot;)) %&gt;% dplyr::select(crime_id, month, longitude, latitude, lsoa_name, lsoa_code, crime_type, WD18CD, WD18NM) You should see that we now end up with a data frame akin to our final output above - the same number of observations and variables, all from one line of course. We could also take another approach in writing code, by completing our selection prior to our join, which would mean having to write out fewer field names when piping this output into our join: Option 2: New code, remove columns first # select, then join all_theft_ward_df_speedy_2 &lt;- dplyr::select(lsoa_ward_lookup, LSOA11CD, WD18CD, WD18NM) %&gt;% right_join(all_theft_df, by = c(LSOA11CD = &quot;lsoa_code&quot;)) What these two options do show is that there are multiple ways to achieve the same output, using similar code. Pipes help us improve the efficiency of our code. That being said: by adding the pipe, we are not able to check our join prior to the selection, so often it is better to add in improve the efficiency of your code once you are certain that your code has run correctly. 5.2.7 Aggregate crime by ward To aggregate our crime by ward for each month in 2020, we need to use a combination of dplyr functions. First, we need to group our crime by each ward and then count - by month - the number of thefts occurring in each ward. To do so, we will use the group_by() function and the count() function. The group_by() function creates a “grouped” copy of the table (in memory), then any dplyr function used on this grouped table will manipulate each group separately (i.e. our count by month manipulation) and then combine the results to a single output. If we solely run the group_by() function, we won’t really see this effect on its own, instead we need to add the count() function, which counts the number of rows in each group defined by the variables provided within the function, in our case, month: # group our crimes by ward, then count the number of thefts occurring in each # month theft_count_month_ward &lt;- group_by(all_theft_ward_df, WD18CD) %&gt;% count(month) To understand our output, go ahead and View() the variable. You should see that we have ended up with a new table that lists each ward (by the WD18CD column) twelve times, to detail the number of thefts for each month - with the months represented as a single field. What we would really prefer is to have our crime count detailed as one field for each individual month, i.e. 2020-01 as a single field, then 2020-02, etc. To change the shape of our data, we are going to need to use tidyr’s pivot functions. In the tidyr library, we have the choice of two pivot() functions: pivot_longer() or pivot_wider(). pivot_wider() “widens” data, increasing the number of columns and decreasing the number of rows. pivot_longer() “lengthens” data, increasing the number of rows and decreasing the number of columns. Our data is already pretty long, so that seems to suggest that we should use pivot_wider(). We just need to first read through the documentation to figure out what parameters we need to use and how. Type ?pivot_wider into the console to access the documentation. If we read through the documentation, we can figure our that our two parameters of interest are the names_from and values_from fields. We use the names_from parameter to set our month column as the column from which to derive output fields from, and the values_from field as our n field (count field) to set our values. As we do not have a field that uniquely identifies each of our rows, we can not use the id_cols parameter. We will therefore need to state the parameters in our code to make sure the function reads in our fields for the right parameter: # pivot wider theft_by_ward_month_df &lt;- pivot_wider(theft_count_month_ward, names_from = month, values_from = n) # inspect theft_by_ward_month_df ## # A tibble: 645 × 13 ## # Groups: WD18CD [645] ## WD18CD `2020-01` `2020-02` 2020-…¹ 2020-…² 2020-…³ 2020-…⁴ 2020-…⁵ 2020-…⁶ ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 E05000026 30 28 25 6 12 13 11 10 ## 2 E05000027 2 1 1 1 1 NA 3 1 ## 3 E05000028 1 1 2 2 2 1 NA 1 ## 4 E05000029 NA NA NA NA 2 NA 2 NA ## 5 E05000030 3 NA NA 1 NA 1 NA 3 ## 6 E05000031 4 NA 4 2 1 NA 1 1 ## 7 E05000032 NA NA 2 NA 2 3 2 1 ## 8 E05000033 1 2 5 NA NA 1 NA 1 ## 9 E05000034 1 NA 1 NA 1 2 1 NA ## 10 E05000035 3 4 NA NA 4 2 3 3 ## # … with 635 more rows, 4 more variables: `2020-09` &lt;int&gt;, `2020-10` &lt;int&gt;, ## # `2020-11` &lt;int&gt;, `2020-12` &lt;int&gt;, and abbreviated variable names ## # ¹​`2020-03`, ²​`2020-04`, ³​`2020-05`, ⁴​`2020-06`, ⁵​`2020-07`, ⁶​`2020-08` One final thing we want to do is clean up the names of our fields to mean a little more to us. Let’s transform our numeric dates to text dates (and change our WD18CD in the process). # rename columns names(theft_by_ward_month_df) &lt;- c(&quot;ward_code&quot;, &quot;jan_2020&quot;, &quot;feb_2020&quot;, &quot;mar_2020&quot;, &quot;apr_2020&quot;, &quot;may_2020&quot;, &quot;jun_2020&quot;, &quot;jul_2020&quot;, &quot;aug_2020&quot;, &quot;sept_2020&quot;, &quot;oct_2020&quot;, &quot;nov_2020&quot;, &quot;dec_2020&quot;) Write out the completed theft table to a new csv file for future reference: # write out the theft_crime_df to a csv within our ouput data folder write.csv(theft_by_ward_month_df, &quot;data/output/theft_by_ward_per_month_2020.csv&quot;, row.names = FALSE) 5.2.8 Joining crime data to wards We are now getting to the final stages of our data processing, we just need to join our completed theft table, theft_by_ward_month_df to our ward_population spatial data frame and then compute a theft crime rate. This will then allow us to map our theft rates per month by ward, exactly what we set to achieve within this practical. Luckily for us, the join approach we used earlier between our all_theft_df and our lsoa_ward_lookup is the exact same approach we need for this, even when dealing with spatial data. Let’s go ahead and use the same left_join() function to join our two data frames together. In this case, we want to keep all rows in our ward_population spatial data frame, so this will be our x data frame, whilst the theft_by_ward_month_df will be our y. # join theft by month to the correct wards in our ward_population data frame all_theft_ward_sdf &lt;- left_join(ward_population, theft_by_ward_month_df, by = c(GSS_CODE = &quot;ward_code&quot;)) To double-check our join, we want to do one extra step of quality checks and check that each of our wards has at least one occurence of crime over the twelve month period. We do this by computing a new column that totals the number of thefts. By identifying any wards that have zero entries (i.e. NAs for each month), we can double-check with our original theft_by_ward_month_df to see if this is the correct “data” for that ward or if there has been an error in our join. We can compute a new column by using the mutate() function from the dplyr library. We use the rowsums() function from the base library to compute the sum of rows and we use the across() function from the dplyr library to identify the columns for which we want to know the sum. # total number of thefts for each ward, create new column all_theft_ward_sdf &lt;- all_theft_ward_sdf %&gt;% mutate(theft_total = rowSums(across(8:19), na.rm = T)) You can now View() our updated all_theft_ward_sdf spatial data frame and sort out columns to see those with a theft_total of 0. What you should see is that we have approximately 20 City of London wards without data, whilst we do indeed have 10 additional wards without data. This seems not unlikely, so we can move forward with our dataset as it is, but what we will need to do is adjust the values present within these wards prior to our visualisation analysis: these should not have NA as their value but rather 0. In comparison our City of London wards should only contain NA. To make sure our data is as correct as possible prior to visualisation, we will remove our City of London wards that do not have any data (crime or population), and then convert the NA in our theft counts to 0. # filter out City of London wards with a crime count of 0 or a population of 0 all_theft_ward_sdf &lt;- filter(all_theft_ward_sdf, theft_total &gt; 0 | DISTRICT != &quot;City and County of the City of London&quot;) # remove the ward of Vintry, which whilst it has a positive crime count, it # does not contain a population all_theft_ward_sdf &lt;- filter(all_theft_ward_sdf, NAME != &quot;Vintry&quot;) # replace all NAs in our data frame with 0 all_theft_ward_sdf[is.na(all_theft_ward_sdf)] = 0 The final step we need to take before we can map our theft data is, of course, compute a crime rate per month for our all_theft_ward_sdf data frame. We have our pop2019 column within our all_theft_ward_sdf data frame - we just need to figure out the code that allows us to apply our calculation that we’ve used in our previous practicals (i.e. using the Attribute/Field Calculator in QGIS: value/pop2019 * 10000) to each of our datasets. Once again, after a bit of searching, we can find out that the mutate() function comes in handy and we can follow a specific approach in our code that allows us to apply the above equation to all of our columns within our data frame. Now this is certainly a big jump in terms of complexity of our code: we are going to store within our crime_rate variable our own function that calculates crime rate on a given value, currently called x. We will then apply this function on each relevant cell within our all_theft_ward_sdf using the mutate_at() function: # create a new function called crime rate, which takes an argument, x, and the # crime rate calculation crime_rate = function(x, na.rm = FALSE) ((x/all_theft_ward_sdf$pop2019) * 10000) # apply this calculation to all columns between 8 and 19 within the # all_theft_ward_sdf and transform the values theft_crime_rate_sdf &lt;- mutate_at(all_theft_ward_sdf, vars(8:19), crime_rate) Have a look at your new theft_crime_rate_sdf spatial data frame. Does it look as you would expect? Now we have our final data frame, we can go ahead and make our maps. 5.2.9 Mapping crime data For making our maps, we will be using one of two main visualisation libraries that can be used for spatial data: tmap. tmap is a library written around thematic map visualisation. The package offers a flexible, layer-based, and easy to use approach to create thematic maps, such as choropleths and bubble maps. What is really great about tmap is that it comes with one quick plotting method for a map called: qtm(). We can use this function to plot the theft crime rate for one of our months really quickly. Within your script, use the qtm function to create a map of theft crime rate in London in January 2020. Note Before continuing do confirm whether your theft_crime_rate_sdf is indeed still of class sf. In some instances it is possible that this changed when manipulating the attributes. You can simply check this by running class(theft_crime_rate_sdf). If your dataframe is not of class sf, you can force it into one by running theft_crime_rate_sdf &lt;- st_as_sf(theft_crime_rate_sdf)). # quick thematic map for January 2020 qtm(theft_crime_rate_sdf, fill = &quot;jan_2020&quot;) In this case, the fill argument is how we tell tmap to create a choropleth map based on the values in the column we provide it with. If we simply set it to NULL, we would only draw the borders of our polygons. Within our qtm function, we can pass quite a few different parameters that would enable us to change specific aesthetics of our map - if you go ahead and look up the documentation for the function, you will see a list of these parameters. We can, for example, set the lines of our ward polygons to white by adding the borders parameter: # quick thematic map for January 2020, include white borders qtm(theft_crime_rate_sdf, fill = &quot;jan_2020&quot;, borders = &quot;white&quot;) The map does not really look great. We can continue to add and change parameters in our qtm() function to create a map we are satisfied with. However, the issue with the qtm() function is that it is quite limited in its functionality and mostly used to quickly inspect your data. Instead, when we want to develop more complex maps using the tmap library, we want to use their main plotting method which uses a function called tm_shape(), which we build on using the layered grammar of graphics approach. Tip When it comes to setting colours within a map or any graphic, we can either pass through a colour as a word, a HEX code or a pre-defined palette. You can find out more here, which is a great quick reference to just some of the possible colours and palettes you will be able to use in R. The main approach to creating maps in tmap is to use the grammar of graphics to build up a map based on what is called the tm_shape() function. Essentially this function, when populated with a spatial data frame, takes the spatial information of our data (including the projection and geometry of our data) and creates a spatial “object”. This object contains some information about our original spatial data frame that we can override (such as the projection) within this function’s parameters, but ultimately, by using this function, you are instructing R that this is the object from which to “draw my shape”. To actually draw the shape, we next need to add a layer to specify the type of shape we want R to draw from this information - in our case, our polygon data. We need to add a function therefore that tells R to “draw my spatial object as X” and within this “layer”, you can also specific additional information to tell R how to draw your layer. You can then add in additional layers, including other spatial objects (and their related shapes) that you want drawn on your map, plus a specify your layout options through a layout layer. Let’s see how we can build up our first map in tmap. # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons tm_polygons() As you should now see, we have now mapped the spatial polygons of our theft_crime_rate_sdf spatial data frame. However, this is not the map we want: we want to have our polygons represented by a choropleth map where the colours reflect the theft crime rate in January, rather than the default grey polygons we see before us. To do so, we use the col= parameter that is within our tm_polygons() shape. Tip The col parameter within tm_polygons() is used to fill our polygons with a specific fill type, of either: a single color value (e.g. red) the name of a data variable that is contained in the spatial data file Either the data variable contains color values, or values (numeric or categorical) that will be depicted by a specific color palette. MAP_COLORS. In this case polygons will be colored such that adjacent polygons do not get the same color. Let’s go ahead and pass our jan_2020 column within the col= parameter and see what we get: # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column tm_polygons(col = &quot;jan_2020&quot;) We are slowly getting there. But there are two things we can notice straight away that do not look right about our data. The first is that our classification breaks do not really reflect the variation in our dataset. This is because tmap has defaulted to its default break type: pretty breaks, whereas, as we know, using an approach such as natural breaks, aka jenks, may reveal better variation in our data. Using the documentation for tm_polygons(), it looks like the following parameters are relevant to help us create the right classification for our map: n: state the number of classification breaks you want. style: state the style of breaks you want, e.g. fixed, sd, equal, quantile. breaks: state the numeric breaks you want to use when using the fixed style approach. Let’s say we want to change our choropleth map to have 5 classes, determined via the jenks method. We simply need to add the n and style parameters into our tm_polygons() layer: # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column, specifying jenks tm_polygons(col = &quot;jan_2020&quot;, n = 5, style = &quot;jenks&quot;) We now have a choropleth that reflects better the distribution of our data, but we can make them a little prettier by rounding the values. To do so, we can change the style of the map to fixed and then supply a new argument for breaks that contains the rounded classification breaks: # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column, specifying fixed breaks tm_polygons(col = &quot;jan_2020&quot;, n = 5, style = &quot;fixed&quot;, breaks = c(0, 5, 16, 40, 118, 434)) That looks a little better from the classification side of things. We still have one final data-related challenge to solve, before we start to style our map and that is showing the polygons for City of London wards, even though we have no data for them. The easiest way to do so is to simply add a spatial object to our map that symbolises our polygons as grey wards and then draw the crime data on top: # set out tm_shape equal to our original ward data frame tm_shape(ward_population) + # draw out spatial objects as polygons, set to grey tm_polygons(&quot;gray&quot;) + # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column, specifying fixed breaks tm_polygons(col = &quot;jan_2020&quot;, n = 5, style = &quot;fixed&quot;, breaks = c(0, 5, 16, 40, 118, 434)) Note The order of your layers matters. What happens if you were to switch the layers around, i.e. first add the crime rate layer and then the “grey” ward layer? Why? 5.2.10 Styling crime data To style our map takes a further understanding and familiarity with our tmap library, but it is only something you will only really learn by having to make your own maps. As a result, we will not go into explaining exactly every aspect of map styling but instead provide you with some example code that you can use as well as experiment with to try to see how you can adjust aspects of the map to your preferences. Fundamentally, the key functions to be aware of: tm_layout(): contains parameters to style titles, fonts, the legend, etc.; tm_compass(): contains parameters to create and style a North arrow or compass; tm_scale_bar(): contains parameters to create and style a scale bar. To be able to start styling our map, we need to interrogate each of these functions and their parameters to trial and error options to ultimately create a map we are happy with: # set out tm_shape equal to our original ward data frame tm_shape(ward_population) + # draw out spatial objects as polygons, set to grey tm_polygons(&quot;gray&quot;, border.col = &quot;gray&quot;) + # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column, # specifying fixed breaks, colour palette, and borders tm_polygons( col = &quot;jan_2020&quot;, n = 5, style = &quot;fixed&quot;, breaks = c(0, 5, 16, 40, 118, 434), palette = &quot;Blues&quot;, border.col = &quot;white&quot;, title = &quot;Rate per 10,000 people&quot; ) + # add title tm_layout( main.title = &quot;Theft Crime January 2020&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.position = c(&quot;left&quot;, &quot;top&quot;), legend.title.size = 1, legend.title.fontface = 2 ) + # add North arrow tm_compass( type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;) ) + # add scale bar tm_scale_bar( breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;) ) We will leave it at this, although there is a few more things we would want to do such as adding an additional legend property to state why the City of London wards are grey (No Data) as well as add our data source information. 5.2.11 Exporting our crime data Once we are finished making our map, we can go ahead and export it to our maps folder. To do so, we need to save our map-making code to as a variable and then use the tmap_save() function to save the output of this code to a picture within our maps folder. # add map object to variable jan2020_map &lt;- # set out tm_shape equal to our original ward data frame tm_shape(ward_population) + # draw out spatial objects as polygons, set to grey tm_polygons(&quot;gray&quot;, border.col = &quot;gray&quot;) + # set our tm_shape equal to our spatial data frame tm_shape(theft_crime_rate_sdf) + # draw out spatial objects as polygons, specifying a data column, # specifying fixed breaks, colour palette, and borders tm_polygons( col = &quot;jan_2020&quot;, n = 5, style = &quot;fixed&quot;, breaks = c(0, 5, 16, 40, 118, 434), palette = &quot;Blues&quot;, border.col = &quot;white&quot;, title = &quot;Rate per 10,000 people&quot; ) + # add title tm_layout( main.title = &quot;Theft Crime January 2020&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.position = c(&quot;left&quot;, &quot;top&quot;), legend.title.size = 1, legend.title.fontface = 2 ) + # add North arrow tm_compass( type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;) ) + # add scale bar tm_scale_bar( breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;) ) # save as image tmap_save(jan2020_map, filename = &quot;data/map/jan2020_theft_crime_map.png&quot;) We also want to export the rest of our hard work in terms of data wrangling that we have completed for this practical, so let’s go ahead and export our data frames so we can use them in future projects. # write out the all_theft_ward_sdf to a shapefile within our output data folder st_write(theft_crime_rate_sdf, &quot;data/output/theft_rate_by_ward_per_month_2020.shp&quot;, row.names = FALSE) # write out the all_theft_ward_sdf to a shapefile within our output data folder st_write(all_theft_ward_sdf, &quot;data/output/theft_count_by_ward_per_month_2020.shp&quot;, row.names = FALSE) # write out the all_theft_ward_sdf to a csv within our output data folder write.csv(all_theft_ward_sdf, &quot;data/output/theft_count_by_ward_per_month_2020.csv&quot;, row.names = FALSE) 5.3 Assignment For your assignment for this week, we want you to create a map for a different month of 2020 with a different layout and look. Keep in mind: You will need to really think about your classification breaks when you change to map a different dataset. Play with the different settings, e.g. change the colours of the map, change the legend title name, change the type of North arrow, etc. If you are up for a challenge: now try to create a map in which you incorporate the maps of two different months together in one figure. Google is your friend! 5.4 Want more? [Optional] 5.4.1 Git and Github Git is a version control system, originally developed to help groups of developers work collaboratively on big software projects. One way to think about it is in terms of “Track Changes” used for documents, only this time it is applied to code - and much more powerful. A great resource to help you get started with Git is Happy Git and GitHub for the useR. Highly recommended. 5.5 Before you leave And that is how you use R as a GIS in its most basic form. More RGIS in the coming weeks, but this concludes the tutorial for this week. "],["analysing-spatial-patterns-i-geometric-operations-and-spatial-queries.html", "6 Analysing Spatial Patterns I: Geometric Operations and Spatial Queries 6.1 Reading list 6.2 Map challenge 6.3 Bike theft in London 6.4 Assignment 6.5 Before you leave", " 6 Analysing Spatial Patterns I: Geometric Operations and Spatial Queries This week, we will be looking at the use of geometric operations and spatial queries within spatial data processing and analysis. Geometric operations and spatial queries are not really a theoretical topic per se but rather essential building blocks to overall spatial data processing and analysis such as calculating the area covered by an individual polygon in an areal unit dataset to running buffer and point-in-polygon calculations. 6.1 Reading list Essential readings Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 4: Spatial data operations. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 5: Geometry operations. [Link] Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, Chapter 6: Reprojecting geographic data. [Link] Suggested readings Houlden, V. et al. 2019. A spatial analysis of proximate greenspace and mental wellbeing in London. Applied Geography 109: 102036. [Link] Malleson, N. and Andresen, M. 2016. Exploring the impact of ambient population measures on London crime hotspots. Journal of Criminal Justice 46: 52-63. [Link] Oliver, L., Schuurman, N. and Wall, A. 2007. Comparing circular and network buffers to examine the influence of land use on walking for leisure and errands. International Journal of Health Geographics 6: 41. [Link] 6.2 Map challenge Before we start with this week’s tutorial, we will start with a small formative assessment: a 45-minute map challenge. During this task you have 45 minutes to create a map using a specific dataset. After 45 minutes you need to stop coding and show the resulting map to the teaching staff who will look at each of your maps individually and provide formative feedback on your code and map layout. All instructions can be found here: [Link]. 6.3 Bike theft in London This week, we will be investigating bike theft in London in 2019 and look to confirm a very simple hypothesis: that bike theft primarily occurs near tube and train stations. We will be investigating its distribution across London using the point data provided within our crime dataset. We will then compare this distribution to the location of train and tube stations using specific geometric operations and spatial queries that can compare the geometry of two (or more) datasets. We will also learn how to download data from OpenStreetMap as well as use an interactive version of tmap to explore the distribution of the locations of individual bike theft against the locations of these stations. 6.3.1 Housekeeping Open a new script within your GEOG0030 project and save this script as wk6-bike-theft-analysis.r. At the top of your script, add the following metadata (substitute accordingly): # Analysing bike theft and its relation to stations using geometric analysis # Date: January 2023 # Author: Justin Within your script, add the following libraries for loading: # libraries library(tidyverse) library(sf) library(tmap) library(janitor) library(RColorBrewer) library(osmdata) # change tmap mode to plot tmap_mode(&quot;plot&quot;) 6.3.2 Loading data This week, we will start off using three datasets: London Ward boundaries for 2018 Crime in London for 2019 from data.police.uk Train and tube Stations from Transport for London File download File Type Link Crime in London 2019 csv Download Train and tube stations in London kml Download Download the files above. Store your crime_all_2019_london.csv in your data/raw/crime folder. Move your tfl_stations.kml download to your raw data folder and create a new transport folder to contain it. The London Ward boundaries for 2019 should still be in your data/raw/boundaries folder. Let’s first load our London Ward shapefile: # read in our 2018 London Ward boundaries london_ward_shp &lt;- read_sf(&quot;data/raw/boundaries/2018/London_Ward.shp&quot;) Check the CRS of our london_ward_shp spatial dataframe: # check the CRS for the 2018 London Ward boundaries st_crs(london_ward_shp) ## Coordinate Reference System: ## User input: OSGB36 / British National Grid ## wkt: ## PROJCRS[&quot;OSGB36 / British National Grid&quot;, ## BASEGEOGCRS[&quot;OSGB36&quot;, ## DATUM[&quot;Ordnance Survey of Great Britain 1936&quot;, ## ELLIPSOID[&quot;Airy 1830&quot;,6377563.396,299.3249646, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4277]], ## CONVERSION[&quot;British National Grid&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,49, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-2, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996012717, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,400000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,-100000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United Kingdom (UK) - offshore to boundary of UKCS within 49°45&#39;N to 61°N and 9°W to 2°E; onshore Great Britain (England, Wales and Scotland). Isle of Man onshore.&quot;], ## BBOX[49.75,-9,61.01,2.01]], ## ID[&quot;EPSG&quot;,27700]] Of course it should be of no surprise that our london_ward_shp spatial dataframe is in BNG / ESPG: 27700, however, it is always good to check. Let’s go ahead and read in our tfl_stations dataset: # read in our London stations dataset london_stations &lt;- read_sf(&quot;data/raw/transport/tfl_stations.kml&quot;) This dataset is provided as a kml file, which stands for Keyhole Markup Language (KML). KML was originally created as a file format used to display geographic data in Google Earth. So we definitely need to check what CRS this dataset is in and decide whether we will need to do some reprojecting. # check the CRS for the London stations st_crs(london_stations) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] The result informs us that we are going to need to reproject our data in order to use this dataframe with our london_ward_shp spatial dataframe. Luckily in R and the sf library, this reprojection is a relatively straight-forward transformation, requiring only one function: st_transform(). The function is very simple to use: you only need to provide the function with the dataset and the code for the new CRS you wish to use with the data: # reproject our data from WGS84 to BNG london_stations &lt;- st_transform(london_stations, 27700) We can double-check whether our new variable is in the correct CRS by using the st_crs() command: # check the CRS for the London stations st_crs(london_stations) ## Coordinate Reference System: ## User input: EPSG:27700 ## wkt: ## PROJCRS[&quot;OSGB36 / British National Grid&quot;, ## BASEGEOGCRS[&quot;OSGB36&quot;, ## DATUM[&quot;Ordnance Survey of Great Britain 1936&quot;, ## ELLIPSOID[&quot;Airy 1830&quot;,6377563.396,299.3249646, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4277]], ## CONVERSION[&quot;British National Grid&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,49, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-2, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996012717, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,400000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,-100000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United Kingdom (UK) - offshore to boundary of UKCS within 49°45&#39;N to 61°N and 9°W to 2°E; onshore Great Britain (England, Wales and Scotland). Isle of Man onshore.&quot;], ## BBOX[49.75,-9,61.01,2.01]], ## ID[&quot;EPSG&quot;,27700]] You should see that our london_stations spatial dataframe is now in BNG / EPSG: 27700. We are now ready to load our final dataset - our csv that contains our crime from 2019. From this csv, we want to do three things: Extract only those crimes that are bicycle thefts, i.e. crime_type == \"bicycle theft\". Convert our csv into a spatial dataframe that shows the locations of our crimes, determined by the latitude and longitudes provided, as points. Transform our data from WGS84 / 4326 to BNG / 27700. Since we are getting pretty used to looking at code and cleaning data we should be able to chain these operations using the %&gt;% operator: # read in our crime data csv from our raw data folder bike_theft_2019 &lt;- read_csv(&quot;data/raw/crime/crime_all_2019_london.csv&quot;) %&gt;% # clean names with janitor clean_names() %&gt;% # filter according to crime type and ensure we have no NAs in our dataset filter(crime_type == &quot;Bicycle theft&quot; &amp; !is.na(longitude) &amp; !is.na(latitude)) %&gt;% # select just the longitude and latitude columns dplyr::select(longitude, latitude) %&gt;% # transform into a point spatial dataframe # note providing the columns as the coordinates to use # plus the CRS, which as our columns are long/lat is WGS84/4236 st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4236) %&gt;% # convert into BNG st_transform(27700) We now have our three datasets loaded, it is time for a little data checking. We can see just from our Environment window that in total, we have 302 stations and 18,744 crimes to look at in our analysis. We can double-check the (Attribute) tables of our newly created spatial dataframes to see what data we have to work with. You can either do this manually by clicking on the variable, or using commands such as head(), summary() and names() to get an understanding of our dataframe structures and the field names present.You can choose your approach, but make sure to look at your data. As you should remember from the code above, for our bicycle theft data, we actually only have our geometry column because this is all that we extracted from our crime csv. For our london_stations spatial dataframe, we have a little more information, including the name of the station and its address - as well as its geometry. Now, let’s map all three layers of data onto a single map using tmap: # plot our London Wards first tm_shape(london_ward_shp) + tm_fill() + # then add bike crime as blue tm_shape(bike_theft_2019) + tm_dots(col = &quot;blue&quot;) + # then add our stations as red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # then add a north arrow tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + # then add a scale bar tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) Let’s think about the distribution of our data: we can already see that our bike theft is obviously highly concentrated in the centre of London although we can certainly see some clusters in the Greater London areas. Let’s go ahead and temporally remove the bike theft data from our map for now to see where our tube and train stations are located. To remove the bike data, simply put a comment sign in front of that piece of code and re-run the code: # plot our London Wards first tm_shape(london_ward_shp) + tm_fill() + # then add bike crime as blue # tm_shape(bike_theft_2019) + tm_dots(col=&quot;blue&quot;) + # then add our stations as red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # then add a north arrow tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + # then add a scale bar tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) We can see our train and tube stations are only present in primarily the north of London and not really present in the south. This is not quite right and in fact our dataset only contains those train stations used by Transport for London within the tube network rather than all the stations in London. We will need to fix this before conducting our full analysis. But this isn’t the only problem with our dataset. We can also see that both our bike_theft spatial dataframe and our london_stations spatial dataframe extend beyond our London boundaries. 6.3.3 Data preparation When we want to reduce a dataset to the spatial extent of another, there are two different approaches to conducting this in spatial analysis: a subset or a clip. Each deal with the geometry of the resulting dataset in slightly different ways. A clip-type operation works a bit like a cookie-cutter: it will take the geometry of the input layer (i.e. the layer you want to clip), places a ‘cookie-cutter’ layer on top (i.e. the layer you want to clip by) and then returns only the parts of the input layer contained within the cookie-cutter. This will mean that the geometry of our resulting layer will be modified, if it contains observation features that extend further than the ;cookie-cutter’ extent it will literally ‘cut’ the geometry of our data. A subset-type operation is what is known in GIScience-speak as a select by location query. In this case, our subset will return the full geometry of each observation feature of the input layer that intersects with our second layer. Any geometry that does not intersect with our second layer will be removed from the geometry of our resulting layer. Note Luckily for us, as we are using point data, we can (theoretically) use either approach because it is not possible to split the geometry of a single point feature. When it comes to polygon and line data, not understanding the differences between the two approaches can lead you into difficulties with your data processing as there will be differences in the feature geometry between the clipped layer and the subset layer. Each approach is implemented differently in R. To subset our data, we only need to use the base R library to selection using [] brackets: # subset our bike_theft_2019 spatial dataframe by the london_ward_shp spatial # dataframe bike_theft_2019_subset &lt;- bike_theft_2019[london_ward_shp, ] Conversely, if we want to clip our data, we need to use the st_intersection() function from the sf library. # clip our bike_theft_2019 spatial dataframe by the london_ward_shp spatial # dataframe bike_theft_2019 &lt;- bike_theft_2019 %&gt;% st_intersection(london_ward_shp) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries Note Which approach you use with future data is always dependent on the dataset you want to use - and the output you need. For example, is keeping the geometry of your observation features in your dataset important? Out of the two, the subset approach is the fastest to use as R is simply comparing the geometries rather than also editing the geometries. Before we go ahead and sort out our london_stations spatial dataframe, we are going to look at how we can dissolve our london_ward_shp spatial dataframe into a single feature. Reducing a spatial dataframe to a single observation is often required when using R and sf‘s geometric operations to complete geometric comparisons. Sometimes, also, we simply want to map an outline of an area, such as London, rather than add in the additional spatial complexities of our wards. To achieve just a single ’observation’ that represents the outline geometry of our dataset, we use the geometric operation st_union(). Tip You can also use the st_union() function to combine two datasets into one. This can be used to merge data together that are of the same spatial type. Let’s go ahead and see if we can use this to create our London outline: # use st_union to create a single outline of London from our london_ward_shp # spatial dataframe london_outline &lt;- london_ward_shp %&gt;% st_union() You should see that our london_outline spatial data frame only has one observation. You can now go ahead and plot() your london_outline spatial dataframe from your console and see what it looks like: Back to our train and tube stations. We have seen that our current london_stations spatial dataframe really does not provide the coverage of train stations in London that we expected. To add in our missing data, we will be using OpenStreetMap. Note OpenStreetMap (OSM) is a free editable map of the world,although its spatial coverage is still unequal across the world. In addd itoin, as you will find if you use the data, the accuracy and quality of the data can often be quite questionable or simply missing attribute details that we would like to have, e.g. types of roads and their speed limits, to complete specific types of spatial analysis. As a result, do not expect OSM to contain every piece of spatial data that you would want. Whilst there are various approaches to downloading data from OpenStreetMap, we will use the osmdata library to directly extract our required OpenStreetMap (OSM) data into a variable. The osmdata library grants access within R to the Overpass API that allows us to run queries on OSM data and then import the data as either sf or sp objects. These queries are at the heart of these data downloads. To use the library (and API), we need to know how to write and run a query, which requires identifying the key and value that we need within our query to select the correct data. Essentially every map element (whether a point, line or polygon) in OSM is “tagged” with different attribute data. In our case, we are looking for train stations, which fall under the key, Public Transport, with a value of station as outlined in their wiki. These keys and values are used in our queries to extract only map elements of that feature type - to find out how a feature is “tagged” in OSM is simply a case of reading through the OSM documentation and becoming familiar with their keys and values. In addition to this key-value pair, we also need to obtain the bounding box of where we want our data to be extracted from, i.e. London, to prevent OSM searching the whole map of the world for our feature (although the API query does have in-built time and spatial coverage limits to stop this from happening). Let’s try to extract elements from OSM that are tagged as public_transport = station from OSM into an osmdata_sf() object: # extract the coordinates from our London outline using the st_bbox() function # note we also temporally reproject the london_outline spatial dataframe before obtaining the bbox # we need our bbox coordinates in WGS84 (not BNG), hence reprojection p_bbox &lt;- st_bbox(st_transform(london_outline, 4326)) # pass our bounding box coordinates into the OverPassQuery (opq) function london_stations_osm &lt;- opq(bbox = p_bbox) %&gt;% # pipe this into the add_osm_feature data query function to extract our stations add_osm_feature(key = &quot;public_transport&quot;, value = &quot;station&quot;) %&gt;% # pipe this into our osmdata_sf object osmdata_sf() Note In some instances the OSM query will return an error, especially when several people from the same location are executing the exact same query at the same time. If that is the case you can download the london_stations_osm object here: [Download]. After downloading, you can copy the file to your working directory and load the object using the load() function. Tip When we download OSM data, and extract it as above, our query will return all elements tagged as our key-value pair into our osmdata_sf() OSM data object. This means all elements associated with our tag will be returned: any points, lines and polygons. We might think with our public_transport = station tag, we would only return point data representing our train and tube stations in London. But if we use the summary() function on our london_stations_osm OSM data object, we can see that not only is a lot of other data stored in our OSM data object (including the bounding box we used within our query, plus metadata about our query), but our query has returned both points and polygons stored within this OSM data object as individual spatial data frames. To extract only the points of our tube and train stations from our london_stations_osm OSM data object, we simply need to extract this from the dataframe and store this under a separate variable. But, whenever you are dealing with OSM data, just remember that your query can return multiple different types of map elements (and their respective geometries), so always be clear in knowing which type of spatial data you will need and remember to extract this from your OSM data object. Extract train station points from our OSM data object and process/clean ready for analysis: # extract only the points data from the osmdata object london_stations_osm &lt;- london_stations_osm$osm_points %&gt;% # add projection to the point spatial dataframe st_set_crs(4326) %&gt;% # reproject our dataset to BNG st_transform(27700) %&gt;% # clip to the London outline shapefile st_intersection(london_outline) %&gt;% # select only attributes that seem relevant dplyr::select(c(&quot;osm_id&quot;, &quot;name&quot;, &quot;network&quot;, &quot;operator&quot;, &quot;public_transport&quot;, &quot;railway&quot;)) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries # inspect plot(london_stations_osm) With the accuracy of OSM a little questionable, we want to complete some data validation tasks to check its quality and to confirm that it at least contains the data we see in our authoritative london_stations spatial dataframe. The total number of data points also seems rather high. In fact, a quick search online can tell us that there are 272 tube stations in the London network as well as 335 train stations in Greater London. As we can see in our plot above, not all of our stations appear to be of the same value in our railway field. If we check the field using our count() function, you will see that there are some different values and NAs in our dataset: # inspect values count(london_stations_osm, railway) ## Simple feature collection with 6 features and 2 fields ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: 505078.2 ymin: 159027.2 xmax: 556185.7 ymax: 200138.6 ## Projected CRS: OSGB36 / British National Grid ## railway n geometry ## 1 entrance 2 MULTIPOINT ((532814.8 16572... ## 2 station 604 MULTIPOINT ((505078.2 17673... ## 3 stop 2 MULTIPOINT ((513225.1 18452... ## 4 subway_entrance 7 MULTIPOINT ((512210.7 17613... ## 5 tram_stop 6 MULTIPOINT ((524730.4 17025... ## 6 &lt;NA&gt; 1057 MULTIPOINT ((505596.3 18419... As we can see, not everything in our london_stations_osm spatial dataframe is a station as recorded by OSM and we have a high number of NAs which are unlikely to actually represent stations in London. The number of points marked as station in the railway field are most likely the only points in our dataset that represent actual stations in London. There is still a difference between the official numbers and the OSM extract, but we will go on and use the best information we have from this attribute and our search and remove all other points from our OSM dataset: # extract only the points that we think are actual train and tube stations london_stations_osm &lt;- london_stations_osm %&gt;% filter(railway == &quot;station&quot;) We have now cleaned our london_stations_osm spatial dataframe to remove all those points within our dataset that are not tagged as railway == \"station\". Our london_stations spatial dataframe is of course an authoritative dataset from TfL, so we know at least that this data should be accurate. Therefore, it would be great if we could compare our two datasets to one another spatially to double-check that our london_stations_osm spatial dataframe contains all the data within our london_stations spatial dataframe. We can first look at this by comparing their distributions visually on a map. But first, as our london_stations spatial dataframe still extends outside of London, we will go ahead and clip this: # clip London stations london_stations &lt;- london_stations %&gt;% st_intersection(london_ward_shp) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries Map our two spatial dataframes to compare their spatial coverage: # plot our London Wards first with a grey background tm_shape(london_outline) + tm_fill() + # plot OSM station data in black tm_shape(london_stations_osm) + tm_dots(col = &quot;black&quot;) + # plot TfL station data in red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # add north arrow tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + # add scale bar tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) + # add our OSM contributors statement tm_credits(&quot;© OpenStreetMap contributors&quot;) What we can see is that it looks like our OSM data actual does a much better job at covering all train and tube stations across London but still it is pretty hard to get a sense of comparison from a static map like this whether it contains all of the tube and train stations in our london_stations spatial dataframe. An interactive map would enable us to interrogate the spatial coverage of our two station spatial dataframes further. To do so, we use the tmap_mode() function and change it from its default plot() mode to a view() model: # change tmap mode to view / interactive mapping tmap_mode(&quot;view&quot;) # plot the outline of our London Wards first tm_shape(london_outline) + tm_borders() + # plot OSM station data in black tm_shape(london_stations_osm) + tm_dots(col = &quot;black&quot;) + # plot TfL station data in red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # set basemap tm_basemap(c(StreetMap = &quot;OpenStreetMap&quot;)) Using the interactive map, what we can see is that whilst we do have overlap with our datasets, and more importantly, our london_stations_osm spatial dataframe seems to contain all of the data within the london_stations spatial dataframe, although there are definitely differences in their precise location. Now depending on what level of accuracy we are willing to accept with our assumption that our OSM data contains the same data as our Transport for London data, we could leave our comparison here and move forward with our analysis. There are, however, several more steps we could complete to validate this assumption. The easiest first step is to simply reverse the order of our datasets to check that each london_stations spatial dataframe point is covered by reversing the drawing order: # plot the outline of our London Wards first tm_shape(london_outline) + tm_borders() + # plot TfL station data in red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # plot OSM station data in black tm_shape(london_stations_osm) + tm_dots(col = &quot;black&quot;) + # set basemap tm_basemap(c(StreetMap = &quot;OpenStreetMap&quot;)) 6.3.4 Spatial operations I The comparision looks pretty good but still the question is: can we be sure? Using geometric operations and spatial queries, we can look to find if any of our stations in our london_stations spatial dataframe are not present the london_stations_osm spatial dataframe. We can use specific geometric operations and/or queries that let us check whether or not all points within our london_stations spatial dataframe spatially intersect with our london_stations_osm spatial dataframe, i.e. we can complete the opposite of the clip/intersection that we conducted earlier. The issue we face, however is that, as we saw above, our points are slightly offset from one another as the datasets have ultimately given the same stations slightly different locations. This offset means we need to think a little about the geometric operation or spatial query that we want to use. We will approach this question in two different ways to highlight the differences between geometric operations and spatial queries: We will use geometric operations to generate geometries that highlight missing stations from our london_stations spatial dataframe (i.e. ones that are not present in thelondon_stations_osm spatial dataframe.) We will use spatial queries to provide us with a list of features in our london_stations spatial dataframe that do not meet our spatial requirements (i.e. are not present in thelondon_stations_osm spatial dataframe.) 6.3.4.1 Geometric operations As highlighted above, the offset between our spatial dataframes adds a little complexity to our geometric operations code. To be able to make our direct spatial comparisons across our spatial dataframes, what we first need to do is try to snap the geometry of our london_stations spatial dataframe to our london_stations_osm spatial dataframe for points within a given distance threshold. This will mean that any points in the london_stations spatial dataframe that are within a specific distance of the london_stations_osm spatial dataframe will have their geometry changed to that of the london_stations_osm spatial dataframe. Figure 6.1: Snapping points to a line. In our case we snap our points to other points. By placing a threshold on this snap, we stop too many points moving about if they are unlikely to be representing the same station (e.g. further than 150m or so away) but this still allows us to create more uniformity across our datasets’ geometries (and tries to reduce the uncertainty we add by completing this process). Snap our our london_stations spatial dataframe to our london_stations_osm spatial dataframe for points within a 150m distance threshold: # snap points london_stations_snap &lt;- st_snap(london_stations, london_stations_osm, 150) Now we have out snapped geometry, we can look to compare our two datasets to calculate whether or not our london_stations_osm spatial dataframe is missing any data from our london_stations_snap spatial dataframe. To do so, we will use the st_difference() function which will return us the geometries of those points in our london_stations_snap spatial dataframe that are missing in our our london_stations_osm spatial dataframe. However, to use this function successfully we need to convert our our london_stations_osm spatial dataframe into a single geometry first. To simplify our london_stations_osm spatial dataframe into a single geometry, we simply use the st_union() code we used with our London outline above: # create a single geometry version of our london_stations_osm spatial dataframe london_stations_osm_compare &lt;- london_stations_osm %&gt;% st_union() # compare our two point geometries to identify missing stations missing_stations &lt;- st_difference(london_stations_snap, london_stations_osm_compare) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries You should now find that we apparently have 4 missing stations in our london_stations_osm spatial dataframe. We can plot these missing stations against our london_stations_osm spatial dataframe and confirm whether these stations are indeed missing or not. # plot our london_stations_osm spatial dataframe in black tm_shape(london_stations_osm) + tm_dots(col = &quot;black&quot;) + # plot our missing_stations spatial dataframe in green tm_shape(missing_stations) + tm_dots(col = &quot;green&quot;) + # set basemap tm_basemap(c(StreetMap = &quot;OpenStreetMap&quot;)) When you investigate the missing stations, you can actually see that our london_stations_osm spatial dataframe dataset is actually more accurate than the TfL locations. All ‘missing’ stations are not in fact missing but simply at a greater offset than 150m. We can safely suggest that we can move forward with only using the london_stations_osm spatial dataframe and do not need to follow through with adding any more data to this dataset. 6.3.4.2 Spatial queries Before we go ahead and move forward with our analysis, we will have a look at how we can implement the above quantification using spatial queries instead of geometric operations. Usually, when we want to find out if two spatial dataframes have the same or similar geometries, we would use one of the following queries: st_equals() st_intersects() st_crosses() st_overlaps() st_touches() Ultimately which query or spatial relationship conceptualisation you would choose would depend on the qualifications you are trying to place on your dataset. In our case, considering our london_stations spatial dataframe and our london_stations_osm spatial dataframe, we have to consider the offset between our datasets. We could, of course, snap our spatial dataframe as above but wouldn’t it be great if we could skip this step? To do so, instead of snapping the london_stations spatial dataframe to the london_stations_osm spatial dataframe, we can use the st_is_within_distance() spatial query to ask whether our points in our london_stations spatial dataframe are within 150m of our london_stations_osm spatial dataframe. This ultimately means we can skip the snapping and st_difference() steps and complete our processing in two simple steps. Tip One thing to be aware of when running spatial queries in R and sf is that whichever spatial dataframe is the comparison geometry (i.e. spatial dataframe y in our queries), this spatial dataframe must be a single geometry (as we saw above in our st_difference() geometric operation). If it is not a single geometry, then the query will be run x number of observations * y spatial dataframe number of observations times, which is not the output that we want. By converting our comparison spatial dataframe to a single geometry, the query is only run for the number of observations in x. You should also be aware that any of our spatial queries will return one of two potential outputs: a list detailing the indexes of all those observation features in x that do intersect with y, or a matrix that contains a TRUE or FALSE statement about this relationship. To define whether we want a list or a matrix output, we set the sparse parameter within our query to TRUE or FALSE respectively. Query whether the points in our london_stations spatial dataframe are within 150m of our london_stations_osm spatial dataframe: # create a single geometry version of our `london_stations_osm` spatial # dataframe for comparison london_stations_osm_compare &lt;- london_stations_osm %&gt;% st_union() # compare our two point geometries to identify missing stations london_stations$in_osm_data &lt;- st_is_within_distance(london_stations, london_stations_osm_compare, dist = 150, sparse = FALSE) We can go ahead and count() the results of our query. # count the number of stations within 150m of our the OSM spatial dataframe count(london_stations, in_osm_data) ## Simple feature collection with 2 features and 2 fields ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: 505625.9 ymin: 168579.9 xmax: 556144.8 ymax: 196387.1 ## Projected CRS: OSGB36 / British National Grid ## # A tibble: 2 × 3 ## in_osm_data[,1] n geometry ## * &lt;lgl&gt; &lt;int&gt; &lt;MULTIPOINT [m]&gt; ## 1 FALSE 4 ((510244.5 185830.3), (533644.3 188926.1), (537592.5 17… ## 2 TRUE 282 ((505625.9 184164.2), (507565.2 185008.3), (507584.9 17… Great - we can see we have 4 stations missing (4 FALSE observations), just like we had in our geometric operations approach. We can double-check this by mapping our two layers together: # plot our london_stations by the in_osm_data column tm_shape(london_stations) + tm_dots(col = &quot;in_osm_data&quot;) + # add our missing_stations spatial dataframe tm_shape(missing_stations) + tm_dots(col = &quot;green&quot;) + # set basemap tm_basemap(c(StreetMap = &quot;OpenStreetMap&quot;)) You can turn on and off the missing_stations layer to compare the locations of these points to the FALSE stations within our london_stations_osm spatial dataframe, generated by our spatial query. 6.3.4.3 File export Now we have done our checks and we know that we can move forward with using our tube and train station file, we should save a copy for usage at a later stage. Save your london_stations_osm spatial dataframe under the transport folder in your raw directory as a shapefile: # write out london_stations_osm to a shapefile st_write(london_stations_osm, &quot;data/raw/transport/osm_stations.shp&quot;) 6.3.5 Spatial operations II We now have our London bike theft and train stations ready for analysis and we just need to complete one last step of processing with this dataset to find out whether or not bike theft occurs more often near to a train station. As above, we can use both geometric operations or spatial queries to complete this analysis. 6.3.5.1 Geometric operations Our first approach using geometric operations will involve the creation of a buffer around each train station to then identify which bike thefts occur within 400m of a train or tube station. When it comes to buffers, we need to consider two main things: what distance will we use (and are we in the right CRS to use a buffer) and whether we want individual buffers or a single buffer. Figure 6.2: A single versus multiple buffer. The single buffer represents a dissolved version of the multiple buffer option. Source: Q-GIS, 2020. In terms of CRS, we want to make sure we use a CRS that defines its measurement units in metres. If our CRS does not use metres as its measurement unit, it might be in a base unit of an Arc Degree or something else that creates difficulties when converting between a required metre distance and the measurement unit of that CRS. In our case, we are using British National Grid and, luckily for us, the units of the CRS is metres, so we do not need to worry about this. In terms of determining whether we can create a single or multiple buffers, we can investigate the documentation of the function st_buffer() to find out what additional parameters it takes. What we can find out is that we need to (of course!) provide a distance for our buffer, but whatever figure we supply this will be interpreted within the units of the CRS we are using. Fortunately none of this is our concern: we know we can simply input the figure or 400 into our buffer and this will generate a buffer of 400m. # generate a 400m buffer around our london_stations_osm dataset, union it to # create one buffer station_400m_buffer &lt;- london_stations_osm %&gt;% st_buffer(dist = 400) %&gt;% st_union() You can then go ahead and plot our buffer to see the results, entering plot(station_400m_buffer) within the console: To find out which bike thefts have occurred within 400m of a station, we will use the st_intersects() function. Tip Before we move forward, one thing to note is that there is a difference between st_intersects() and the st_intersections() function we have been used so far. Unlike the st_intersections() function which creates a ‘clip’ of our dataset, i.e. produces a new spatial dataframe containing the clipped geometry, the st_intersects() function simply identifies whether “x and y geometry share any space”. As explained above, as with all spatial queries, the st_intersects() function can produce two different outputs: either a list detailing the indexes of all those observation features in x that do intersect with y or a matrix that contains a TRUE or FALSE statement about this relationship. As with our previous spatial query, we will continue to use the matrix approach: this means for every single bike theft in London, we will know whether or not it occurred within our chosen distance of a train station. We can then join this as a new column to our bike_theft_2019 spatial dataframe. To detect which bike thefts occur within 400m of a train or tube station, we can do: # test whether a bike theft intersects with our station buffer and store this # as a new column called nr_train_400m bike_theft_2019$nr_train_400 &lt;- bike_theft_2019 %&gt;% st_intersects(station_400m_buffer, sparse = FALSE) We could go ahead and recode this to create a 1 or 0, or YES or NO after processing, but for now we will leave it as TRUE or FALSE. We can go ahead and now visualise our bike_theft_2019 based on this column, to see those occurring near to a train station: # set tmap back to drawing mode tmap_mode(&quot;plot&quot;) # plot our london outline border tm_shape(london_outline) + tm_borders() + # plot our bike theft and visualise the nr_train_400m column tm_shape(bike_theft_2019) + tm_dots(col = &quot;nr_train_400&quot;, palette = &quot;BuGn&quot;) + # add our train stations on top tm_shape(london_stations_osm) + tm_dots(palette = &quot;gray&quot;) + # add our OSM contributors statement tm_credits(&quot;© OpenStreetMap contributors&quot;) It should be of no surprise that visually we can of course see some defined clusters of our points around the various train stations. We can then utilise this resulting dataset to calculate the percentage of bike thefts have occured at this distance, but first we will look at the spatial query approach to obtaining the same data. 6.3.5.2 Spatial queries Like earlier, we can use the st_is_within_distance() function to identify those bike thefts that fall within 400m of a tube or train station in London. We will again need to use the single geometry version of our london_stations_osm spatial dataframe for this comparison with sparse = FALSE to create a matrix that we simply join back to our bike_theft_2019 spatial dataframe as a new column: # compare our two point geometries to identify missing stations bike_theft_2019$nr_train_400_sq &lt;- st_is_within_distance(bike_theft_2019, london_stations_osm_compare, dist = 400, sparse = FALSE) We can count or map the outputs of our two different approaches to check that we have the same output. If you were to do this you will see that we have achieved the exact same output with fewer lines of code and, as a result, quicker processing. However, unlike with the geometric operations, we do not have a buffer to visualise this distance around a train station, which we might want to do for maps in a report or presentation, for example. Once again, it will be up to you to determine which approach you prefer to use. Some people prefer using the more visual techniques of geometric operations, whereas others might find spatial queries to answer the same questions. 6.3.5.3 Theft at train and tube locations? Now we have, for each bike theft in our bike_theft_2019 spatial dataframe, an attribute of whether it occurs within 400m of a train or tube station. We can quite quickly use the count() function to find out just how many thefts these clusters of theft represent. # count the number of bike thefts occuring 400m within a station count(bike_theft_2019, nr_train_400) ## Simple feature collection with 2 features and 2 fields ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: 504861.2 ymin: 159638.3 xmax: 556969.7 ymax: 199879.7 ## Projected CRS: OSGB36 / British National Grid ## # A tibble: 2 × 3 ## nr_train_400[,1] n geometry ## * &lt;lgl&gt; &lt;int&gt; &lt;MULTIPOINT [m]&gt; ## 1 FALSE 8482 ((504907.2 183392.4), (504937.2 184142.4), (504952.2 1… ## 2 TRUE 10253 ((504861.2 175885.4), (505339.2 184226.4), (505394.1 1… Over 40 per cent of bike thefts occur within 400m of a train station - that is quite a staggering amount, but if we consider commuter behaviour this occurrence is not be unexpected. After all, if a bike is left at a train station, it is unlikely to be watched by a ‘suitable guardian’ nor is a simple bike lock likely to deter a thief, making it a ‘suitable target’. Overall, our main hypothesis that bike thefts occur primarily near train and tube stations is perhaps not quite proven, but so far we have managed to quantify that a substantial amount of bike thefts do occur within 400m of these areas. In a final step, we will conduct a very familiar procedure: aggregating our data to the ward level. At the moment, we have now calculated for each bike theft whether or not it occurs within 400m of a tube or train station. We can use this to see if specific wards are hotspots of bike crimes near stations across London. To do this, we will be using the same process we used in QGIS: counting the number of points in each of our polygons, i.e. the number of bike thefts in each ward. To create a point-in-polygon count within sf, we use the st_intersects() function again but instead of using the matrix output of TRUE or FALSE that we have used before, what we actually want to extract from our function is the total number of points it identifies as intersecting with our london_ward_shp spatial dataframe. To achieve this, we use the lengths() function from the base R package to count the number of wards returned within the index list its sparse output creates. Remember, this sparse output creates a list of the bike thefts (by their index) that intersect with each ward. The lengths() function will return the length of this list, i.e. how many bike thefts each ward contains or, in other words, a point-in-polygon count. This time around therefore we do not set the sparse function to FALSE but leave it as TRUE (its default) by not entering the parameter. As a result, we can calculate the number of bike thefts per ward and the number of bike thefts within 400m of a station per ward and use this to generate a theft rate for each ward of the number of bikes thefts that occur near a train station for identification of these hotspots. Calculate the number of bike thefts per ward and the number of bike thefts within 400m of a station per ward using the PIP operation via st_intersects(): # run a point-in-polygon analysis for total number of bike thefts within a ward # using st_intersects function london_ward_shp$total_bike_theft &lt;- lengths(st_intersects(london_ward_shp, bike_theft_2019)) # run a point-in-polygon analysis for number of bike thefts within 400m of # train station within a ward using st_intersects function london_ward_shp$nr_station_bike_theft &lt;- lengths(st_intersects(london_ward_shp, filter(bike_theft_2019, nr_train_400 == TRUE))) As you can see from the code above, we have now calculated our total bike theft and bike theft near a train station for each ward. The final step in our processing therefore is to create our rate of potentially station-related bike theft = bike theft near train station / total bike theft. Note We are looking specifically at the phenomena of whether bike theft occurs near to a train or tube station or not. By normalising by the total bike theft, we are creating a rate that shows specifically where there are hotspots of bike theft near train stations. This, however, will be of course influenced by the number of train stations within a ward, the size of the ward, and of course the number of bikes and potentially daytime and residential populations within an area. Calculate the rate of bike theft within 400m of a train or tube station out of all bike thefts for each ward: # calculate the rate of bike thefts within 400m of train or tube station london_ward_shp$btns_rate &lt;- (london_ward_shp$nr_station_bike_theft/london_ward_shp$total_bike_theft) * 100 6.4 Assignment Now we worked through all this, for this week’s assignment: Create a proper map of the rate of bike thefts within 400m of a train or tube station. Re-run the above analysis at four more distances: 100m, 200m, 300m, 500m and calculate the percentage of bike theft at these different distances. You can choose whether you would like to use the geometric operations or spatial queries approach. What do you think could explain the substantial differences in counts as we increase away from the train station from 100 to 200m? 6.5 Before you leave And that is how you can conduct basic geometric operations and spatial queries using R and sf. Of course: more RGIS in the coming weeks, but this concludes the tutorial for this week. "],["analysing-spatial-patterns-ii-spatial-autocorrelation.html", "7 Analysing Spatial Patterns II: Spatial Autocorrelation 7.1 Reading list 7.2 Childhood obesity 7.3 Statistical distributions 7.4 Assignment 1 7.5 Spatial distributions 7.6 Assignment 2 7.7 Want more? [Optional] 7.8 Before you leave", " 7 Analysing Spatial Patterns II: Spatial Autocorrelation This week, we will be looking at measuring spatial dependence. Spatial dependence is the idea that the observed value of a variable in one location is dependent (to some degree) on the observed value of the same value in a nearby location. For spatial analysis, this dependence can be assessed and measured statistically by considering the level of spatial autocorrelation between values of a specific variable, observed in either different locations or between pairs of variables observed at the same location. Spatial autocorrelation occurs when these values are not independent of one another and instead cluster together across geographic space. 7.1 Reading list Essential readings Griffith, D. 2017. Spatial Autocorrelation. The Geographic Information Science &amp; Technology Body of Knowledge. [Link] Gimond, M. 2021. Intro to GIS and spatial analysis. Chapter 13: Spatial autocorrelation. [Link] Livings, M. and Wu, A-M. 2020. Local Measures of Spatial Association. The Geographic Information Science &amp; Technology Body of Knowledge. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; systems, Chapter 13: Spatial Analysis. [Link] Suggested readings Brundson, C. and Comber, L. 2018. An Introduction to R for Spatial Analysis and Mapping. Chapter 7: Spatial Attribute Analysis with R. [Link] Lee, S. 2019. Uncertainty in the effects of the modifiable areal unit problem under different levels of spatial autocorrelation: a simulation study. International Journal of Geographical Information Science 33: 1135-1154. [Link] Harris, R. 2020. Exploring the neighbourhood-level correlates of Covid-19 deaths in London using a difference across spatial boundaries method. Health &amp; Place 66: 102446. [Link] 7.2 Childhood obesity This week, we are using a completely new dataset and investigating a different phenomena: childhood obesity. We will be investigating its distribution across London at the ward-level. To complete this analysis, we will be using a single data download from the London Datastore, which we will need to clean, wrangle and then join to one of our ward shapefiles in order to spatially investigate the distribution of childhood obesity. 7.2.1 Housekeeping Let’s get ourselves ready to start our practical content by first downloading the relevant data and loading this within our script. Open a new script within your GEOG0030 project and save this script as wk7-obesity-spatial-analysis.r. At the top of your script, add the following metadata (substitute accordingly): # Analysing childhood obesity and its factors Date: January 2023 Author: Justin Add the following libraries for loading in your script: # libraries library(tidyverse) library(sf) library(tmap) library(janitor) library(spdep) library(RColorBrewer) 7.2.2 Loading data We are going to only need two datasets for this week: our London ward boundaries from 2011 and the Greater London Authority (GLA) Ward Atlas and Profiles. The GLA Ward Atlas and Profiles provide a range of demographic and related data for each ward in Greater London and were specifically designed to provide an overview of the ward’s population by collating and presenting a range of data on the population, diversity, households, life expectancy, housing, crime, benefits, land use, deprivation, and employment. Indicators in the Atlas/Profile include: Age and sex Land area, projections and population density Household composition, religion, ethnicity Birth rates (general fertility rate), death rates (standardised mortality ratio), life expectancy Average house prices, properties sold, housing by council tax band, tenure, property size (bedrooms), dwelling build period and type, mortgage and landlord home repossession Employment and economic activity, Incapacity Benefit, Housing Benefit, Household income, Income Support and JobSeekers Allowance claimant rates, dependent children receiving child-tax credits by lone parents and out-of-work families, child poverty GCSE results, A-level / Level 3 results (average point scores), pupil absence Child obesity Crime rates (by type of crime), fires, ambulance call outs, road casualties Happiness and well-being, land use, public transport accessibility (PTALs), access to public greenspace, access to nature, air emissions / quality, car use, bicycle travel Indices of Deprivation Election turnout The main dataset utilises the 2011 Ward Boundaries as its spatial representation, therefore we need to use the 2011 boundaries. We already have our 2011 London Ward boundaries within our raw data folder, so we only need to download our Ward Atlas. Navigate to the ward Atlas dataset in the London Data Store: [Link]. Download the ward-atlas-data.csv. You might find that instead of downloading the file, your browser will open up a new window. You have two options: Copy and paste all contents of the page into a text editor such as Notepad and save your pasted contents as ward-atlas-data.csv in your raw data folder in a new atlas folder. Make sure to add the .csv to the end of your file name to save your text file as a csv. Click back to the dataset page, right-click on the ward-atlas-data.csv name and select Download Linked File from your computer’s options. Move this into your raw data folder in a new atlas folder. Figure 7.1: Download linked file. Let’s first load our London ward shapefile from our raw/boundaries/2011 folder: # read in our London ward boundaries london_ward_shp &lt;- read_sf(&quot;data/raw/boundaries/2011/London_Ward_CityMerged.shp&quot;) We can both View() and plot() the data in our console to check what our data looks like. We are happy with the dataframe (its field names) and what its looking like as a shapefile, so we do not need to do any cleaning on this dataset. We can now turn to our London Ward Atlas dataset and load the csv dataset into R: # read in our ward atlas data csv from our raw data folder all_ward_data &lt;- read_csv(&quot;data/raw/atlas/ward-atlas-data.csv&quot;) If you go ahead and view the data, you will see we have a lot of information about our Wards in the dataset. We have a total of 946 variables four our 629 wards. We cannot exactly analyse all of these variables, so we will need to extract only the variables we need. Note If you run into an error along the lines of Error in nchar(x, \"width\") : invalid multibyte string, element 1, there is an issue with the character encoding of the file. If this is the case, please download a UTF-8 encoded copy of the file here: [Link] 7.2.3 Data preparation To clean our data and extract the variables for our analysis, we need to identify those most useful to our research. Of course, we need to find a variable that matches our phenomena of investigation: child obesity. We will also keep several additional variables in case one would want to move beyond studying the distribution of child obesity, e.g. by looking at explanatory factors such as: Individual level factors: diet and exercise, parents’ weights, mode of travel to school / time taken to walk to school. Household/societal level factors: area deprivation, household income, household employment This week, our data wrangling is quite minimal but it is important you follow all the steps to ensure you have the correct final dataframe for our analysis. Overall, you will: Select the required columns for our dataframe and analysis. Remove the first row which contains data that are part of the column names. Remove the last three rows, which contains data for the whole of London, England, and England and Wales. Clean and rename our field columns. Coerce our variables into the correct data type for our analysis. Join our ‘atlas data’ dataframe to our ward spatial dataframe. The fields that we need to extract from our dataset include: 838: Childhood Obesity Prevalence; Year 6 (School children aged 10-11); 2011/12 to 2013/14: % obese 900: Indices of Deprivation; IDACI; 2010 248: House Prices; Median House Price; 2014 353: Household Income; Mean Modelled Household income (£); 2012/13 373: Employment; Adults not in Employment - 2011 Census; % of households with no adults in employment with dependent children 377: Qualifications; Qualifications and Students - 2011 Census; % No qualifications 859: Access to green space and nature; % homes with deficiency in access to nature; 2012 865: Public Transport Accessibility; Average PTAL score; 2014 and of course: 2: …2 - which contains our ward codes. 4: …4 - which contains our ward names. Select our 10 fields from our all_ward_data dataframe for use in analysis: # select our 10 fields for analysis using their index number obesity_ward_data &lt;- dplyr::select(all_ward_data, 2, 4, 838, 900, 248, 353, 373, 377, 859, 865) You should now have a new dataframe with our 10 variables. One issue with our original csv is that is contained two rows worth of field names - hence if you look at the first row of our dataframe, it does not make sense. We therefore want to remove this row as well as the last three rows. In addition, it would be good to clean up our names for use. Here we use the clean_names() function from the janitor library, which cleans our names by removing white space, special characters, capitals etc. Remove the first line of our dataframe and clean our field names: # remove our first row, remove last three rows, clean the names of our fields obesity_ward_data &lt;- obesity_ward_data %&gt;% slice(-1) %&gt;% head(-3) %&gt;% clean_names() # inspect names(obesity_ward_data) ## [1] &quot;x2&quot; ## [2] &quot;x4&quot; ## [3] &quot;childhood_obesity_prevalence_year_6_age_10_11_2011_12_to_2013_14_percent_obese&quot; ## [4] &quot;indices_of_deprivation_idaci_2010&quot; ## [5] &quot;house_prices_median_house_price_2014&quot; ## [6] &quot;household_income_mean_modelled_household_income_2012_13&quot; ## [7] &quot;employment_adults_not_in_employment_2011_census_percent_of_households_with_no_adults_in_employment_with_dependent_children&quot; ## [8] &quot;qualifications_qualifications_and_students_2011_census_percent_no_qualifications&quot; ## [9] &quot;access_to_green_space_and_nature_percent_homes_with_deficiency_in_access_to_nature_2012&quot; ## [10] &quot;public_transport_accessibility_average_ptal_score_2014&quot; The final thing we can do with this dataset before we need to join it to our London Wards spatial dataframe is just tidy up our column names: x2 and x4 does not exactly mean much to us and it gives us a chance to shorten the names of the other variables: # rename field names of ward data to something more useful names(obesity_ward_data) &lt;- c(&quot;ward_code&quot;, &quot;ward_name&quot;, &quot;y6_obesity_2014&quot;, &quot;IDACI_2010&quot;, &quot;med_house_price_2014&quot;, &quot;mean_hh_income_2013&quot;, &quot;per_no_adult_employ_2011&quot;, &quot;per_no_qual_2011&quot;, &quot;per_deficiency_greenspace_2012&quot;, &quot;PTAL_2014&quot;) Now we have the data we want to map, we need to do a final spot of checking: one of the main issues faced with loading data directly from a csv in R without cleaning it first in a spreadsheet programme as we have done before, is that we cannot guarantee that the data will be loaded correctly. Unfortunately with our current dataframe we can see that not all columns are correctly loaded. If you inspect the structure of the dataframe, you will see that several of our variables are of the type char. # inspect the structure of the data str(obesity_ward_data) ## tibble [625 × 10] (S3: tbl_df/tbl/data.frame) ## $ ward_code : chr [1:625] &quot;E09000001&quot; &quot;E05000026&quot; &quot;E05000027&quot; &quot;E05000028&quot; ... ## $ ward_name : chr [1:625] &quot;City of London&quot; &quot;Abbey&quot; &quot;Alibon&quot; &quot;Becontree&quot; ... ## $ y6_obesity_2014 : chr [1:625] &quot;23.21428571&quot; &quot;24.71655329&quot; &quot;25.99531616&quot; &quot;29.25851703&quot; ... ## $ IDACI_2010 : num [1:625] 0.12 0.439 0.397 0.38 0.435 ... ## $ med_house_price_2014 : num [1:625] 765000 173000 215000 210000 240500 ... ## $ mean_hh_income_2013 : chr [1:625] &quot;99390&quot; &quot;38870&quot; &quot;37290&quot; &quot;37860&quot; ... ## $ per_no_adult_employ_2011 : chr [1:625] &quot;0.86659065&quot; &quot;8.748906387&quot; &quot;12.44019139&quot; &quot;10.73182137&quot; ... ## $ per_no_qual_2011 : chr [1:625] &quot;6.7&quot; &quot;16.4&quot; &quot;31.2&quot; &quot;28&quot; ... ## $ per_deficiency_greenspace_2012: chr [1:625] &quot;100&quot; &quot;2.164412071&quot; &quot;71.7273622&quot; &quot;17.1662713&quot; ... ## $ PTAL_2014 : chr [1:625] &quot;7.9&quot; &quot;5.989364918&quot; &quot;3.145890095&quot; &quot;2.8717665&quot; ... The results from the str() function suggest that some variables have been interpreted by R to be characters rather than numeric. This might be because there is some missing data or in some cases, the decimal point can interfere with the data being read as a numeric. Luckily it is easy to change our data type - a bit like right-clicking on our columns in Excel and setting the format of the column to number, we will do this using code. If we wanted to apply this to a single column than we would use the code: as.numeric(dataframe$column) but as we want to apply this across a few columns, we will be using the mutate_at() function from the dplyr library. # change data types obesity_ward_data &lt;- mutate_at(obesity_ward_data, vars(y6_obesity_2014, mean_hh_income_2013, per_no_adult_employ_2011, per_no_qual_2011, per_deficiency_greenspace_2012, PTAL_2014), function(x) as.numeric(x)) ## Warning in (function (x) : NAs introduced by coercion You will see warnings that NAs have been introduced by this coercion in some of our variables. This is something we will need to be aware of later in our analysis, but will not look at right now. Now our final step is to join our final obesity_ward_data dataframe to our london_wards_shp spatial dataframe so we can complete both statistical and spatial analysis: # join obesity df to ward sdf for analysis obesity_ward_sdf &lt;- left_join(london_ward_shp, obesity_ward_data, by = c(&quot;GSS_CODE&quot; = &quot;ward_code&quot;) ) Have a look at your newly created spatial dataframe using the plot() function, for instance. If you like, you can also write out the final csv using the write_csv() function to save a raw copy in your data folder. 7.3 Statistical distributions Today, we are interested in looking at spatial autocorrelation: the effect of spatial processes on distributions. We will be using our newly created obesity_ward_sdf to look at this in action, whilst also answering questions on the overall distribution and factors of childhood obesity. Within general data analysis, when it comes to analysing the distribution of your data, you are looking to conduct what is known as Exploratory Data Analysis (EDA) which is where we look to summarise the main characteristics of our data. EDA was promoted by prominent statistician John Tukey to encourage data analysts to explore their data outside of traditional formal modelling and come up with new areas of investigation and hypotheses. Tukey promoted the use of five summary statistics: the max-min, the median, and the quartiles, which, in comparison to the mean and standard deviation, provide a more robust understanding of a data’s distribution, particularly if the data is skewed. We looked at how we can use R to extract some of these summary statistics briefly in Week 4, but let’s have a look at how we can add further to this EDA, including creating some statistical charts of our data’s distribution. In your script, below your joining of our dataframes, summarise our y6_obesity_2014 distribution # summarise our y6_obesity_2014 data summary(obesity_ward_sdf$y6_obesity_2014) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 5.929 18.569 22.670 21.752 25.325 35.000 12 This summary() function can also be called on the dataset as a whole and will generate summary statistics for each individual numeric variable. You can execute this in your console if you like to get an understanding of all of variables - although we will focus on obesity for much of this practical. We can see that our median and mean are quite close to one another. We can also see that the quartiles are nearly the same amount apart from the mean, so we can start to think that our data is normally distribution. To confirm this, we can do the next best thing, which is plot our distribution using a histogram, using the base R hist() command: # plot the histogram of our y6_obesity_2014 data hist(obesity_ward_sdf$y6_obesity_2014) We can actually see our data has a slight negative skew, which makes sense given that our median is higher than our mean. Figure 7.2: Cheatsheet on data distributions: negative skew, normal, positive skew. We can further customise our histograms if we want to make them more aesthetically pleasing and update the title and axis labeling: # pretty histogram hist(obesity_ward_sdf$y6_obesity_2014, breaks = 20, col = &quot;grey&quot;, main = &quot;Distribution of Obesity in Year 6 children, London Wards in 2014&quot;, xlab = &quot;Percentage of obese Year 6 children in the ward&quot;) We can also export this histogram and save it as a png by storing the histogram code to a variable and saving this variable to a file. The code to do so is a little different: we essentially first “open up” a file, called what we want to name our plot. We then run the code to plot our data, which will place the output “within” the file and then “close’ the file down. # open an empty png png(&quot;data/graphs/Y6_obesity_distribution.png&quot;) # pretty histogram hist(obesity_ward_sdf$y6_obesity_2014, breaks = 20, col = &quot;grey&quot;, main = &quot;Distribution of Obesity in Year 6 children, London Wards in 2014&quot;, xlab = &quot;Percentage of obese Year 6 children in the ward&quot;) # close the png dev.off() Another type of chart we can create just using the base R library is a boxplot. Figure 7.3: Simple boxplot. A boxplot shows the core characteristics of the distributions within a dataset, including the interquartile range. Plot the boxplot of our y6_obesity_2014 variable: # plot the boxplot of our y6_obesity_2014 data boxplot(obesity_ward_sdf$y6_obesity_2014) Tip There is actually a lot more we can do in terms of visualising our data’s distribution and the best way forward would be to become more familiar with the ggplot2 library. ggplot2 is the main visualisation for both statistical and, increasingly, spatial graphs, charts and maps. 7.4 Assignment 1 Your first assignment this week is to go ahead and test each of our variables to determine their distribution. Make a note of which ones are normally distributed and which are not (and their skew). Understanding your data’s distribution is important if you want to test the relationships between different variables. For example, if you want to conduct a linear regression analysis you have to ensure that your variables are normally distributed. 7.5 Spatial distributions Whilst statistical analysis of distributions focus on tests and charts, when we want to understand the spatial distribution of our phenomena, we have a very simple solution: we make a map. In our case, we are looking at areal unit data and therefore we can use a choropleth map to study our data across the wards: # store our variables of interest as a variable var_fields &lt;- names(obesity_ward_sdf)[10:17] # map all our variables of interest at once tm_shape(obesity_ward_sdf) + tm_polygons(&quot;gray&quot;, border.col = &quot;gray&quot;) + tm_shape(obesity_ward_sdf) + tm_polygons(col = var_fields) + tm_layout( legend.show = FALSE, panel.labels = c( &quot;Yr 6 Obesity&quot;, &quot;IDACI&quot;, &quot;Median House Price&quot;, &quot;Mean Household Income&quot;, &quot;Percent No Adult Employment&quot;, &quot;Percent No Qualifications&quot;, &quot;Percent Deficient in Greenspace&quot;, &quot;PTAL&quot; ) ) + tm_facets(ncol = 3) And specifically, we can create a single output choropleth map for each of our variables to visually understand their distribution: # child obesity map tm_shape(london_ward_shp) + tm_polygons(&quot;gray&quot;, border.col = &quot;gray&quot;) + tm_shape(obesity_ward_sdf) + tm_polygons( col = &quot;y6_obesity_2014&quot;, n = 5, style = &quot;jenks&quot;, title = &quot;Percentage of children &quot;, palette = &quot;Purples&quot;, border.col = &quot;white&quot; ) + tm_layout( main.title = &quot;Obesity of Year 6 children in London Wards in 2014&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, legend.title.size = 1, legend.title.fontface = 2 ) + tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) The thing with spatial distributions is that we can quickly pick up on spatial patterns present within our data just by looking at the data. For example, in our obesity example, we can see there are clusters of high levels of obesity in East London, whilst there are clusters of low levels of obesity in the south east and south west areas of London. Let’s analyse these clusters statistically by looking at spatial autocorrelation. Note Earlier we encountered that our dataset contains NAs in at least one of our columns. In fact, our yr6_obesity_2014 variable contains NAs. To move forward with our analysis, we need to remove those wards that do not contain any obesity information from our spatial dataframe. This will have some issues in terms of how we think about our “neighbours”, explained further below, but will allow us to run the code required. Remove the wards in our obesity_ward_sdf that do not contain any obesity information. # remove NAs obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% filter(!is.na(y6_obesity_2014)) We can assess the distribution of our data using what is known as spatial autocorrelation tests, which can be conducted on both a global (identify if the data is clustered) and local (identify the precise clusters) scales. Whilst these different tests quantify how clustered, how random, or how dispersed, these distributions are through various approaches, ultimately they provide us with statistical and spatial information that can be used to create quantifiable descriptions of a variable’s distribution and how it vary over space. This can be incredibly useful when looking to explain and discuss a variable, particularly as the clustering present in one variable can be compared to another, which might be useful to make connections between underlying causes or possible solutions to the issues the original variable poses. As discussed in this week’s lecture, we have several types of tests that look to quantify spatial autocorrelation. Of these tests, there are two categories: Global statistical tests (i.e. those that provide us with a statistic to tell us about autocorrelation in our dataset). Local spatial tests (i.e. those that provide us with the cluster maps). Three important tests are outlined in the below table for easy reference: Test Scale Test Output Significance Value Global Moran’s I Global Tests how “random” the spatial distribution of values are, producing a correlation coefficient for the relationship between a variable (like income) and its surrounding values. Moran’s I statistic: Metric between -1 and 1. -1 = dispersed 0 = CSR 1 = clustered Yes - \\(p\\)-value Local Moran’s I Local Tests the difference between a unit of analysis and its neighbour(s). Local Moran’s I statistic: 1. Can be used alongside the mean of values to generate cluster type generations. i.e. High-High, High-Low, Low-High, Low-Low, Insignificant. 2. Can also use standard deviation of main local statistic to show just high and low clusters Yes - \\(p\\)-value Local Getis-Ord Local Identifies statistically significant hot spots and cold spots using the local Getis-Ord Gi* statistic. Can use the standard deviation of statistic to identify hot and cold spots Yes - \\(p\\)-value In each of these cases, our \\(p\\)-values are pseudo \\(p\\)-values, generated through simulations such as that outlined in the lecture. Our pseudo \\(p\\)-values allow us to interpret our relationships with a level of confidence. If we find that our relationships do not have any significance, then we cannot be confident in presenting them as true results. 7.5.1 Spatial lag Underlying our global Moran’s I test is the concept of a spatial lag model. A spatial lag model plots each value against the mean of its neighbours’ values, defined by our selected approach. This creates a scatter plot, from which our Moran’s I statistic can be derived. An Ordinary Least Squares (OLS) regression is used to fit the data and produce a slope, which determines the Moran’s I statistic: Figure 7.4: A spatial lag model - plotting value against the mean of its neighbours. Source: Manuel Gimond. To determine a \\(p\\)-value from our model for global Moran’s I, this spatial lag model is computed multiple times (think hundreds, thousands) but uses a random distribution of neighbouring values to determine different slopes for multiple ways our data could be distributed, if our data was distributed by random. The output of this test is a sampling distribution of Moran’s I values that would confirm a null hypothesis that our values are randomly distributed. These slopes are then compared to compare our observed slope versus our random slopes and identify whether the slope is within the main distribution of these values or an outlier: Figure 7.5: A spatial lag model - plotting value against the mean of its neighbours. Source: Manuel Gimond. If our slope is an outlier, i.e. not a value we would expect to compute if the data were randomly distributed, we are more confidently able to confirm our slope is reflective of our data’s clustering and is significant. Our pseudo-\\(p\\)-values are then computed from our simulation results: \\(\\frac{N_{extreme} + 1}{N + 1}\\) Where \\({N_{extreme}}\\) is the number of simulated Moran’s I values that were more extreme that our observed statistic and \\({N}\\) is the total number of simulations. In the example above, from Manuel Gimond, only 1 out the 199 simulations was more extreme than the observed local Moran’s I statistic. Therefore \\({N_{extreme}}\\) = 1 , so \\(p\\) is equal to (1+1) / (199 + 1) = 0.01. This means that “there is a 1% probability that we would be wrong in rejecting the null hypothesis”. This approach is known as a Monte Carlo simulation or permutation bootstrap test. 7.5.2 Defining neighbours For any spatial autocorrelation test that you want to conduct, you will always need one critical piece of information: how do we define ‘neighbours’ in our dataset to enable the value comparison. Every observation in a dataset will need to have a set of neighbours to which its value is compared. To enable this, we need to determine how many or what type of neighbours should be taken into account for each observation when conducting a spatial autocorrelation test. These ‘neighbouring’ observations can be defined in a multitude of ways, based either on geometry or proximity, and include: Contiguity neighbours: Queen / Rook (plus order) Fixed Distance neighbours: Euclidean Distance (e.g. within 2km) (K) Nearest Neighbours: Certain n number of closest neighbours Figure 7.6: Different approaches of conceptualising neighbours for spatial autocorrelation measurement: contiguity, fixed distance and nearest neighbours. Source: Manuel Gimond. Depending on the variable you are measuring, the appropriateness of these different types of neighbourhood calculation techniques can change. As a result, how you define neighbours within your dataset will have an impact on the validity and accuracy of spatial analysis. Whatever approach you choose therefore needs to be grounded in particular theory that aims to represent the process and variable investigated. Note Have a look at Esri’s Help Documentation on Selecting a conceptualization of spatial relationships: Best practices when you come to need to define neighbours yourself for your own analysis. For our analysis into childhood obesity, we will primarily use the Queen contiguity. This approach is “effective when polygons are similar in size and distribution, and when spatial relationships are a function of polygon proximity (the idea that if two polygons share a boundary, spatial interaction between them increases)” (Esri, 2021). 7.5.3 Spatial weights matrix Before we can calculate Moran’s I and any similar statistics, we need to first define our spatial weights matrix. This is known mathematically as \\(W_{ij}\\) and this will tell our code which unit neighbours which, according to our neighbour definition. For each neighbour definition, there is a different approach to implementing code to calculate the \\(W_{ij}\\) spatial weights matrix. Here, we will look at three approaches: Creating a Queen \\(W_{ij}\\) spatial weights matrix Creating a Rook \\(W_{ij}\\) spatial weights matrix Creating a Fixed Distance \\(W_{ij}\\) spatial weights matrix For either approach, we use a single line of code to create the relevant \\(W_{ij}\\) spatial weights matrix: # create a neighbours list based on the Queen neighbour definition ward_neighbours_queen &lt;- obesity_ward_sdf %&gt;% poly2nb(., queen = T) # create a neighbours list based on the Rook neighbour definition ward_neighbours_rook &lt;- obesity_ward_sdf %&gt;% poly2nb(., queen = F) # creates centroid and joins neighbours within 0 and 3000 &#39;units&#39; of the CRS, # i.e. metres ward_neighbours_fd &lt;- dnearneigh(st_geometry(st_centroid(obesity_ward_sdf)), 0, 3000) ## Warning in st_centroid.sf(obesity_ward_sdf): st_centroid assumes attributes are ## constant over geometries of x Creating our neighbours list through a single line of code, as above, does not really tell us much about the differences between these conceptualisations. It would be useful to the links between neighbours for our three definitions and visualise their distribution across space. To be able to do this, we will use a few lines of code to generate a visualisation based on mapping the defined connections between the centroids of our wards. Note A centroid, in its most simplest form is the central point of an areal unit. How this central point is defined can be weighted by different approaches to understanding geometries or by using an additional variable. In our case, our centroids will reflect in the ‘central’ point of our wards, determined by its geometric boundaries. We can calculate the centroids of our wards using one of the geometric tools from the sf library: sf_centroid(): # calculate the centroids of all of the Wards in London ward_centroid &lt;- obesity_ward_sdf %&gt;% st_centroid() ## Warning in st_centroid.sf(.): st_centroid assumes attributes are constant over ## geometries of x You can plot() the ward_centroid using the console to see what they look like as spatial data. Now we have our ward centroids, we can go ahead and plot the centroids and the defined neighbour connections between them from each of our neighbour definitions. To do so, we will use the plot() function, provide the relationships via our ward_neighbours_X list and then the geometry associated with these lists from our ward_centroid(): # plot neighbours: Queen plot(ward_neighbours_queen, st_geometry(ward_centroid), col = &quot;red&quot;, pch = 20, cex = 0.5) # plot neighbours: Rook plot(ward_neighbours_rook, st_geometry(ward_centroid), col = &quot;blue&quot;, pch = 20, cex = 0.5) # plot neighbours: Fixed Distance plot(ward_neighbours_fd, st_geometry(ward_centroid), col = &quot;green&quot;, pch = 20, cex = 0.5) When comparing these different maps, we can see that there is definitely a difference in the number of neighbours when we use our different approaches. It seems our fixed distance neighbour conceptualisation has much connections in the center of London versus areas on the outskirts. We can see that our contiguity approaches provide a more equally distributed connection map, with our Queen conceptualisation having a few more links that our Rook. We can also type the different neighbours objects into the console to find out the total number of “non-zero links” (i.e. total number of connections) present within the conceptualisation. You should see that Queen has 3560 non-zero links, Rook has 3474 and Fixed Difference has 8238. Whilst this code simply explores these conceptualisations it helps us understand further how our different neighbourhood conceptualisations can ultimately impact our overall analysis. With our neighbours now defined, we will go ahead and create our final (two) spatial weights objects that will be needed for our spatial autocorrelation code. At the moment, we currently have our neighbours defined as a “list” but we need to convert it to a “neighbours” object using the nb2listw() function: # create a neighbours list ward_spatial_weights_queen &lt;- ward_neighbours_queen %&gt;% nb2listw(., style = &quot;C&quot;) # creates a neighbours list ward_spatial_weights_fd &lt;- ward_neighbours_fd %&gt;% nb2listw(., style = &quot;B&quot;) Note If you did not remove the NAs in our obesity column than the following code will not run. Make sure you have done this. If not, do it now and re-run your spatial weights matrix generation code again. 7.5.4 Global Moran’s I With a Global Moran’s I we test how “random” the spatial distribution of these values is, producing a global Moran’s statistic from the lag approach explained earlier. The global Moran’s I statistic is a metric between -1 and 1: -1 is a completely even spatial distribution of values 0 is a “random” distribution 1 is a “non-random” distribution of clearly defined clusters Before we run our global Moran’s I test, we will first create a spatial lag model plot which looks at each of the values plotted against their spatially lagged values. The graph will show quickly whether we are likely to expect our test to return a positive, zero or negative statistic: obesity_MI_sp &lt;- moran.plot(obesity_ward_sdf$y6_obesity_2014, listw = ward_spatial_weights_queen) We can see that there is a positive relationship between our y6_obesity_2014 variable and the spatially lagged y6_obesity_2014 variable, therefore we are expecting our global Moran’s I test to produce a statistic reflective of the slope visible in our scatter plot. Now we can run the global Moran’s I spatial autocorrelation test and print the result: # run the global Moran&#39;s I test on our y6_obesity_2014 data obesity_GMI &lt;- obesity_ward_sdf %&gt;% pull(y6_obesity_2014) %&gt;% as.vector() %&gt;% moran.test(., ward_spatial_weights_queen) # print global Moran&#39;s I result obesity_GMI ## ## Moran I test under randomisation ## ## data: . ## weights: ward_spatial_weights_queen ## ## Moran I statistic standard deviate = 22.69, p-value &lt; 2.2e-16 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.5333351039 -0.0016339869 0.0005558933 The Moran’s I statistic calculated should be 0.53. With 1 = clustered, 0 = no pattern, -1 = dispersed, this means we can confirm that childhood obesity in London is positively autocorrelated. In other words, childhood obesity does spatially cluster. We can also consider the pseudo \\(p\\)-value as a measure of the statistical significance of the model - at &lt; 2.2e-16, which confirm our result is (psuedo) significant. Note Before we run our local spatial autocorrelation tests, let’s just take a second to think through what our results have shown. From our global statistical tests, we can confirm that: There is clustering in our dataset. Similar values are clustering. High values are clustering. We can conclude already that areas of high levels of childhood obesity tend to cluster in the same area. What we do not know yet is where these clusters are occurring. To help with this, we need to run our local models to identify where these clusters are located. 7.5.5 Local Moran’s I A local Moran’s I test deconstructs the global Moran’s I down to its components and then constructs a localized measure of autocorrelation, which can show different cluster types. To run a local Moran’s I test, the code again is similar to above: # run the local Moran&#39;s I test on our y6_obesity_2014 data obesity_LMI &lt;- obesity_ward_sdf %&gt;% pull(y6_obesity_2014) %&gt;% as.vector() %&gt;% localmoran(., ward_spatial_weights_queen) # print the first 5 lines of the local Moran&#39;s I statistic output head(obesity_LMI) ## Ii E.Ii Var.Ii Z.Ii Pr(z != E(Ii)) ## 1 0.03833697 -8.703017e-05 0.009181660 0.4009978 6.884218e-01 ## 2 0.47282190 -1.379282e-03 0.144723426 1.2465027 2.125799e-01 ## 3 3.82565784 -1.107669e-02 1.147178083 3.5821711 3.407504e-04 ## 4 0.40863261 -9.066869e-05 0.009491210 4.1953536 2.724462e-05 ## 5 2.79741620 -7.224878e-03 0.749114397 3.2404343 1.193478e-03 ## 6 0.16952553 -1.234628e-05 0.001286115 4.7274492 2.273579e-06 As you should see, we do not get given a single statistic as per with our global tests, but rather a table of five different statistics that are all related back to each of the wards in our dataset. If we look at the help page for the localmoran function (run ?localmoran in your console) we can find out what each of these statistics mean: Name Description Ii Local Moran’s I statistic E.Ii Expectation of local Moran’s I statistic Var.Ii Variance of local Moran’s I statistic Z.Ii Standard deviation of local Moran’s I statistic Pr() \\(p\\)-value of local Moran’s I statistic We therefore have a local Moran’s I statistic for each of our wards, as well as a significance value plus a few other pieces of information that can help us create some maps showing our clusters. To be able to do this, we need to join our local Moran’s I output back into our obesity_ward_sdf spatial dataframe, which will then allow us to map these results. To create this join, we first coerce our local Moran’s I output into a dataframe that we then join to our obesity_ward_sdf spatial dataframe using the mutate() function from the dplyr library. In our case, we do not need to provide an attribute to join these two dataframes together as we use the computer’s logic to join the data in the order in which it was created: # coerce obesity_LMI into dataframe obesity_LMI &lt;- as.data.frame(obesity_LMI) # update the names for easier reference names(obesity_LMI) &lt;- c(&quot;LMI_Ii&quot;, &quot;LMI_eIi&quot;, &quot;LMI_varIi&quot;, &quot;LMI_zIi&quot;, &quot;LMI_sigP&quot;) # join to obesity_ward_sdf obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% mutate(obesity_LMI) We now have the data we need to plot our local spatial autocorrelation maps. We will first plot the most simple maps to do with our local Moran’s I test: the local Moran’s I statistic as well as the \\(p\\)-values of the local Moran’s I statistic. Map the local Moran’s I statistic: # map our local Moran&#39;s I statistic tm_shape(obesity_ward_sdf) + tm_polygons(&quot;LMI_Ii&quot;, style = &quot;pretty&quot;, midpoint = 0, title = &quot;Local Moran&#39;s I statistic&quot;) + tm_layout( main.title = &quot;Spatial Autocorrelation of Childhood Obesity in London&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, legend.title.size = 1, legend.title.fontface = 2 ) + tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) From the map, it is possible to observe the variations in autocorrelation across space. We can interpret that there seems to be a geographic pattern to the autocorrelation. However, it is not possible to understand if these are clusters of high or low values. To be able to interpret this confidently, we also need to know the significance of the patterns we see in our map and therefore need to map the \\(p\\)-value of local Moran’s I statistic. Map the \\(p\\)-value of local Moran’s I statistic: # significance breaks breaks &lt;- c(0, 0.05, 0.1, 1) # colours for our local Moran&#39;s I statistic colours &lt;- c(&quot;white&quot;, &quot;#a6bddb&quot;, &quot;#2b8cbe&quot;) # map our local Moran&#39;s I statistic tm_shape(obesity_ward_sdf) + tm_polygons(&quot;LMI_sigP&quot;, style = &quot;fixed&quot;, breaks = breaks, palette = rev(colours), title = &quot;p-value of Local Moran&#39;s I stat&quot; ) + tm_layout( main.title = &quot;Spatial Autocorrelation of Childhood Obesity in London&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, legend.title.size = 1, legend.title.fontface = 2 ) + tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) Using our significance map, we can interpret the above clusters present in our local Moran’s I statistic more confidently. As evident, we do have several clusters that are statistically significant to the \\(p\\)-value &lt; 0.05. Ideally we would combine these two outputs to see what values cluster together and which clusters are significant. We can do this with a cluster map of our local Moran’s I statistic (Ii) which will show areas of different types of clusters, including: HIGH-HIGH: A ward of high obesity that is also surrounded by other wards of high obesity. HIGH-LOW: A ward of high obesity that is surrounded by wards of low obesity. LOW-HIGH: A ward of low obesity that is surrounded by wards of high obesity. LOW-LOW: A ward of low obesity that is also surrounded by other wards of low obesity. Those areas that have no significant cluster or relationship to the wards around them. Our HIGH-HIGH and LOW-LOW will show our clusters, whereas the other two cluster types reveal anomalies in our variable. To create a map that shows this, we need to quantify the relationship each of our wards have with the wards around them to determine their cluster type. We do this using their observed value and their local Moran’s I statistic and their deviation around their respective means: If a ward’s observed value is higher than the observed mean and it’s local Moran’s I statistic is higher than the LMI mean, it is designated as HIGH-HIGH. If a ward’s observed value is lower than the observed mean and it’s local Moran’s I statistic is lower than the LMI mean, it is designated as LOW-LOW. If a ward’s observed value is lower than the observed mean but it’s local Moran’s I statistic is higher than the LMI mean, it is designated as LOW-HIGH. If a ward’s observed value is higher than the observed mean but it’s local Moran’s I statistic is lower than the LMI mean, it is designated as HIGH-LOW. If a ward’s LMI was found not to be significant, the ward will be mapped as not significant. For example, this means that if we know our ward’s observed value is less than the mean value of our overall y6_obesity_2014 variable, then it means it is of course a low value for obesity in comparison to the entirety of London. If it’s local Moran’s I statistic is also lower than the mean value of the rest of the LMI_Ii statistics, it also means it is located in a neighbourhood of low values. As a result, if this relationship is significant (determined by the pseudo \\(p\\)-value from our local Moran’s I calculation), we can call this a “LOW-LOW” cluster. To achieve this cluster map, we need to take several additional steps: The first will tell us, for each ward, whether its observed value is higher or lower than the mean observed. The second will tell us, for each ward, whether its LMI value is higher or lower than the mean LMI. The third will use the values of these two columns to assign each ward with a cluster type. Determine the cluster type of each ward by comparing observed and LMI values against their respective means and the significance value: # compare local value for obesity with mean value obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% mutate(obs_diff = (y6_obesity_2014 - mean(obesity_ward_sdf$y6_obesity_2014))) # compare local LMI value with mean LMI value obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% mutate(LMI_diff = (obesity_LMI$LMI_Ii - mean(obesity_LMI$LMI_Ii))) # set a significance threshold signif &lt;- 0.05 # generate column with cluster type, using values above obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% mutate(cluster_type = case_when( obs_diff &gt; 0 &amp; LMI_diff &gt; 0 &amp; LMI_sigP &lt; signif ~ &quot;High-High&quot;, obs_diff &lt; 0 &amp; LMI_diff &lt; 0 &amp; LMI_sigP &lt; signif ~ &quot;Low-Low&quot;, obs_diff &lt; 0 &amp; LMI_diff &gt; 0 &amp; LMI_sigP &lt; signif ~ &quot;Low-High&quot;, obs_diff &gt; 0 &amp; LMI_diff &lt; 0 &amp; LMI_sigP &lt; signif ~ &quot;High-Low&quot;, LMI_sigP &gt; signif ~ &quot;No Significance&quot; )) Now we have a column detailing our cluster types, we can create a cluster map that details our four cluster types as well as those that are not significant. Creating a categorical map in R and using tmap is a little tricky and we will need to do some preparing of our colour palettes to ensure our data is mapped correctly. To do this, we first need to figure out how many cluster types we have in our cluster_type field: # count the different values within our `cluster_type` variable count(obesity_ward_sdf, cluster_type) ## Simple feature collection with 5 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## Projected CRS: OSGB36 / British National Grid ## # A tibble: 5 × 3 ## cluster_type n geometry ## * &lt;chr&gt; &lt;int&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 High-High 53 (((532073.1 176529.5, 532050.9 176496.2, 532041.3 17647… ## 2 High-Low 22 (((523772 167981.8, 523713.5 168026.7, 523667.2 168063.… ## 3 Low-High 70 (((519142.5 166507.1, 519154.9 166492.8, 519159.6 16648… ## 4 Low-Low 19 (((524633.2 165084, 524628 165092.6, 524610.7 165084, 5… ## 5 No Significance 449 (((516493.8 160310.2, 516500.9 160324.2, 516507.3 16034… We can see we actually have all four cluster types present within our dataset - alongside the No Significance value. We therefore need to ensure our palette includes four colours for these two cluster types, plus a white colour for No Significance: # create a colour palette pal &lt;- c(&quot;#d7191c&quot;, &quot;#fdae61&quot;, &quot;#abd9e9&quot;, &quot;#2c7bb6&quot;, &quot;#F5F5F5&quot;) # plot the clusters tm_shape(obesity_ward_sdf) + tm_polygons(col = &quot;cluster_type&quot;, palette = pal, title = &quot;Cluster Type&quot;) + tm_layout( main.title = &quot;Cluster Map of Childhood Obesity in London, 2014&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, legend.title.size = 1, legend.title.fontface = 2 ) + tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) And there we have it: within one map we can visualise both the relationship of our wards to their respective neighbourhoods and the significance of this relationship from our local Moran’s I test. This type of map is called a LISA map and is a great way of showing how a variable is actually clustering. 7.5.6 Getis-Ord-Gi* The final test we will run today is the local Getis-Ord, which will produce the Gi* statistic. This statistic will identify hot- and coldspots by looking at the neighbours within a defined proximity to identify where either high or low values cluster spatially and recognising statistically significant hotspots as those areas of high values where other areas within a neighbourhood range also share high values too (and vice versa for coldspots). Run the local Gi* statistic spatial autocorrelation test and print the result: # run the local Gi* test on our y6_obesity_2014 data, note we again use the fd # weights obesity_LGO &lt;- obesity_ward_sdf %&gt;% pull(y6_obesity_2014) %&gt;% as.vector() %&gt;% localG(., ward_spatial_weights_fd) # join the local Gi* statistic to `obesity_ward_sdf` spatial dataframe obesity_ward_sdf &lt;- obesity_ward_sdf %&gt;% mutate(obesity_LGO_G = as.numeric(obesity_LGO)) # inspect obesity_ward_sdf ## Simple feature collection with 613 features and 25 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## Projected CRS: OSGB36 / British National Grid ## # A tibble: 613 × 26 ## NAME GSS_CODE HECTARES NONLD…¹ LB_GS…² BOROUGH POLY_ID ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Chessington South E05000405 755. 0 E09000… Kingst… 50840 ## 2 Tolworth and Hook Rise E05000414 259. 0 E09000… Kingst… 117160 ## 3 Berrylands E05000401 145. 0 E09000… Kingst… 50449 ## 4 Alexandra E05000400 269. 0 E09000… Kingst… 50456 ## 5 Beverley E05000402 188. 0 E09000… Kingst… 117161 ## 6 Coombe Hill E05000406 442. 0 E09000… Kingst… 117159 ## 7 Chessington North and Hook E05000404 193. 0 E09000… Kingst… 50530 ## 8 Surbiton Hill E05000413 166. 0 E09000… Kingst… 50457 ## 9 Old Malden E05000410 180. 0 E09000… Kingst… 50455 ## 10 St. Mark&#39;s E05000412 138. 0 E09000… Kingst… 50450 ## # … with 603 more rows, 19 more variables: geometry &lt;POLYGON [m]&gt;, ## # ward_name &lt;chr&gt;, y6_obesity_2014 &lt;dbl&gt;, IDACI_2010 &lt;dbl&gt;, ## # med_house_price_2014 &lt;dbl&gt;, mean_hh_income_2013 &lt;dbl&gt;, ## # per_no_adult_employ_2011 &lt;dbl&gt;, per_no_qual_2011 &lt;dbl&gt;, ## # per_deficiency_greenspace_2012 &lt;dbl&gt;, PTAL_2014 &lt;dbl&gt;, LMI_Ii &lt;dbl&gt;, ## # LMI_eIi &lt;dbl&gt;, LMI_varIi &lt;dbl&gt;, LMI_zIi &lt;dbl&gt;, LMI_sigP &lt;dbl&gt;, ## # obs_diff &lt;dbl&gt;, LMI_diff &lt;dbl&gt;, cluster_type &lt;chr&gt;, obesity_LGO_G &lt;dbl&gt;, … By printing the results of our test, we can see that the local Getis-Ord test is a bit different from a local Moran’s I test as it only contains a single value: the z-score. The z-score is a standardised value relating to whether high values or low values are clustering together, which we call the Gi* statistic. We can join this output, a list of our Gi* values, to our obesity_ward_sdf spatial dataframe and map the result: # create a colour palette GIColours &lt;- rev(brewer.pal(8, &quot;RdBu&quot;)) # plot the clusters tm_shape(obesity_ward_sdf) + tm_polygons(&quot;obesity_LGO_G&quot;, style = &quot;pretty&quot;, palette = GIColours, midpoint = 0, title = &quot;Local Gi* statistic&quot; ) + tm_layout( main.title = &quot;Hot/Cold Spot Map of Childhood Obesity in London, 2014&quot;, main.title.fontface = 2, fontfamily = &quot;Helvetica&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, legend.title.size = 1, legend.title.fontface = 2 ) + tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) Our map shows quite clearly hot and cold spots of obesity across London. How does this compare with our local Moran’s I? Do we see the same clusters? Tip If we want to only map the statistically significant clusters, we need to use these z-scores to filter out only statistically significant clusters. When using a 95 percent confidence level your values should be between -1.96 and +1.96 standard deviations. 7.6 Assignment 2 Through conducting our spatial autocorrelation tests, we can visually confirm the presence of clusters in our y6_obesity_2014 variable and provide a significance value associated with these tests. This provides us with a way to explain our distributions quantitatively during the analysis of our results. Now you have the code, you will be able to repeat this analysis on any variable in the future. For this week’s assignment, we therefore want you to find out whether our IDACI_2010 variable contains spatial clustering. In order to do this, you have to: Create a choropleth map showing the distribution of the variable values. Calculate a global spatial autocorrelation statistic and explain what it shows. Create a local Moran’s I map showing the four cluster types. Create a local Getis-Ord hotspot map. Compare these results to the output of our y6_obesity_2014 values. Do both variables have clusters? Do we see similar clusters in similar locations? What might this tell us about the relationship between deprivation and obesity in children in London? Run the analysis using a different neighbour definition. What happens? Do the results change? 7.7 Want more? [Optional] 7.7.1 More spatial autocorrelation If you are interested in moving beyond spatial autocorrelation, for instance how to account for spatial autocorrelation in statistical models (e.g. with Geographically Weighted Regression or Spatial Regression), have a look at the workbook Mapping and Modelling Geographic Data in R by Bristol-based Professor Richard Harris. Start with The Spatial Variable section, move to the Measuring spatial autocorrelation section before looking at the Geographically Weighted Statistics and Spatial Regression sections. 7.8 Before you leave And that is how you can measure spatial dependence in your dataset through different spatial autocorrelation measures. Next week we will focus on the last topic within our set of core spatial analysis methods and techniques, but this week we have covered enough! "],["analysing-spatial-patterns-iii-point-pattern-analysis.html", "8 Analysing Spatial Patterns III: Point Pattern Analysis 8.1 Reading list 8.2 Bike theft in London 8.3 Point pattern analysis 8.4 Density-based techniques 8.5 Assignment 8.6 Distance-Based Methods 8.7 Want more? [Optional] 8.8 Before you leave", " 8 Analysing Spatial Patterns III: Point Pattern Analysis This week, we will be looking at how we can use Point Pattern Analysis (PPA) to detect and delineate clusters within point data. Within point pattern analysis, we look to detect clusters or patterns across a set of points, including measuring density, dispersion and homogeneity in our point structures. There are several approaches to calculating and detecting these clusters, which are explained in our main lecture. We then deploy several PPA techniques, including Kernel Density Estimation, on our bike theft data to continue our investigation from the week before last. 8.1 Reading list Essential readings Cheshire, J. and Longley, P. 2011. Identifying spatial concentrations of surnames. International Journal of Geographical Information Science 26(2), pp.309-325. [Link] Longley, P. et al. 2015. Geographic Information Science &amp; systems, Chapter 12: Geovisualization. [Link] Yin, P. 2020. Kernels and density estimation. The Geographic Information Science &amp; Technology Body of Knowledge. [Link] Yuan, Y. et al. 2020. Point Pattern Analysis. The Geographic Information Science &amp; Technology Body of Knowledge. [Link] Suggested readings Arribas-Bel, D., Garcia-López, M.-À., Viladecans-Marsal, E. 2021. Building(s and) cities: Delineating urban areas with a machine learning algorithm. Journal of Urban Economics 125: 103217. [Link] Van Dijk, J. and Longley, P. 2020. Interactive display of surnames distributions in historic and contemporary Great Britain. Journal of Maps 16, pp.58-76. [Link] Shi, X. 2010. Selection of bandwidth type and adjustment side in kernel density estimation over inhomogeneous backgrounds. International Journal of Geographical Information Science 24(5), pp.643-660. [Link] 8.2 Bike theft in London This week, we again investigate bike theft in London in 2019 as we look to confirm our very simple hypothesis: that bike theft primarily occurs near tube and train stations. This week, instead of looking at the distance of individual bike thefts from train stations, we will look to analyse the distribution of clusters in relation to the stations. We will first look at this visually and then look to compare these clusters to the location of train and tube stations quantitatively using geometric operations. To complete this analysis, we will again use the following datasets: Bike theft in London for 2019 from data.police.uk Train and Tube Stations from Transport for London 8.2.1 Housekeeping Let’s get ourselves ready to start our lecture and practical content by first downloading the relevant data and loading this within our script. Open a new script within your GEOG0030 project and save this script as wk8-bike-theft-PPA.r. At the top of your script, add the following metadata (substitute accordingly): # Analysing bike theft and its relation to stations using point pattern analysis # Data: January 2023 # Author: Justin All of the geometric operations and spatial queries we will use are contained within the sf library. For our Point Pattern Analysis, we will be using the spatstat library (“spatial statistics”). The spatstat library contains the different Point Pattern Analysis techniques we will want to use in this practical. We will also need the raster library, which provides classes and functions to manipulate geographic (spatial) data in raster format. We will use this package briefly today, but look into it in more detail next week. Lastly, you will also need to load the dbscan package. # libraries library(tidyverse) library(sf) library(tmap) library(janitor) library(spatstat) library(raster) library(dbscan) 8.2.2 Loading data This week, we will continue to use our data from Week 06. This includes: London ward boundaries for 2018 Crime in London for 2019 from data.police.uk Train and Tube Stations from Transport for London You should load these datasets as new variables in this week’s script. You should have the original data files for both the London wards and 2019 crime already in your raw data folder. Note If you did not export your OpenStreetMap train and tube stations from our practical in Week 06, you will need to re-run parts of your code to download and then export the OpenStreetMap data. If this is the case, open your wk6-bike-theft-analysis.r and make sure you create a shapefile of the train and tube stations. Let’s go ahead and load all of our data at once. # read in our 2018 London ward boundaries london_ward_shp &lt;- read_sf(&quot;data/raw/boundaries/2018/London_Ward.shp&quot;) # read in our OSM tube and train stations data london_stations &lt;- read_sf(&quot;data/raw/transport/osm_stations.shp&quot;) # read in our crime data csv from our raw data folder bike_theft_2019 &lt;- read_csv(&quot;data/raw/crime/crime_all_2019_london.csv&quot;) %&gt;% # clean names with janitor clean_names() %&gt;% # filter according to crime type and ensure we have no NAs in our dataset filter(crime_type == &quot;Bicycle theft&quot; &amp; !is.na(longitude) &amp; !is.na(latitude)) %&gt;% # select just the longitude and latitude columns dplyr::select(longitude, latitude) %&gt;% # transform into a point spatial dataframe note providing the columns as # the coordinates to use plus the CRS, which as our columns are long/lat is # WGS84/4236 st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4236) %&gt;% # convert into BNG st_transform(27700) %&gt;% # clip to London st_intersection(london_ward_shp) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries Let’s create a quick map of our data to check it loaded correctly: # plot our London wards first tm_shape(london_ward_shp) + tm_fill() + # then add bike crime as blue tm_shape(bike_theft_2019) + tm_dots(col = &quot;blue&quot;) + # then add our stations as red tm_shape(london_stations) + tm_dots(col = &quot;red&quot;) + # then add a north arrow tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + # then add a scale bar tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) Great - that looks familiar! This means we can move forward with our data analysis and theoretical content for this week. 8.3 Point pattern analysis Point pattern analysis (PPA) studies the spatial distribution of points. PPA uses the density, dispersion and homogeneity in our point datasets to assess, quantify and characterise its distribution. Over the last fifty years, various methods and measurements have been developed to analyze, model, visualise, and interpret these properties of point patterns (Qiang et al, 2020). There are three main categories of PPA techniques: Descriptive statistics: The use of descriptive statistics will provide a summary of the basic characteristics of a point pattern, such as its central tendency and dispersion. Descriptive statistics provide a simple way of visualising a dataset as a whole, from plotting the median or mean centre, or, often preferably, a standard deviational ellipse for those datasets that display a directional pattern. Density-based methods: Density-based methods focus on the first-order properties of a dataset, i.e. the variation in the individual locations of the points in the dataset across the area of interest, and will characterise our dataset’s distribution accordingly in terms of density. Distanced-based methods: Distanced-based methods focus on the second-order properties of a dataset, i.e. the interactions between points within our data and whether they appear to have influence on one another and form clusters, and will characterise our dataset’s distribution accordingly in terms of dispersion. The main library to use when it comes to point pattern analysis in R is the spatstat library, developed by Baddeley, Rubak and Turner since 2005. As their documentation states, spatstat “is a package for the statistical analysis of spatial data. Its main focus is the analysis of spatial patterns of points in two-dimensional space”. According to the Get Started with spatstat documentation spatstat supports a very wide range of popular techniques for statistical analysis for spatial point patterns, including: Kernel estimation of density/intensity Quadrat counting and clustering indices Detection of clustering using Ripley’s K-function Model-fitting Monte Carlo tests as well as some advanced statistical techniques (Baddeley et al, 2020). We will only cover a brief amount of the functionality the package offers - it has almost 1,800 pages of documentation and over 1,000 functions, so it would be near impossible to cover everything even if we had a full module dedicated just to PPA. Instead, we will focus on some key PPA techniques: Quadrat Analysis Kernel Density Estimation Nearest Neighbour Ripley’s K function But before we get started with our analysis, you need to know one critical piece of information in order to use spatstat: we need our data to be in the format of a ppp object. There are some spatial packages in R that require us to convert our data from an sf simple features object (e.g. for point data, a SpatialPoints object) into a different spatial object class. spatstat is one of them. Tip The ppp format is specific to spatstat, but you may find it used in other spatial libraries. An object of the class ppp represents a two-dimensional point dataset within a pre-defined area, known as the window of observation, a class in its own right, known as owin in spatstat. We can either directly create a ppp object from a list of coordinates (as long as they are supplied with a window) or convert from another data type (using the as.ppp() function). However, as spatstat predates sf, this conversion function does not yet work with sf data objects. Instead, therefore, we have to create a workaround workflow that enables us to extract the coordinates from our bike_theft_2019 spatial dataframe for use within the ppp function. To turn our bike_theft_2019 spatial dataframe into a ppp object, we need to extract the geometry of our bike theft points, store this geometry as two separate columns within a matrix, and provide these columns, alongside an observation window equal to our london_ward_shp spatial dataframe, to create a ppp object: # create a window of observation window &lt;- as.owin(london_ward_shp$geometry) # extract coordinates from our bike theft dataset as a matrix bike_theft_xy &lt;- bike_theft_2019 %&gt;% st_coordinates() # create a ppp object bike_theft_ppp &lt;- ppp(x = bike_theft_xy[, 1], y = bike_theft_xy[, 2], window = window) ## Warning: data contain duplicated points # plot our ppp object plot(bike_theft_ppp) Our plot shows us our bike_theft_ppp object, which includes both the coordinate points of our bike theft data and our London window. You should also see your bike_theft_ppp object variable appear in your Environment window. You should also see a message stating that our data contains duplicated points. Let’s see whether this is true. We can first use a logical statement from the R base library to check if our bike_theft_ppp object contains duplicated points and then count the total number of duplicates exist using the multiplicity() function from the spatstat library. # check for duplicates using anyDuplicated(bike_theft_ppp) ## [1] TRUE # count the sum of the number of duplicated points sum(multiplicity(bike_theft_ppp) &gt; 1) ## [1] 12352 One of the key assumptions underlying many analytical methods is that all events are unique. In fact, some statistical procedures actually may return very wrong results if duplicate points are found within the data. In terms of our bike theft data, it is unsurprising that it contains duplicates. The Police service use snapping points, to which crimes are snapped to in order to preserve the anonymity and privacy of those involved. This is an issue in spatial point pattern analysis as we need our events, i.e. each record of a crime and its respective location, to be unique in order for our analysis to be accurate. To account for these issues within our dataset (and other datasets that contain duplicates), we have three options: We can remove the duplicates and pretend they simply are not there. However, this is feasible only when your research problem allows for this, i.e. the number of points at each location is not as important as the locations themselves, and therefore you are happy to ‘ignore’ some of the data. Create and assign a weighting schema to our points, where each point will have an attribute that details the number of events that occur in that location and utilise this weight within our PPA techniques. Weights however can only be used with certain PPA techniques (e.g. Kernel Density Estimation). Force all points to be unique by utilising a function that offsets our points randomly from their current location. If the precise location is not important for your analysis or, for example, you are dealing with data that in our case is already slightly offset, we can introduce a “jitter” to our dataset that slightly adjusts all coordinates so that the event locations do not exactly coincide anymore. This way, our duplicates will no longer have the same precise location. This approach however introduces a certain level of uncertainty into the precise location of any analysis derived from our datasets. Each approach will have a specific compromise, which you will have to decide upon depending on the type of analysis you are completing. In our case, we will choose the jitter approach to keep all of our bike theft events. We know that already the location of our bike thefts are not precise locations of the original theft, therefore adding additional offset will not detract from our analysis. Let’s shift all our coordinates slightly to ‘remove’ our duplicates and essentially ‘move’ all points into unique locations. We will use the rjitter function from the spatstat library, which applies an independent random displacement to each point in a point pattern: # add an offset to our points using the rjitter function bike_theft_ppp_jitter &lt;- rjitter(bike_theft_ppp, retry = TRUE, nsim = 1, drop = TRUE) # count the number of duplicated points of the new jitter dataset anyDuplicated(bike_theft_ppp_jitter) ## [1] FALSE # plot the resulting ppp object plot(bike_theft_ppp_jitter) Great, we now have our bike theft data in a format ready to be analysed with our different PPA techniques using the spatstat library! Tip One additional thing to note about the ppp data object is that a ppp object does not necessarily have to have any attributes (our fields) associated with the events each point our point data represents. If your data does have attributes (such as calculating a weight as outlined above for dealing with duplications), these attributes are referred to as marks within the spatstat environment. Be aware that some functions do require these marks to be present - and you will find this out only from the spatstat documentation. We will not use any functions/techniques today that require marks. 8.4 Density-based techniques Density-based techniques are used to characterise the pattern of a point dataset utilising its general distribution. A bit like our spatial autocorrelation techniques, we can calculate densities at both the global and local scale. However, as you will see, for PPA, global density really does not tell us much more about the distribution of our data - in terms of areas of high and low densities, for example. This is where local density techniques such as Quadrat Analysis and Kernel Density Estimation can help us visualise these differences in density in our data’s distribution. 8.4.1 Quadrat analysis We can create a simple understanding of our data’s distribution by first understanding its global density. This is simply the ratio of the observed number of points, \\(n\\) , to the study region’s surface area, \\(a\\): \\(\\widehat{\\lambda} =\\frac{n}{a}\\) Calculate the global density of our bike theft point data relative to London: # calculate the global density of our bike points global_density &lt;- length(bike_theft_2019$NAME)/sum(st_area(london_ward_shp)) # inspect global_density ## 1.174831e-05 [1/m^2] We can see that we have a global density of 0.00001174 bike thefts per m^2 in London. This simple density analysis could be supported with further descriptive statistics, however, we still would know little about the local density of our points. The most basic approach to understanding a point pattern’s local density is to simply measure the density at different locations within the study area. This approach helps us assess if the density is constant across the study area. The most simplest approach to this measurement is through Quadrat Analysis, where the study area is divided into sub-regions, aka quadrats. The point density is then computed for each quadrat, by dividing the number of points in each quadrat by the quadrat’s area. Quadrats can take on many different shapes (and uilise different approaches to creating these shapes). The most basic approach is using squares (or rather, a grid). Furthermore, the choice of quadrat numbers and quadrat shape can influence the measure of local density and therefore must be chosen with care. We will start with a simple quadrat count by dividing the observation window into 15 x 15 sections and then counting the number of bicycle thefts within each quadrant using the quadratcount() function within R. # quadratcount in a 15 x 15 grid across the observational window biketheft_quadrat &lt;- quadratcount(bike_theft_ppp_jitter, nx = 10, ny = 10) # inspect plot(biketheft_quadrat) Our resulting quadrat count shows total counts of bike theft. We can see quite quickly that the quadrats in central London are likely to have a higher local density as their count is much higher than those on the outskirts of London. If we divided our count by the area covered by each quadrat, we would also be able to calculate a precise local density. We will not do this for now, as realistically, it is not often that you would want to use quadrat analysis for actual PPA. The reason why we look at this technique is that it provides us with an easy way to think about how to compare our data distribution and how this relates to the Poisson distribution of Complete Spatial Randomness (CSR). Note When looking at the distribution of our points and the respective patterns they show, the key question we often want to answer as geographers and spatially-enabled thinkers is: are our points clustered, randomly distributed (i.e. display complete spatial randomness), uniform or dispersed? Whilst we can visually assess this distribution, to be able to statistically quantify our data’s distribution, we can compare its distribution to that of the Poisson distribution. The Poisson distribution describes the probability or rate of an event happening over a fixed interval of time or space. The Poisson Distribution applies when: The events are discrete and can be counted in integers Events are independent of each other The average number of events over space or time is known Point data that contains a random distribution of points is said to follow a Poisson distribution. The Poisson distribution is very useful as it allows us to compare a random expected model to our observations. Essentially, if our data does not fit the Poisson model, then we can infer that something interesting might be going on and our events might not actually be independent of each other. Instead, they might be clustered or dispersed and there is likely to be underlying processes influencing these patterns. The most basic test of CSR with the Poisson distribution in PPA can be completed with the results of our Quadrat Analysis. We compare our quadrat results with a Poisson distribution for the same quadrats and determine whether the pattern is generated in a random manner; i.e. whether the distribution of points in our study area differs from complete spatial randomness (CSR) or whether there are some clusters present. To enable this, we can run a chi-squared test of our data against a theoretical randomly generated point pattern dataset with the same number of points and window, with the null hypotheses that our point data have been generated under complete spatial randomness. Our chi-squared test will tell us whether our data is distributed under the null hypothesis and determine whether there is a statistically significant difference between the expected distribution (i.e. CSR) and the observed distribution (our bike theft point data): # chi-square between observed point pattern of our data and Poisson sampled # points quadrat.test(bike_theft_ppp_jitter, nx = 10, ny = 10) ## Warning: Some expected counts are small; chi^2 approximation may be inaccurate ## ## Chi-squared test of CSR using quadrat counts ## ## data: bike_theft_ppp_jitter ## X2 = 55249, df = 80, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided ## ## Quadrats: 81 tiles (irregular windows) Our \\(p\\) value is well below 0.01, which means there is a statistically significant difference between the expected distribution (i.e. CSR) and the observed distribution (our bike theft point data). We can therefore reject the null hypothesis that our point data have been generated under complete spatial randomness and confirm that our point pattern was not generated in a random matter. However, our completing both a quadrat analysis and the resulting chi-squared test is not exactly the most efficient way of looking to understand the relative local densities of our dataset - nor can we compare these results to the location of our train and tube stations to look into our original hypothesis that bike theft primarily occurs near tube and train stations. 8.4.2 Kernel Density Estimation We now have an understanding of whether our data is randomly distributed or not - and our quadrats give us a very coarse understanding of where there may be clusters within our data. But instead of looking at the distribution of our bike theft with the boundaries of our quadrats, we can also analyse our points using a Kernel Density Estimation (KDE). KDE is a statistical technique to generate a smooth continuous distribution between data points that represent the density of the underlying pattern. Note A KDE will produce a raster surface that details the estimated distribution of our event point data over space. Each cell within our raster contains a value that is this estimated density at that location; when visualised in its entirety as the whole raster, we can quickly identify areas of high and low density, i.e. where are clusters are located in our dataset. To create this surface, a KDE computes a localised density for small subsets of our study area but unlike quadrat analysis, these subsets overlap one another to create a moving sub-region window, defined by a kernel. A kernel defines the shape and size of the window and can also weight the points, using a defined kernel function. The simplest kernel function is a basic kernel where each point in the kernel window is assigned equal weight. The kernel density approach generates a grid of density values whose cell size is smaller than that of the kernel window. Each cell is assigned the density value computed for the kernel window centered on that cell. The resulting surface is created from these individually, locally calculated density values. Producing a KDE in R is very straight-forward in spatstat, using your ppp object and the density.ppp() function. However, you will need to consider both the bandwidth or diameter of your Kernel (sigma) and whether you want to apply a weighting to your points using a function. First, let’s go ahead and create a simple KDE of bike theft with our bandwidth set to 100m: # kernel density estimation of our bike theft ppp object plot(density.ppp(bike_theft_ppp_jitter, sigma = 100)) We can see from just our KDE that there are visible clusters present within our bike theft data, particularly in and around central London. We can even see our south-west cluster that we saw in our proportional symbols map last week. We can go ahead and vary our bandwidth to to see how that affects the density estimate: # kernel density estimation of our bike theft ppp object with 500m bandwith plot(density.ppp(bike_theft_ppp_jitter, sigma = 500)) Our clusters now appear brighter and larger than our KDE with a 100m bandwidth. This is because changing the bandwidth enables your KDE to take into account more points within its calculation, resulting in a smoother surface. However, there are issues with oversmoothing your data - as you can see above, our clusters are not as well defined and therefore we may attribute high levels of bike theft to areas where there actually is not that much. Smaller bandwidths will lead to a more irregular shaped surface, where we have more precision in our defined clusters but, once again, there are issues of undersmoothing. In our case, as we know bike theft is not exactly a phenomena that obeys strict square boundaries, we may run into similar issues of boundary effects that we see in areal unit aggregation, and end up not extending our clusters far enough to cover our “hotspot” areas. Whilst there are automated functions (e.g. based on maximum-likelihood estimations) that can help you with selecting an appropriate bandwidth, in the end you will have to make a decision on what is most appropriate for your dataset. Thinking through the phenomenon that you are analysing will help. Although bandwidth typically has a more pronounced effect upon the density estimation than the type of kernel used, kernel types can affect the result too. When we use a different kernel type, we are looking to weight the points within our kernel differently: Figure 8.1: Kernel Types and Their Distributions. Each function will result in a slightly different estimation. Deciding which function is most suitable for your analysis will all depend on what you are trying to capture. We can compare and see the impact of different functions on our current dataset looking at the default kernel in density.ppp(), which gaussian, alongside the epanechnikov, quartic or disc kernels. Note, the sigma in these KDEs is set to 400m: Tip To change the kernel within your KDE, you simply need to add the kernel parameter and set it to one of the kernels available, denoted as a string, e.g. epanechnikov, quartic, disc. Ultimately, however, bandwidth will have a more marked effect upon the density estimation than kernel type. Wee can be quite confident in stating that bike theft in London in 2019 is not a spatially random process and we can clearly see the areas where bicycle theft is most concentrated. How can we use this new data in our original analysis that looks to find out whether bike theft primarily occurs near tube and train stations? The main use of a KDE is primarily for visual analysis of our point data distribution. However, our current plotting approach is quite limited - if you had not noticed, we have primarily been using the base R plotting techniques to display the results of our density.ppp() function. It would therefore be difficult to create any maps that allow visual comparison to our train stations nor could we really complete any further analysis on our KDE dataset. This is because, at the moment, our KDE raster is stored as a spatstat object - and is not, currently, a standalone raster dataset. As a result, we cannot use our KDE with other visualisation libraries such as tmap. To enable this use, we need to first export our KDE spatstat object into a standalone raster that can be used with these libraries. We therefore need to look to the raster library that is capable of doing just that. Until now, with our spatial data, we have primarily used vector data that the sf library can read, load and manage. However the sf library does not contain the right functions to enable the same reading, loading and management of raster data. As a result, it is not a suitable spatial library for dealing with raster data. Instead, we need to use the raster library, which is the default spatial library for dealing with raster data (i.e. just as we use sf for vector, we use raster for raster). To convert spatstat KDE object into a raster, we only need one very simple function from the raster library: raster(). To return a raster from our density.ppp() function, we simply need to pipe its output into the raster function: # create a raster directly from the output of our KDE kde_400g_raster &lt;- density.ppp(bike_theft_ppp_jitter, sigma = 400, edge = T) %&gt;% raster() # plot the resulting raster plot(kde_400g_raster) We now have a standalone raster we can use with any function in the raster() library (more on this next week) and our visualisation libraries, including tmap. Before we go ahead, one issue we will face is that our resulting raster does not have a Coordinate Reference System. A bit like using the st_crs() function in sf, we can use the crs() function within the raster library to check our kde_400g_raster CRS: # check the CRS of the kde_400g_raster crs(kde_400g_raster) ## Coordinate Reference System: ## Deprecated Proj.4 representation: NA You should see an NA appear within our CRS arguments, so we need to fix this: # set the CRS of the kde_400g_raster to BNG crs(kde_400g_raster) &lt;- &quot;+init=EPSG:27700&quot; # Check the CRS of the kde_400g_raster crs(kde_400g_raster) ## Coordinate Reference System: ## Deprecated Proj.4 representation: +init=EPSG:27700 Now we have our raster ready to map, we can use the same Grammar of Graphics approach that we have used with our vector data and will first provide tmap with our kde_400g_raster as a tm_shape(). We then add the tm_raster() function, with the required and optional parameters we want to include: # map our kde_400g_raster using tmap tm_shape(kde_400g_raster) + tm_raster(&quot;layer&quot;, palette = &quot;viridis&quot;) With our kde_400g_raster using tmap, we can go ahead and customise our map as we would do with our vector mapping such as changing the legend, adding a title, north arrow, etc. 8.5 Assignment We are now one step closer to visually investigating our original hypothesis that bike theft primarily occurs near tube and train stations. To help with our analysis, we could go ahead and change the tmap_mode to the view mode and use the basemap to visually investigate the distribution of bike theft and its relation to train stations. Alternatively, we could make a static map that overlays our london_stations_osm spatial dataframe as part of our map and compare their location against our visible clusters, that we could use for visual analysis and confirmation of our hypothesis. For this week’s assignment, you need to produce a finished KDE map for bike theft in London that also shows the location of train stations relative to our KDE clusters. You can adjust the bandwidth and kernel settings if you like, but mainly you need to create a final map that contains this additional data layer as well our expected mapping conventions, plus a title and a renamed legend title. Once your map is done: do you think our hypothesis is confirmed? How confident are you in this assessment? 8.6 Distance-Based Methods We have spent a good amount of time looking at using density-based methods to quantify whether our point data is randomly distributed and visualise and identify high and low areas of density, showing if our data is clustered and where. Overall, within PPA, (kernel) density estimation is certainly a prominent technique, but we also have distance-based methods that allow us to quantify the 2nd order properties of our data, i.e. the influence the location of these points have on one another. Distance-based measures analyze the spatial distribution of points using distances between point pairs, with the majority using Euclidean distance, to determine quantitatively whether our data is, again, randomly distributed or shows sign of clustering or dispersion. These methods are a more rigorous alternative to using the Quadrat Analysis approach, and enables us to assess clustering within our point data at both a global and local scale. 8.6.1 Average Nearest Neighbour Average Nearest Neighbour (ANN) is the average distance between all points within a dataset and their individual nearest point. ANN is used as a global indicator to measure the overall pattern of a point set. The ANN of a given point collection can be compared with the expected ANN from points following complete spatial randomness (CSR) to test whether our point data is clustered or dispersed (Yuan et al. 2020). Figure 8.2: Relations between different point patterns and mean nearest neighbor distance (NND). Source: Yuan et al. 2020. The approach is similar to that of the Quadrat Analysis simulation we saw above, but by using distance rather than density grouped to arbitrary quadrats, ANN is likely to be a more robust quantification of our point distribution. We can calculate the ANN for our dataset by using the nndist() function from the spatstat library: # calculate the average distance to nearest neighbour mean(nndist(bike_theft_ppp_jitter, k = 1)) ## [1] 61.38663 We can see that the average nearest neighbour for all points is 61.3 metres. To understand whether our dataset is clustered or dispersed, we now need to run a Monte Carlo simulation of running the ANN test for multiple (think hundreds) of Poisson distributions of our bike thefts within our London ward in order to generate a graph as above. Then, similar to our Global Moran’s I calculation, we would compare our mean to that of all of the means generated to determine whether our dataset is clustered or dispersed. The code and computing requirements to complete this analysis is quite complex, therefore, we look instead to different approach, which is to plot the ANN values for different order neighbours (i.e. first closest point, second closest point etc), to get an insight into the spatial ordering of all our points relative to one another. For point patterns that are highly clustered, we would expect that the average distances between points to be very short. However, this is based on the important assumption that the point pattern is stationary throughout the study area. Further to this, the size and shape of the study area also have a very strong effect on this metric. Calculate the average nearest neighbour to the \\(k\\) nearest neighbours for our bike theft data: # calculate the ANN for up to 100 neighbours bike_theft_ann &lt;- apply(nndist(bike_theft_ppp_jitter, k = 1:100), 2, FUN = mean) # plot the results of k ANN plot(bike_theft_ann ~ seq(1:100)) In our case, the plot does not reveal anything interesting in particular except that higher order points seem to be slightly closer than lower order points. Overall, the ANN is a good approach to conduct statistical tests on large datasets (e.g. if we were to run the Monte Carlo simulation explore above), but visually it does not tell us a huge amount about our dataset! 8.6.2 Ripley’s K function One way of getting around the limitations of both the ANN and Quadrat Analysis is to use Ripley’s K function. Ripley’s K function looks at the distance between a point and ‘all distances’ to other points and automatically compare this to a Poisson-distribution point pattern (without the need to add in Monte Carlo simulation code as above). Ripley’s K function essentially summarises the distance between points for all distances using radial distance bands. The calculation is relatively straightforward: For point event A, count the number of points inside a buffer (radius) of a certain size. Then count the number of points inside a slightly larger buffer (radius). Repeat this for every point event in the dataset. Compute the average number of points in each buffer (radius) and divide this to the overall point density. Repeat this using points drawn from a Poisson random model for the same set of buffers. Compare the observed distribution with the distribution with the Poisson distribution. We can conduct a Ripley’s K test on our data very simply with the spatstat package using the Kest() function. Tip Be careful with running Ripley’s K on large datasets as the function is essentially a series of nested loops, meaning that calculation time will increase exponentially with an increasing number of points. Run a Ripley’s K function on our bike theft data using the Kest() function: # calculate Ripley&#39;s K for our bicycle theft locations, maximum radius of 1 # kilometre plot(Kest(bike_theft_ppp_jitter, correction = &quot;border&quot;, rmax = 5000)) The Kpois(r) line shows the theoretical value of K for each distance radius (r) under a Poisson assumption of Complete Spatial Randomness. When our observed/calculated K values are greater than the expected K, this indicates clustering of points at a given distance band. In our dataset, we can see our observed distribution exceeds the Poisson distribution across our distance bands. This means our data is more clustered than what would be expected from a random distribution. Note There are several limitations to Ripley’s K. In the same fashion as the Average Nearest Neighbour Analysis, it assumes a stationary underlying point process. From our previous analysis and visualisation of our bike theft data, we know that this is unlikely to be the case, with the prevalence of bike theft influenced by a multitude of factors that they themselves vary over space. 8.7 Want more? [Optional] The use of our techniques above are useful exploratory techniques for telling us if we have spatial clusters present in our point data, but they are not able to tell us precisely where in our area of interest the clusters are occurring. One popular technique for discovering precise clusters in space is an algorithm known as DBSCAN, a density-based algorithm. For the complete overview of the DBSCAN algorithm, you can read the original paper by Ester et al. (1996) or consult the wikipedia page. Whilst DBSCAN is a relatively old algorithm, in recent years, there has been a substantial resurgence in its use within spatial data science. DBSCAN is, for instance, used to delineate urban areas (see Arribas-Bel et al. 2019. We can use DBSCAN to detect clusters within our bike theft dataset and then use the clusters to further answer our original research question. 8.7.1 What is DBSCAN? DBSCAN is an algorithm that searches our dataset to create clusters of points, using two inputs: The minimum number of points, MinPts, that should be considered as a cluster The distance, or epsilon, within with the algorithm should search. Clusters are identified from a set of core points, where there is both a minimum number of points within the distance search, alongside border points, where a point is directly reachable from a core point, but does not contain the set minimum number of points within its radius. Any points that are not reachable from any other point are outliers or noise. Both parameters need to be finely tuned, typically requiring manual experimentation in both cases before an appropriate value can be selected. The following short video on YouTube explains the algorithm really effectively: In summary, across a set of points, DBSCAN will group together points that are close to each other based on a distance measurement and a minimum number of points. It also marks as outliers the points that are in low-density regions. The algorithm can be used to find associations and structures in data that are hard to find through visual observation alone, but that can be relevant and useful to find patterns and predict trends. However, DBSCAN will only work well if you are able to successfully define the distance and minimum points parameters and your clusters do not vary considerably in density. 8.7.2 Conducting a DBSCAN analysis To conduct a DBSCAN analysis using the dbscan library, we use the dbscan() function. It is an incredibly simple function as it only takes 3 parameters: an input point dataset, the epsilon value and the minimum number of points. For our analysis, we will set our epsilon to the 200m and then set our minimum cluster to 20. # run dbscan bktheft_dbscan &lt;- dbscan(bike_theft_xy, eps = 200, minPts = 20) Tip The function only take a data matrix or dataframe of points, not a spatial dataframe. This is why in the above code we use the bike_theft_xy dataframe that we created early on in this practical. When you investigate the result from the dbscan function, you will notice that it is a “list” of three objects: a vector detailing the cluster for each of our bike theft observations / events, and two double objects that simply contain the eps and minPts parameter values used. Plot our DBSCAN analysis: # plot bike thefts by cluster plot(bike_theft_xy, col = bktheft_dbscan$cluster) # add london_ward_shp file plot(london_ward_shp$geometry, add = T) We can see some very defined clusters around the outskirts of central London and of course, a few significantly large clusters within central London. Here we run into our main issue with DBSCAN, as outlined above, that it will not work too well if our clusters vary considerably in density. It is evident just from this initial run, that the clustering we see in outer versus central London has different density properties: to account for the higher occurrence of bike theft and thus higher density, we theoretically need to have a more sensitive epsilon measure to enable more refined mapping of the clusters in this area. However, this will then create more separation in our otherwise well-defined outer London clusters. For example, below is a plot of a DBSCAN analysis run at a 100m: Therefore, to obtain a more precise analysis for central London, it would be worth separating this bike theft data out and re-running DBSCAN at a more local scale, and with finer resolution eps and minPts parameter values. For now, we will continue with our 200m DBSCAN output. 8.7.3 Working with the DBSCAN output As stated above, the DBSCAN output contains three objects, including a vector detailing the cluster for each of our bike theft observations / events. At the moment, we are visualising our clusters by mapping our points from the bike_theft_2019 spatial dataframe, but colouring them by their related cluster number. To be able to work with our DBSCAN output effectively - and for example, plot the clusters as individual polygons - we first need to add our cluster groups back to into our original point dataset (the bike_theft_2019 spatial dataframe). To add the cluster groups to our point data, we can simply use the mutate() function from the dplyr library - as you should know by now, computers are very organised and not random, therefore we can trust that the computer will use the same order to read in the points and therefore join the correct cluster to the correct point. Add the associated DBSCAN cluster number to each of the bike_theft_2019 observations: # add the cluster number column to points data frame bike_theft_2019 &lt;- bike_theft_2019 %&gt;% mutate(dbcluster = bktheft_dbscan$cluster) Now we have each of our bike theft points in London associated with a specific cluster, we can generate a polygon that represents these clusters in space, as we can sort of see in our above plot. To do so, we will utilise a geometric operation from the sf package: the st_convex_hull() function. The st_convex_hull() function can be used to create a polygon that represents the minimum coverage of our individual clusters. As a result, we can use this function to create a polygon that represents the geometry of all points within each cluster - if we provide the function with each cluster and its associated points - which can then ultimately create a final spatial dataframe that contains polygons for all clusters. To enable this, we will use something called a for loop that will make our processing way more efficient. A for loop simply repeats the code contained within it - for a specific value, usually contained within a index. Below, we use a for loop to: Filter our bike_theft_2019 spatial dataframe by each cluster into a subset. For each subset, we union these points into a single set of geometry observations. We then calculate the convex hull of that single set of geometry observations. This creates a polygon which we extract and store its geometry into a list. We then have final list containing all the geometries of our cluster polygons. We convert this list of geometries into a spatial dataframe, referenced to British National Grid. Run a for loop to generate a polygon dataset that represents our bike theft clusters: # create an empty list to store the resulting convex hull geometries Set the # length of this list to the total number of clusters found geometry_list &lt;- vector(mode = &quot;list&quot;, length = max(bike_theft_2019$dbcluster)) # create a counter to keep track counter &lt;- 0 # begin loop for (cluster_index in seq(0, max(bike_theft_2019$dbcluster))) { # filter our entire bike_theft_2019 sdf by the cluster index returns only # points for *that* cluster biketheft_cluster_subset &lt;- filter(bike_theft_2019, dbcluster == cluster_index) # for these points, first union them, then calculate the convex hull cluster_polygon &lt;- biketheft_cluster_subset %&gt;% st_union %&gt;% st_convex_hull() # add the geometry of the polygon into our list geometry_list[counter] &lt;- (cluster_polygon) # update the counter counter &lt;- counter + 1 } # change the list to a multi-polygon geometry bike_theft_clusters &lt;- st_sfc(geometry_list, crs = 27700) 8.7.4 Mapping DBSCAN clusters We now have a polygon spatial dataframe, bike_theft_clusters, that show the general location and distribution of bike theft clusters in London. Let’s go ahead and investigate them: # set tmap to view mode tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing # map our bike theft clusters and their borders tm_shape(bike_theft_clusters) + tm_borders() What do you think of the clusters? What do they tell you about the distribution of bike theft in London? Let’s go ahead and add our london_stations_osm dataset to our map. This will help highlight the location of the stations relative to our bike thefts: # set tmap to view mode tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing # map our bike theft clusters and their borders tm_shape(bike_theft_clusters) + tm_borders() + tm_shape(london_stations_osm) + tm_dots() So what does our data show? What can we conclude from our current analysis? What steps could we next complete with our bike theft analysis? 8.8 Before you leave As geographers and spatially-enabled thinkers, we are keen to understand our point data’s distribution and understand whether are our points clustered, randomly distributed (i.e. display complete spatial randomness), uniform or dispersed. We have looked at various techniques that enable us to statistically and visually assess our data’s distribution and understand whether our data is randomly distributed or not. Primarily, our main focus is using Kernel Density Estimation as a technique for the visual display and analysis of our data and its respective areas of high and low density. However, we can also use DBSCAN to create precise cluster outlines that can be also used for visual analysis but also can be further used for quantitative analysis, via geometric operations. And that is us done for this week. "],["rasters-zonal-statistics-and-interpolation.html", "9 Rasters, Zonal Statistics and Interpolation 9.1 Reading list 9.2 Raster data 9.3 Population change in London 9.4 Assignment 1 9.5 Air pollution in London 9.6 Assignment 2 9.7 Before you leave", " 9 Rasters, Zonal Statistics and Interpolation The majority of our module has focused on the use of vector data and tabular data. This week, we switch it up by focusing primarily on raster data and its analysis using map algebra and zonal statistics. 9.1 Reading list Essential readings Dugoua, E. Kennedy, R. and Urpelainen, J. 2018. Satellite data for the social sciences: measuring rural electrification with night-time lights. International Journal of Remote Sensing 39(9): 2690-2701. [Link] Gimond, M. 2021. Intro to GIS and spatial analysis. Chapter 14: Spatial Interpolation. [Link] Jumaah, H. et al. 2019. Air quality index prediction using IDW geostatistical technique and OLS-based GIS technique in Kuala Lumpur, Malaysia. Geomatics, Natural Hazards and Risk 10(1): 2185-2199. [Link] Suggested readings Ferreira, T. 2018. Using satellite data to track socio-economic outcomes: a case study of Namibia. Stellenbosch Working Paper Series WP12/2018. [Link] Mellander, C. et al. 2015. Night-time light data: a good proxy measure for economic activity? PLoS ONE 10(10): e0139779. [Link] 9.2 Raster data This week’s content introduces you to raster data, map algebra and interpolation. After first looking at population change in London using raster data, we will then look at generating pollution maps in London from individual point readings taken from air quality monitoring sites across London. To complete this analysis, we will be using several new datasets: Population rasters for Great Britain: Raster datasets containing estimated population counts for Great Britain in 2001 and 2011 at a spatial resolution of 1km. NO2 readings across London: A dataset contain readings of NO2 for individual air quality monitoring sites in London. We will also use our London wards (2018) administrative boundaries dataset at various points within both practicals. This file should already be in your raw/boundaries folder. 9.2.1 Housekeeping Let’s get ourselves ready to start our practical content by first downloading the relevant data and loading this within our script. Open a new script within your GEOG0030 project and save this script as wk9-pollution-raster-analysis.r. At the top of your script, add the following metadata (substitute accordingly): # Analysing population change and pollution in London # Data: January 2023 # Author: Justin Within your script, add the following libraries for loading: # libraries library(tidyverse) library(sf) library(raster) library(tmap) library(gstat) library(spatstat) 9.2.2 Downloading data 9.2.2.1 Population data For the first part of this week’s practical material we will be using raster datasets from the Population Change and Geographic Inequalities in the UK, 1971-2011 (PopChange) project. In this ESRC-funded project, researchers from the University of Liverpool created raster population surfaces from publicly available Census data (1971, 1981, 1991, 2001, 2011). These population surfaces are estimates of counts of people, displayed within a regular grid raster of a spatial resolution of 1km. These surfaces can be used to explore, for example, changes in the demographic profiles of small areas, area deprivation, or country of birth. To enable this, the researchers have created several categories of rasters, including: Total Population, Population by Age, Population by Country of Birth, Population by Ethnicity etc. This week we will use the Total Population datasets. To access data directly from the PopChange website requires a simple registration for log-in, you can then navigate through the datasets and choose those you would like to download. For this week, we have gone ahead and downloaded the data for you, which you can access directly from the links below: PopChange Raster File Type Link Population surface GB 2001 - Total Population asc Download Population surface GB 2011 - Total Population asc Download Once downloaded, copy over these files into your data/raw/population folder. 9.2.2.2 Pollution data For the second part of this week’s practical material, we will explore several methods of interpolation by looking at air pollution in London by getting data from the Londonair website. Londonair is the website of the London Air Quality Network (LAQN), and shows air pollution in London and south east England that is provided by the Environmental Research Group of Imperial College London. The data are captured by hundreds of sensors at various continuous monitoring sites in London and the south east of England. The data are publicly available for download and we can use an R package to directly interact with the data without needing to download it. The openair R package enables us to import data directly form the Londonair website. Note The openair library can be a bit fiddly at times: to make things easy for us, you can simply download a copy of the data below. Pollution Data Type Link Air pollution in London for 2019 (NO2) csv Download Once downloaded, copy over these files into a data/raw/pollution folder. Please note that the file is rather larger (~170 MB) and it is best to keep it as .zip file. 9.2.3 Raster data In the previous weeks, we have predominantly worked with vector data and/or tabular data that we then join to vector data for analysis. However, depending on the nature of your research problem, you may also encounter raster data. Figure 9.1: A hypothetical raster and a vector model of landse. If you remember, the main difference between vector and raster models is how they are structured. Our vectors are represented by three different types of geometries: points, lines and polygons. We have used point data in the form of our stations and bike theft, and polygons in the form of our ward and borough boundaries. In comparison, our raster datasets are composed of pixels (or grid cells) - a bit like an image. This means that a raster dataset represents a geographic phenomenon by dividing the world into a set of rectangular cells that are laid out in a grid. Each cell holds one value that represents the value of that phenomena at the location, e.g. a population density at that grid cell location. In comparison to vector data, we do not have an attribute table containing fields to analyse. All analysis conducted on a raster dataset therefore is primarily conducted on the cell values of a raster, rather than on the attribute values of the observations contained within our dataset or the precise geometries of our dataset. Probably one of the most common or well-known types of raster data are those that we can derive from remote sensing, including satellite and RADAR/LIDAR imagery that we see used in many environmental modelling applications, such as land use and pollution monitoring. However, over the last few years, raster data has increasingly being used within spatial data science applications. For example, Worldpop and Facebook have created raster-based estimates of population density (and other variables), that you can access openly via their respective links. Beyond their benefits in computational requirements and even, for some geographical phenomena, visualisation capacity and capabilities, a key advantage of raster data is that is relatively straight-forward to standardise data across space (i.e. different countries) and across variables (i.e. different datasets) to enable greater compatibility and easier comparison of datasets than its vector counterparts. We have, for example, seen that we can run into issues quickly even with data on London, as our ward boundaries have changed so frequently even over just the last ten years. This standardisation can occur as raster data has: An origin point from which the grid extends and then a precise number of columns and rows within said dataset; A specific spatial resolution which refers to the cell size of the raster dataset, e.g. are the grid square 100m x 100m, 1000m x 1000m, etc. From these two values, it is possible to calculate the size of our raster (number of columns X spatial resolution by the number of rows X spatial resolution) as well as * snap future rasters (or resample current rasters) to both the spatial extent and the spatial delineation of one raster dataset (i.e. ensure the cells between the rasters will align with one another). This enables us to create rasters that essentially “line up with one another” and by doing so, we are able to complete specific calculations between our raster datasets known as map algebra. 9.2.4 Map algebra Map algebra is a set-based algebra for manipulating geographic data, coined by Dana Tomlin in the early 1980s. Map algebra uses maths-like operations, including addition, subtraction and multiplication to update raster cell values - depending on the output you’re looking to achieve. The most common type of map algebra is to apply these operations using a cell-by-cell function. Conceptually, this approach will directly stack rasters on top of one another and complete the mathematical operations that you’ve supplied to the cells that are aligned with each other. These operations might include: Arithmetic operations that use basic mathematical functions like addition, subtraction, multiplication and division. Statistical operations that use statistical operations such as minimum, maximum, average and median. Relational operations, which compare cells using functions such as greater than, smaller than or equal to. Trigonometric operations, which use sine, cosine, tangent, arcsine between two or more raster layers. Exponential and logarithmic operations that use exponent and logarithm functions. But it is also possible to run (some of) these operations at a different scale. Map algebra functions can be applied using for four different approaches: Local: The simplest approach - completing functions on a cell-by-cell basis. Global: Used to apply a bulk change to all cells in a raster using a function, e.g. add 1 to all values in a raster, or calculate the euclidean distance each cell is away from a specific cell. Focal: Apply a function to a set of neighborhood values to calculate the output for a single cell, e.g. using a moving window, such as kernel. Zonal: Apply a function to a group of cells within a specified zone (zone can be provided as a raster or vector format). The utilisation of these functions can enable many different types of specialised raster analysis, such as recoding or reclassifying indivdual rasters to reduce complexity in their data values, generating the Normalised Difference Vegetation Index for a satellite imagery dataset, or calculating Least Cost Estimate Surfaces to find the most “efficient” path from one cell in a raster to another. Furthermore, using multiple raster datasets, it is possible to combine these data through mathematical overlays, from the basic mathematical operations mentioned above to more complex modelling, such as prediction using Bayes theorem. The results of these overlays have many applications, including identifying suitable locations for placing a new school or modelling risk to viruses, such as the Zika virus (e.g. Cunze et al, 2019 and Santos &amp; Meneses, 2017 for those of you interested in this application), and, of course, as highlighted above, population density. 9.3 Population change in London The first part of our practical this week will look at map algebra in action - and some simple raster data process - by looking to analyse population change in London between 2001 and 2011. To do so, we are going to complete a very simple bit of map algebra - we will subtract the values of the 2011 raster dataset from the 2011 raster dataset and then map the resulting values, i.e. population change. One question to think about - and reflect on as we move forward with this practical - is that we already know that small-area counts of people in a variety of population subgroups are publicly released for each Census and via the Mid-Year estimates, so why was it necessary to create these raster population surfaces? Before we open up the data in R, try to have a ‘non-spatial sneak peak’ at the .asc file by opening it in a normal text editor, for instance, TextEdit on Mac OS or NotePad on Windows. What you will notice is that the asc file, which is an exchange format, is in very fact a flat plain text file: Figure 9.2: Raster or plain text? Reflecting on what we have just read about rasters and their format, what do you think the first few lines of the asc file, when opened with a text editor, mean? 9.3.1 Loading data Let’s get started and take a look at our data. First we need to load it into R (using the raster library) and then we can quickly plot it using the base plot function: # load our two raster datasets pop_2001 &lt;- raster(&quot;data/raw/population/5a_ascii_grid2001_Total_Population_UsRsPopA.asc&quot;) pop_2011 &lt;- raster(&quot;data/raw/population/5a_ascii_grid2011_Total_Population_URPopAll.asc&quot;) # plot 2001 - this can be a little slow, especially for large raster plot(pop_2001) # plot 2011 - this can be a little slow, especially for large rasters plot(pop_2011) You should see that whilst your maps look very similar, the legend certainly shows that the values associated with each cell has grown over the 10 years between 2001 and 2011: we see our maximum increase from 15,000 people per cell to 20,000 people per cell. Now we have our raster data loaded, we want to reduce it to show only London using our London ward shapefile. To do so, we will use a combination of two techniques - the crop() function and then using a mask to refine our raster further. The crop() function crop any raster by the overall spatial extent or rather bounding box of the y dataset. As a result, the raster returned will be rectangular (or square) in shape - and not cropped to the precise geometry of the y dataset that we see in the use of the st_intersections() function that we use with vector data. To reduce a raster to the (almost) precise geometry of the y dataset, we need to instead use a mask approach. Tip A mask will only work when using two raster datasets. As a result, we need to turn our y dataset (in our case, the London ward shapefile) into a raster - a process simply known as “rasterize” or “rasterizing”. This process of rasterizing will turn our polygon dataset into a raster and thus simplify/alter the geometry of our dataset to coerce it into a grid-based dataset: Figure 9.3: Rasterising a line vector - forcing geometries into a grid. Source: Lovelace et al. 2020. To ensure our resulting raster of our London ward shapefile matches the spatial delineation (aligns our cells) and resolution (make cells the same size) of our population rasters, instead of separately rasterising (using the rasterise() function) our London ward shapefile and then masking (using the mask() function) our rasters by the resulting raster, we can combine this into one, still using the rasterise() function but adding the London population rasters into the function and the mask parameter set to True. Load our London ward shapefile and use this to first crop, then mask our population rasters: # load london ward data london_ward &lt;- read_sf(&quot;data/raw/boundaries/2018/London_Ward.shp&quot;) # crop raster to extent greater london lonpop_2001 &lt;- crop(pop_2001, london_ward) lonpop_2011 &lt;- crop(pop_2011, london_ward) # rasterise London ward, and mask each population raster lonpop_2001 &lt;- rasterize(london_ward, lonpop_2001, mask = TRUE) lonpop_2011 &lt;- rasterize(london_ward, lonpop_2011, mask = TRUE) # plot the 2001 London population raster plot(lonpop_2001) # plot the 2011 London population raster plot(lonpop_2011) You should now have generated two plots for each year. You can quickly flick between the two and see there is evidence of population change between our two datasets. 9.3.2 Analysing population change Now we have our two London population rasters, we are now ready to go ahead and calculate population change between our two datasets by subtracting our 2001 population raster from our 2011 population raster: # subtract 2001 population from 2011 population lonpop_change &lt;- lonpop_2011 - lonpop_2001 # plot the results plot(lonpop_change) We now have a raster that shows us population change in London - and to our surprise, there are areas in which population has actually declined. We can utilise some of the focal and zonal functions from our map algebra catalogue to further enhance our understanding of population change in London. To further analyse our population change raster, we can create a ‘pseudo’ hotspot map of our lonpop_change raster by calculating a smoothed version of our raster using the focal() function. This will enable us to see more clearly where there are areas of high counts (surrounded by areas of high counts) and vice versa - just like our KDE analysis of bike theft. Using the focal() function, we generate a raster that summarises the average (mean) value, using the fun= parameter set to mean, of the 9 nearest neighbours for each cell, using a weight matrix defined in our w parameter and set to a matrix (consisting of our cell with 3 rows and 3 columns as neighbours): # focal statistics (of 9 neighbours) to calculate smoothed raster lonpop_smooth &lt;- focal(lonpop_change, w = matrix(1, 3, 3), fun = mean) # plot results plot(lonpop_smooth) Our areas of high population growth are now more visible in our dataset. Our areas of population decline are potentially not as stark, but are certainly still visible within our raster. We can also look to use zonal functions to better represent our population change by aggregating our data to coarser resolutions. For example, we can resize our raster’s spatial resolution to contain larger grid cells which will, of course, simplify our data, making larger trends more visible in our data but of course, may end up obfuscating smaller trends. We can resize our lonpop_change raster by using the aggregate() function and setting the fact= (factor) parameter to the “order” of rescaling we would like (in our case, 2 times larger both width and height). We then provide the fun= (function) by which to aggregate our data, in this case, we will continue to use the mean but we could in fact provide min or max depending on our future applications/analysis of our dataset: # rescale raster and aggregate based on mean lonpop_change_agg &lt;- aggregate(lonpop_change, fact = 2, fun = mean) # plot resulting raster plot(lonpop_change_agg) Another very common technique used in raster analysis via map algebra is the use of zonal statistics. As outlined earlier, a zonal statistics operation is one that calculates statistics on cell values of a raster (a value raster) within specific zones that are defined by another dataset. The zones can be provided by both raster and vector data - as a result, zonal statistics are a really useful tool if we need to aggregate data from a raster dataset for use within further analysis that primarily uses vector data, such as when we’re analysing data within administrative boundaries. For example, in our case, we can aggregate the lonpop_change raster to our actual London ward boundaries, i.e. calculate for each ward in our dataset, the average (or other function) population change, as determined by our raster. We can, of course, use other functions other than the mean. What function you use will simply depend on your application. Esri has a great resource on how Zonal statistics works with other functions and raster # change tmap mode to plot tmap_mode(&quot;plot&quot;) # aggregate to administrative geography # note: the output is a vector that is forced to a SpatialPolygons object (not sf) london_ward_pop &lt;- raster::extract(lonpop_change, london_ward, fun = mean, sp = TRUE) # plot via tmap tm_shape(london_ward_pop) + tm_polygons(col = &quot;layer&quot;) We now have a vector dataset that we could go ahead and run many of the analyses that we have completed in previous weeks. Furthermore, we can use this data within other analyses we might want to complete. For example, if we are using population change as a specific variable to analyse another dataset that is only available as a vector dataset / at the ward level. Note Trying to calculate population change, particularly across decades as we have done here, is quite difficult with our Census and Mid-Year Estimates given the differences in our ward boundaries and the impact this has when we try to join datasets from different years that then have different codes that we need to join by attribute. Using raster data, such as these datasets, are a good workaround to these issues, but, of course, with any data processing, will add some level of uncertainty into our datasets. 9.4 Assignment 1 The first assignment this week is a purely theoretical question: How can we use a combination of the techniques we have used over the last few weeks to calculate the number of people in London under-served by public transport? To answer the question, we want you to think of a method using what you have learnt above in regards to map algebra and your use of point data in the previous week, to think about how we can calculate the number of people who are not within 400m euclidean distance walk of a bus, tube or train station in London. Tip Many libraries in R share the same function names. This can be a problem when these packages are loaded in a same R session. For instance extract is not only the name of a function in the raster package, but also the name of functions in the magrittr and tidyr packages. To ensure you are using the function that you think you are using, you can specify the package using the :: approach, as follows: library::function, e.g. tidyr::extract or raster::extract. 9.5 Air pollution in London The second half of this week’s tutorial focuses on interpolation. Spatial interpolation is the prediction of a given phenomenon in unmeasured locations. There are many reasons why we may wish to interpolate point data across a map. It could be because we are trying to predict a variable across space, including in areas where there are little to no data. We might also want to smooth the data across space so that we cannot interpret the results of individuals, but still identify the general trends from the data. This is particularly useful when the data corresponds to individual persons and disclosing their locations is unethical. To predict the values of the cells of our resulting raster, we need to determine how to interpolate between our points, i.e. develop a set of procedures that enable us to calculate predicted values of the variable of interest with confidence and, of course, repetitively. We will put some techniques into action by interpolating our air quality point data into a raster surface to understand further how air pollution varies across London. 9.5.1 Loading data Before we get going within interpolating our pollution dataset, let’s first take a look at the distribution of the London Air monitoring sites in London. What are your thoughts about the distribution of the sites? Do you think they will provide enough data for an accurate enough interpolation? Figure 9.4: Locations of the London Air monitoring sites in London. Source: Londonair 2020. Ultimately, monitoring sites and the sensor stations present at them can be expensive to install and run, therefore, identifying the most important places for data collection will somewhat determine their location, alongside trying to create a somewhat even distribution over London. As we can see in the locations of the stations above, there are certainly some areas in London that do not have a station nearby, whilst others (such as central London) where there are many stations available. When using interpolation, the distribution and density of our data points will impact the accuracy of our final raster and we may end up with a level of uncertainty in the areas where data is more sparse, such as the north-west and the south-east of London. Despite this, we can still create an interpolated surface for our pollutant of interest, we just need to interpret our final raster with acknowledgement of these limitations. For this week’s practical, we will go ahead and use the Londonair’s data to study the levels of Nitrogen Dioxide (NO2) in London for 2019. Once we have our data loaded and processed in the right format, we will start interpolating our data using at first two models: Thiessen Polygons and Inverse Distance Weighting. # read in downloaded data # as the file is quite large, we will read it directly from zip pollution &lt;- read_csv(&quot;data/raw/pollution/no2_london_2019.zip&quot;) # pollution dataframe dimensions dim(pollution) ## [1] 1596509 7 Reading in the csv might take a little time: we have 1,596,509 observations with 7 variables. 9.5.2 Analysing air pollution Let’s take a look at why it’s so large and inspect the first five rows of our dataframe: # Rreturn first five rows of our pollution dataframe head(pollution) ## # A tibble: 6 × 7 ## date no2 site code latit…¹ longi…² site_…³ ## &lt;dttm&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2019-07-01 12:00:00 14.5 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## 2 2019-07-01 13:00:00 16.1 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## 3 2019-07-01 14:00:00 16.2 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## 4 2019-07-01 15:00:00 21.8 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## 5 2019-07-01 16:00:00 19.7 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## 6 2019-07-01 17:00:00 17.5 Southwark - Tower Bri… SK8 51.5 -0.0782 Roadsi… ## # … with abbreviated variable names ¹​latitude, ²​longitude, ³​site_type We can see that in our first five rows we have data for the same site and if we look at the date field, we can see we have a reading observation for every hour. With 24 hours in the day, 365 days in a year and potentially hundreds of sites, it should therefore be of no surprise that we have such a big csv. In the end, for this practical, we only want to create one raster, so to make our data more useable we will go ahead and aggregate the data and get the average NO2 value for each monitoring site over 2019. Use the dplyr library functions to return the mean NO2 value for each monitoring site over 2019. Let’s also make sure that we retain the latitude and longitude of our monitoring sites: # aggregate data to unique latitude and longitude combinations, remove # monitoring sites without coordinates, summarise the no2 by the mean avg_pollution &lt;- pollution %&gt;% group_by(latitude, longitude) %&gt;% summarise(no2 = mean(no2)) %&gt;% filter(!is.na(latitude | longitude)) # return the first five rows of our new dataframe head(avg_pollution) ## # A tibble: 6 × 3 ## # Groups: latitude [6] ## latitude longitude no2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 49.8 -7.56 35.6 ## 2 50.4 -4.14 17.5 ## 3 50.7 -1.83 11.5 ## 4 50.8 0.284 15.7 ## 5 50.8 0.181 7.23 ## 6 50.8 0.272 11.4 # return the histogram of our no2 values hist(avg_pollution$no2) We should now see that we only have our latitude and longitude coordinates and the average NO2 value associated with each. Our histogram also shows us the general distribution of our values: we can see that we have a slight positive skew to our dataset. To use this data within our different interpolation methods, we will need to transform our data into a point spatial dataframe using the st_as_sf() function that we have come across before. One thing you should notice is that the latitude and longitude are projected in WGS84 and, therefore, we need to reproject our resulting spatial dataframe into British National Grid. We will also make sure that all of our points are within our London ward extent, using the st_intersection() function. Create a spatial dataframe containing our London monitoring sites and their average NO2 reading: # load London wards for reference map london_ward &lt;- read_sf(&quot;data/raw/boundaries/2018/London_Ward.shp&quot;) # create a point spatial dataframe, project pollution_points &lt;- st_as_sf(avg_pollution, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326)[, 1] %&gt;% st_transform(27700) # ensure all points are within the boundaries of Greater London lonpollution_points &lt;- pollution_points %&gt;% st_intersection(london_ward) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries Let’s create a proportional symbol map to visualise these points: # ensure tmap mode is set to plot tmap_mode(&quot;plot&quot;) # plot our London wards in grey tm_shape(london_ward) + tm_polygons(palette = &quot;grey&quot;, border.col = &quot;white&quot;) + # plot our pollution_points as bubbles, using the NO2 field to determine size tm_shape(lonpollution_points) + tm_bubbles( size = &quot;no2&quot;, col = &quot;mediumorchid&quot;, style = &quot;pretty&quot;, scale = 1, border.col = &quot;white&quot;, title.size = &quot;Average NO2 ug/m3 reading in 2019&quot; ) + # set legend tm_layout(legend.position = c(&quot;left&quot;, &quot;top&quot;)) + # add a north arrow tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;top&quot;)) + # add a scale bar tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c(&quot;left&quot;, &quot;bottom&quot;)) + # add a data statement tm_credits(&quot;Air quality data from London Air.&quot;) Our proportional symbols map already tells us a little about our dataset - we can see that NO2 levels are much higher towards the centre of London, although we can see some anomalies in the south-west, for example. But we can also see how and why a smoothed surface of our data could be really useful for further interpretation - and this is where interpolating our data comes in. 9.5.2.1 Thiessen polygons The first step we can take to interpolate the data across space is to create Thiessen polygons. Thiessen polygons are formed to assign boundaries of the areas closest to each unique point. Therefore, for every point in a dataset, it has a corresponding Thiessen polygon. Figure 9.5: Creating a set of Thiessen polygons. Source: Esri 2020. Note You may come across the term Voronoi polygons: these are the same thing as Thiessen polygons. Both terms are used interchangeably to describe this type of geometry created from point data. In the field of GIS we tend to refer to them as Thiessen polygons, after the American meteorologist who frequented their use. In other fields, particularly mathematics and computer science, they are generally referred to as Voronoi diagrams, in honour of the mathematician Georgy Voronoy. We can create Thiessen polygons using the sf library with a bit of code: we will create a simple function called st_thiessen_point() that we can use to generate Thiessen polygons directly from a point dataset. Tip Do not worry about fully understanding the code behind the function, but simply understand what input (a point spatial dataframe) and output (a Thiessen polygon spatial dataframe) it will provide. You need to copy over both the function and the code underneath. Copying the function stores this function in your computer’s memory for this R session and means the function itself can be used time and time again within the same session or script. The first of the two lines of code below the function then “call” this function on our lonpollutions_points spatial dataframe. The second essentially joins the attribute fields of our lonpollutions_points spatial dataframe to our new Thiessen polygon spatial dataframe and stores this as a new variable. # function to create Thiessen polygons from point input st_thiessen_point &lt;- function(points) { # input check if (!all(st_geometry_type(points) == &quot;POINT&quot;)) { stop(&quot;Input not POINT geometries&quot;) } # make multipoint g &lt;- st_combine(st_geometry(points)) # create thiessen polygons v &lt;- st_voronoi(g) v &lt;- st_collection_extract(v) # return return(v[unlist(st_intersects(points, v))]) } # call function lon_points_voronoi &lt;- st_thiessen_point(lonpollution_points) # add attribute data lonpollution_tv &lt;- st_set_geometry(lonpollution_points, lon_points_voronoi) # inspect lonpollution_tv ## Simple feature collection with 96 features and 7 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 460777.5 ymin: 117634.9 xmax: 599276.3 ymax: 244670.2 ## Projected CRS: OSGB36 / British National Grid ## # A tibble: 96 × 8 ## no2 NAME GSS_C…¹ DISTR…² LAGSS…³ HECTA…⁴ NONLD…⁵ geometry ## * &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;POLYGON [m]&gt; ## 1 41.4 Tolw… E05000… Kingst… E09000… 259. 0 ((460777.5 117634.9, 460… ## 2 33.1 Coom… E05000… Kingst… E09000… 442. 0 ((518160.8 172616.8, 519… ## 3 57.1 Grove E05000… Kingst… E09000… 192. 0 ((505134.1 163271.3, 518… ## 4 28.7 Wadd… E05011… Croydon E09000… 392. 0 ((539500.1 117634.9, 529… ## 5 43.8 Norb… E05011… Croydon E09000… 134. 0 ((528255.9 169332.5, 528… ## 6 44.4 Fair… E05011… Croydon E09000… 147. 0 ((531058.8 165771.8, 531… ## 7 24.2 Brom… E05000… Bromley E09000… 372. 0 ((562432.6 117634.9, 543… ## 8 48.5 East… E05000… Ealing E09000… 428. 0 ((519222.9 181677.7, 519… ## 9 26.5 Sout… E05000… Ealing E09000… 143. 0 ((518394.3 176777, 51679… ## 10 41.8 Acto… E05000… Ealing E09000… 177. 0 ((517366.5 178928.5, 519… ## # … with 86 more rows, and abbreviated variable names ¹​GSS_CODE, ²​DISTRICT, ## # ³​LAGSSCODE, ⁴​HECTARES, ⁵​NONLD_AREA We can now visualise these Thiessen polygons with their associated NO2 value: # visualise thiessen polygons tm_shape(lonpollution_tv) + tm_fill(col = &quot;no2&quot;, palette = &quot;Purples&quot;) We can go ahead tidy this up further by clipping our Thiessen polygons to the extent of London: # generate London outline through st_union london_outline &lt;- london_ward %&gt;% st_union() # clip our thiessen polygons to our london outline lonpollution_tv &lt;- st_intersection(lonpollution_tv, london_outline) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries # visualise thiessen polygons tm_shape(lonpollution_tv) + tm_fill(col = &quot;no2&quot;, palette = &quot;Purples&quot;) And that’s it! We now have our values interpolated using our Thiessen polygon approach. However, as you can see, our approach is quite coarse. Whilst we, of course, can see areas of high and low pollution, it really does not offer us as much spatial detail as we would like, particularly when we know there are better methods out there to use. 9.5.2.2 Inverse Distance Weighting A second method to interpolate point data is Inverse Distance Weighting (IDW). An IDW is a means of converting point data of numerical values into a continuous surface to visualise how the data may be distributed across space. The technique interpolates point data by using a weighted average of a variable from nearby points to predict the value of that variable for each location. The weighting of the points is determined by their inverse distances drawing on Tobler’s first law of geography that “everything is related to everything else, but near things are more related than distant thing”. The distance weighting is done by a power function: the larger the power coefficient, the stronger the weight of nearby point. The output is most commonly represented as a raster surface. We will use the idw() function within the gstat library to conduct an IDW on our lonpollution_points spatial dataframe. Before we can run IDW, we must first generate an empty grid within which to store our data. To do so, we can use the spsample() function from the sp library. We will go ahead and create a grid that covers the entirety of our london_outline, which we will transform into the sp format using the as() function. We then run the gstat idw() function on an sp version of our lonpollution_points dataset, specifying the cell size. We then specify that our IDW result is a gridded format that we then coerce into a raster. Once we have our raster, we can reset its CRS and of course utilise other functions from the raster library to process (e.g. the mask function) and then visualise our dat aset within tmap. Note Some of the following code will unfortunately not work as intended for some of you due to changes in underlying libraries. If the gsat below does not work for you, you can try to conduct the interpolation using thespatstat library instead. # convert our lonpollution_points into the sp format lonpollution_pointsSP &lt;- lonpollution_points %&gt;% as(., &quot;Spatial&quot;) # convert our london_outline into the sp format london_outlineSP &lt;- london_outline %&gt;% as(., &quot;Spatial&quot;) # create an empty raster grid the size for our london_outline over which to # interpolate the pollution values grid &lt;- spsample(lonpollution_pointsSP, type = &quot;regular&quot;, cellsize = 450, bb = bbox(london_outlineSP)) # run an IDW for the NO2 value with a power value of 2 idw &lt;- gstat::idw(lonpollution_pointsSP$no2 ~ 1, lonpollution_pointsSP, newdata = grid, idp = 2) ## [inverse distance weighted interpolation] # specify idw spatial data as being gridded gridded(idw) &lt;- TRUE # coerce to our gridded idw to the raster format lon_poll_raster_idw &lt;- raster(idw) # set our raster CRS to BNG crs(lon_poll_raster_idw) &lt;- CRS(&quot;+init=epsg:27700&quot;) # mask our raster to only the london outline lon_idw_gstat &lt;- rasterize(london_ward, lon_poll_raster_idw, mask = TRUE) # plot the resulting raster plot(lon_idw_gstat) Great. Ff this code has worked for you and you have generated an IDW raster, you can move onto the next task which is to create a proper map of our resulting IDW. 9.5.2.3 Alternative: IDW with spatstat [Optional] For those of you that cannot run the code above, we can look to spatstat as an alternative option although it just brings with it its few complications in terms of converting our datasets into our ppp object: we will first have to convert our data to the ppp object type and then use this within the idw() function spatstat offers. # set our window of observation to London window &lt;- as.owin(london_outline) # extract the coordinates of our pollution points sdf points_xy &lt;- lonpollution_points %&gt;% st_coordinates() # create a ppp object, setting x and y equal to the respective columns in our # matrix set the window equal to our window variable set our &#39;marks&#39; equal to # the NO2 column in our points pollution_ppp &lt;- ppp(x = points_xy[, 1], y = points_xy[, 2], marks = lonpollution_points$no2, window = window) # run the IDW ss_idw &lt;- spatstat.core::idw(pollution_ppp, power = 2, at = &quot;pixels&quot;) # coerce our im output to raster lon_idw_sp &lt;- raster(ss_idw) # set our raster CRS to BNG crs(lon_idw_sp) &lt;- CRS(&quot;+init=epsg:27700&quot;) # plot the resulting raster plot(lon_idw_sp) You should see we actually get a similar result to the IDW of the gstat library. This is because our cell sizes resolutions are similar in both cases. We set our cell resolution as 450 x 450m above and we can check the cell size of our spatstat IDW raster using a very simple command: res(lon_idw). You will see that the IDW spatstat auto-generated a 456m cell size. 9.5.2.3.1 Mapping the IDW raster We now have our final predicted raster surface. To map it, we can again use the tm_raster() as we have done previously. For our raster, the name of the layer we need to provide is var1.pred for those using the gstat result and simply layer for those using the spatstat result. # plot the gstat raster tm_shape(lon_idw_gstat) + tm_raster(&quot;var1.pred&quot;, style = &quot;quantile&quot;, n = 100, palette = &quot;Reds&quot;, legend.show = FALSE ) + tm_shape(london_ward) + tm_borders(col = &quot;white&quot;, lwd = 0.1) ## Warning in CPL_crs_from_input(x): GDAL Message 1: +init=epsg:XXXX syntax is ## deprecated. It might return a CRS with a non-EPSG compliant axis order. # plot the spatstat raster tm_shape(lon_idw_sp) + tm_raster(&quot;layer&quot;, style = &quot;quantile&quot;, n = 100, palette = &quot;Reds&quot;, legend.show = FALSE ) + tm_shape(london_ward) + tm_borders(col = &quot;white&quot;, lwd = 0.1) And that’s it. For those of you able to use the gstat code, it is highly worth playing around with the cell size to look at how it changes the smoothness of our resulting IDW. A smaller cell size will create a smoother IDW output, but it does add uncertainty to these estimates as we do not exactly have a substantial amount of data points to interpolate from. To help with minimising this uncertainty, there are two additional steps you can take with your IDW output: Testing and fine-tuning the power function you have used to ensure it is a valid parameter by using something known as the Leave One Out Cross Validation. Generating a 95% confidence interval map of our interpolation mode using cross-validation methods. This is beyond the scope of this module, but if you would like to explore this you can found details on this in Manuel Gimond’s tutorial on interpolation available here: Link Tip A raster dataset normally only contains one layer, i.e. one variable. Hence when we want to map a raster, we use the tm_raster() and provide the layer name for mapping. In our examples, this has been layer and var1.pred, for example. However, in some circumstances, such as with satellite imagery we will want to use the tm_rgb() function instead. This is because these types of rasters, instead of having a single layer, actually consist of three bands: a band with a red value, a band with a green value and a band with a blue value. This is known as multi-band imagery. To visualise multiband images correctly, we need to use the tm_rgb() function in order to stack our three bands together to create the appropriate visualisation. We can visualise each band independently of one another, however, you would see that you end up with either a nearly all red, green or blue image. This is also out of scope of this module, but if you are interested to learn more about using satellite imagery with R this CASA tutorial is good place to start. Alternatively, you can also check Esri’s help information on Rasters and Raster Bands here. Learning how to use satellite imagery can be a really useful skill set, particularly as this type of data is being increasingly used human geography applications - as well as, of course, its more traditional applications in physical and environmental geography. 9.6 Assignment 2 For your final assignment this week, we want you to redo the IDW interpolation of the London pollution data for the months of June and December and see to what extent there are differences between these months. In order to do this you will, at least, need to: Create monthly averages for the pollution data. This will involve quite some data wrangling. Keep in mind that Google is your friend! For both the month of June and December create a spatial dataframe containing the London monitoring sites and their average NO2 reading. Conduct an Inverse Distance Weighting interpolation for both months of data. Execute some map algebra to identify the areas where the results of the interpolation differ. 9.7 Before you leave This week, we’ve looked at raster datasets and how we use the raster library to manage and process them. Specifically, we looked at using map algebra to apply mathematical operations to rasters, using local, global, focal and zonal approaches and how we use map algebra on either an individual or combination of rasters. We then looked at how we can use two different interpolation methods to generate raster data from point data. Understanding how to interpolate data correctly is incredibly important. Whilst in most instances you will be working with vector data, especially where government statistics and administrative boundaries are involved, there are also plenty of use cases in which you will need to generate raster data from point data, as we have done today. With that being said: that is it for our final-to-last week in Geocomputation. "],["transport-network-analysis.html", "10 Transport Network Analysis 10.1 Reading list 10.2 Transport Network Analysis 10.3 Want more? [Optional] 10.4 Before you leave", " 10 Transport Network Analysis In this final week we will cover a different type of data: network data. We will take a look at how we can use network data to measure accessibility using the dodgr R library. We will calculate the network distances between combinations of locations (i.e. a set of origins and a set of destinations). These distances can then, for instance, be used to calculate the number of a resource (e.g. fast-food outlets) within a certain distance of a Point of Interest (e.g. a school or population-weighted centroid). 10.1 Reading list Essential readings Geurs, K., Van Wee, B. 2004. Accessibility evaluation of land-use and transport strategies: review and research directions. Journal of Transport Geography 12(2): 127-140. [Link] Higgins, C., Palm, M. DeJohn, A. et al. 2022. Calculating place-based transit accessibility: Methods, tools and algorithmic dependence. Journal of Transport and Land Use 15(1): 95-116. [Link] Neutens, T. Schwanen, T. and Witlox, F. 2011. The prism of everyday life: Towards a new research agenda for time geography. Transport Reviews 31(1): 25-47. [Link] Schwanen, T. and De Jong, T. 2008. Exploring the juggling of responsibilities with space-time accessibility analysis. Urban Geography 29(6): 556-580. [Link] Suggested readings Van Dijk, J., Krygsman, S. and De Jong, T. 2015. Toward spatial justice: The spatial equity effects of a toll road in Cape Town, South Africa. Journal of Transport and Land Use 8(3): 95-114. [Link] Van Dijk, J. and De Jong, T. 2017. Post-processing GPS-tracks in reconstructing travelled routes in a GIS-environment: network subset selection and attribute adjustment. Annals of GIS 23(3): 203-217. [Link] 10.2 Transport Network Analysis The term network analysis covers a wide range of analysis techniques ranging from complex network analysis to social network analysis, and from link analysis to transport network analysis. What the techniques have in common is that they are based on the concept of a network. A network or network graph is constituted by a collection of vertices that are connected to one another by edges. Note, vertices may also be called nodes or points, whilst edges may be called links or lines. Within social network analysis, you may find the terms actors (the vertices) and ties or relations (the edges) also used. Figure 10.1: Visualising networks with vertices and edges. Understanding that networks are formed through the connections of vertices and edges, we can think of many naturally and man made occurring networks that also have a precise geography to them (i.e. their distribution can be mapped directly within geographic space), such as rivers connected with tributaries, animal tracks, electricity pylons and cables, and our road and street networks that form crucial parts of our infrastructure. The latter, in particular, have been a substantial focus of those working within spatial analysis over the last two decades, particularly with routing applications now dominating much of our day-to-day technology, from personal route-planning and ride-share apps to large-scale logistics and infrastructure applications, including the delivery operations behind all of our online shopping and even Scotland’s Trunk Road Gritters. Alongside this development of routing applications, GIS analysts, geographers and public health specialists have also identified the utility of network analysis within geographic space to calculate distance-based measurement and coverage buffers that can be used as part of accessibility studies that look to understand the provision of a specific resource (e.g. greenspaces, hospitals, and fast-food stores) to a certain area of population. 10.2.1 Accessibility in Portsmouth For this week’s practical, we will be using Portsmouth in the UK as our area of interest for our analysis. One prominent topic within the city is the issue of public health and childhood obesity. According to figures released in March 2020 by Public Health England, more than one in three school pupils are overweight or obese by the time they finish primary school within the city - higher than the national average of one in four. One potential contributor to the health crisis is the ease and availability of fast-food outlets in the city. In the following, we will measure the accessibility of fast-food outlets within specific walking distances of all school in Portsmouth starting at 400m, then 800m and finally a 1km walking distance. We will then aggregate these results to the Lower Super Output Area (LSOA) and overlay these results with some socio-economic variable. To execute this analysis, we will need to first calculate the distances between our schools and fast-food outlets. This involves calculating the shortest distance a child would walk between a school and a fast-food outlet, using roads or streets. We will use the dodgr R package to conduct this transport network analysis. Note All calculations within the dodgr library currently need to be run in WGS84/4236. This is why we will not transform the CRS of our data in this practical. 10.2.2 Acquiring network data The first dataset we need to download will help with the visualisation of our results: boundary data that contains an outline of Portsmouth. File File Type Link Major towns and cities boundaries 2015 shp Download We can now load the required libraries as well as the major towns and cities boundaries shapefile. # libraries library(tidyverse) library(sf) library(tmap) library(osmdata) library(dodgr) # load major towns and cities, filter Portsmouth portsmouth_city &lt;- st_read(&quot;data/raw/outline/Major_Towns_and_Cities__December_2015__Boundaries.shp&quot;, stringsAsFactors = FALSE) %&gt;% filter(tcity15nm == &quot;Portsmouth&quot;) ## Reading layer `Major_Towns_and_Cities__December_2015__Boundaries&#39; from data source `/Users/justinvandijk/Dropbox/UCL/Web/jtvandijk.github.io/GEOG0030/data/raw/outline/Major_Towns_and_Cities__December_2015__Boundaries.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 112 features and 5 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -4.204842 ymin: 50.34101 xmax: 1.378014 ymax: 55.03117 ## Geodetic CRS: WGS 84 To create our network and Origin-Destination dataset, we will need data on schools, fast-food outlets, and a streetnetwork. Today we will be using OpenStreetMap for this again. Whilst there are various approaches to downloading data from OpenStreetMap, we will again use the osmdata library to directly extract our required OpenStreetMap (OSM) data into a variable. The osmdata library grants access within R to the Overpass API that allows us to run queries on OSM data and then import the data as spatial objects. These queries are at the heart of these data downloads. To download our road network dataset, we first define a variable to store our bounding box coordinates, p_bbox(). We then use this within our OSM query to extract specific types of road segments within that bounding box - the results of our query are then stored in an osmdata object. We will select all OSM features with the highway tag that are likely to be used by pedestrians (e.g. not motorways). # define our bbox coordinates for Portsmouth p_bbox &lt;- c(-1.113197, 50.775781, -1.026508, 50.859941) # pass bounding box coordinates into the OverPassQuery (opq) function only # download features that are not classified as motorway osmdata &lt;- opq(bbox = p_bbox) %&gt;% add_osm_feature(key = &quot;highway&quot;, value = c(&quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;, &quot;residential&quot;, &quot;path&quot;, &quot;footway&quot;, &quot;unclassified&quot;, &quot;living_street&quot;, &quot;pedestrian&quot;)) %&gt;% osmdata_sf() Note As before: in some instances the OSM query will return an error, especially when several people from the same location are executing the exact same query. If this happens, you can just read through the instructions and download a prepared copy of the data that contains all required OSM Portsmouth data instead: [Link]. The osmdata object contains the bounding box of your query, a time-stamp of the query, and then the spatial data as osm_points, osm_lines, osm_multilines and osm_polgyons. Some of the spatial features maybe empty, depending on what you asked your query to return. Our next step therefore is to extract our spatial data from our osmdata object to create our road network data set. This is in fact incredibly easy, using the traditional $ R approach to access these spatial features from our object. Deciding what to extract is probably the more complicated aspect of this - mainly as you need to understand how to represent your road network, and this will usually be determined by the library/functions you will be using it within. Today, we want to extract the edges of the network, i.e. the lines that represent the roads, as well as the nodes of the network, i.e. the points that represent the locations at which the roads start, end, or intersect. For our points, we will only keep the osm_id data field, just in case we need to refer to this later. For our lines, we will keep a little more information that we might want to use within our transport network analysis, including the type of road, the maximum speed, and whether the road is one-way or not. # extract the points, with their osm_id. ports_roads_nodes &lt;- osmdata$osm_points[, &quot;osm_id&quot;] # extract the lines, with their osm_id, name, type of highway, max speed and # oneway attributes ports_roads_edges &lt;- osmdata$osm_lines[, c(&quot;osm_id&quot;, &quot;name&quot;, &quot;highway&quot;, &quot;maxspeed&quot;, &quot;oneway&quot;)] To check our data set, we can quickly plot the edges of our road network using the plot() function: plot(ports_roads_edges, max.plot = 1) Because we are focusing on walking, we will overwrite the oneway variable by suggesting that none of the road segments are restricted to one-way traffic which may affect our analysis as well as the general connectivity of the network. # overwrite one-way default ports_roads_edges$oneway &lt;- &quot;no&quot; Now we have the network edges, we can turn this into a graph-representation that allows for the calculation of network-based accessibility statistics. 10.2.3 Measuring accessibility Before we can construct our full network graph for the purpose of accessibility analysis, we need to also provide our Origin and Destination points, i.e. the data points we wish to calculate the distances between. According to the dodgr documentation, these points need to be in either a vector or matrix format, containing the two coordinates for each point for the origins and for the destinations. As for our Portsmouth scenario we are interested in calculating the shortest distances between schools and fast-food outlets, we need to try and download these datasets - again we will turn to OpenStreetMap. Following a similar structure to our query above, we will use our knowledge of OpenStreetMap keys and values to extract the points of Origins (schools) and Destinations (fast-food outlets) we are interested in: # download schools from OSM schools &lt;- opq(bbox = p_bbox) %&gt;% add_osm_feature(key = &quot;amenity&quot;, value = &quot;school&quot;) %&gt;% osmdata_sf() # download fast-food outlets ff_outlets &lt;- opq(bbox = p_bbox) %&gt;% add_osm_feature(key = &quot;amenity&quot;, value = &quot;fast_food&quot;) %&gt;% osmdata_sf() We also need to then extract the relevant data from the osmdata object: # extract school points ports_schools &lt;- schools$osm_points[, c(&quot;osm_id&quot;, &quot;name&quot;)] # extract fast-food outlet points ports_ff &lt;- ff_outlets$osm_points[, c(&quot;osm_id&quot;, &quot;name&quot;)] We now have our road network data and our Origin-Destination (OD) points in place and we can now move to construct our network graph and run our transport network analysis. Note In this analysis, we are highly reliant on the use of OpenStreetMap to provide data for both our Origins and Destinations. Whilst in the UK OSM provides substantial coverage, its quality is not always guaranteed. As a result, to improve on our current methodology in future analysis, we should investigate into a more official school data set or at least validate the number of schools against City Council records. The same applies to our fast-food outlets. With any network analysis, the main data structure is a graph, constructed by our nodes and edges. To create a graph for use within dodgr, we pass our ports_roads_edges() into the weight_streetnet() function. The dodgr library also contains weighting profiles, that you can customise, for use within your network analysis. These weighting profiles contain weights based on the type of road, determined by the type of transportation the profile aims to model. Here we will use the weighting profile foot, as we are looking to model walking accessibility. # create network graph with the foot weighting profile graph &lt;- weight_streetnet(ports_roads_edges, wt_profile = &quot;foot&quot;) Once we have our graph, we can then use this to calculate our network distances between our OD points. One thing to keep in mind is that potentially not all individual components in the network that we extracted are connected, for instance, because the bounding box cut off the access road of a cul-de-sac. To make sure that our entire extracted network is connected, we now extract the largest connected component of the graph. You can use table(graph$component) to examine the sizes of all individual subgraphs. You will notice that most subgraphs consist of a very small number of edges. Tip The dodgr package documentation explains that components are numbered in order of decreasing size, with $component = 1 always denoting the largest component. Always inspect the resulting subgraph to make sure that its coverage is adequate for analysis. # extract the largest connected graph component graph_connected &lt;- graph[graph$component == 1, ] # inspect number of remaining road segments nrow(graph_connected) ## [1] 55676 # inspect on a plot plot(dodgr_to_sf(graph_connected), max.plot = 1) Note OpenStreetMap is a living dataset, meaning that changes are made on a continuous basis; as such it may very well possible that the number of remaining road segments as shown above may be slightly different when you run this analysis. Now we have our connected subgraph, will can use the dodgr_distances() function to calculate the network distances between every possible Origin and Destination. In the dodgr_distances() function, we first pass our graph, then our Origin points (schools), in the from argument, and then our Destination points (fast-food outlets), in the to argument. One thing to note is our addition of the st_coordinates() function as we pass our two point data sets within the from and to functions as we need to supplement our Origins and Destinations in a matrix format. For all Origins and Destinations, dodgr_distances() will map the points to the closest network points, and return corresponding shortest-path distances. # create a distance matrix between schools and fast-food stores sch_to_ff_calc &lt;- dodgr_distances(graph_connected, from = st_coordinates(ports_schools), to = st_coordinates(ports_ff), shortest = TRUE, pairwise = FALSE, quiet = FALSE) The result of this computation is a distance-matrix that contains the network distances between all Origins (i.e. schools) and all Destinations (i.e. fast-food outlets). Let’s inspect the first row of our output. Do you understand what the values mean? # inspect head(sch_to_ff_calc, n = 1) ## 1 2 3 4 5 6 7 8 ## 1 4000.016 2090.485 6549.779 9352.913 10903.62 2231.919 11845.44 2292.263 ## 9 10 11 12 13 14 15 16 ## 1 693.2568 1672.318 1675.556 1692.929 1672.318 2090.485 2090.485 2060.898 ## 17 18 19 20 21 22 23 24 25 ## 1 4000.016 2324.454 4000.016 4000.016 3338.83 1700.179 581.0582 7212.3 3610.322 ## 26 27 28 29 30 31 32 33 ## 1 1359.146 3321.374 340.8823 1102.226 10796.81 2963.157 2720.491 3508.267 ## 34 35 36 37 38 39 40 41 ## 1 2330.386 2818.121 2920.565 2920.565 736.0556 3399.756 6231.901 3394.397 ## 42 43 44 45 46 47 48 49 ## 1 9171.192 9372.628 9238.263 9481.949 1629.029 3525.506 2400.918 7173.413 ## 50 51 52 53 54 55 56 57 ## 1 8978.739 9403.034 9329.926 6483.465 6483.465 6470.802 6470.802 763.0434 ## 58 59 60 61 62 63 64 65 ## 1 2526.807 1067.907 1010.408 1010.408 1967.697 1418.767 2818.121 1245.823 ## 66 67 68 69 70 71 72 73 ## 1 2157.02 354.4935 688.8672 2162.922 2205.285 2119.323 11755.26 4829.051 ## 74 75 76 77 78 79 80 81 ## 1 2738.124 844.6083 615.1102 788.7212 2586.476 2667.125 728.4882 11845.44 ## 82 83 84 85 86 87 88 89 ## 1 11845.44 11845.44 11934.59 11934.59 11934.59 11845.44 11845.44 11845.44 ## 90 91 92 93 94 95 96 97 ## 1 11845.44 11845.44 11845.44 11845.44 11322.89 6545.668 6589.917 6589.917 ## 98 99 100 101 102 103 104 105 ## 1 6442.566 4000.016 4000.016 4234.432 5929.469 3841.384 581.0582 597.3575 ## 106 107 108 109 110 111 112 113 ## 1 2654.314 5119.621 5317.048 5058.497 926.0127 5058.497 4045.705 753.752 ## 114 115 116 117 118 119 120 121 ## 1 556.5173 713.536 622.6949 597.3575 1225.66 3339.134 3295.754 5469.038 ## 122 123 124 125 126 127 128 129 ## 1 6670.481 6670.481 6670.481 6626.71 6670.481 6670.481 6670.481 6670.481 ## 130 131 132 133 134 135 136 137 ## 1 6670.481 12348.71 9645.464 9645.464 5522.227 9336.292 9336.292 9287.866 ## 138 139 140 141 142 143 144 145 ## 1 8563.944 9287.866 9336.292 12026.51 12026.51 12033.8 12026.11 9548.47 ## 146 147 148 149 150 151 152 153 ## 1 3586.662 2300.121 815.5434 3467.049 5708.154 905.8238 905.8238 905.8238 ## 154 155 156 157 158 159 160 161 ## 1 4950.036 4968.988 858.9023 3216.085 3397.074 11419.74 4879.532 1813.109 ## 162 163 164 165 166 167 168 169 170 ## 1 9160.3 1666.407 9599.24 9659.195 4687.627 3177.171 3467.049 3118.594 5973.195 ## 171 172 173 174 175 176 177 178 ## 1 9633.051 9659.195 5299.098 3966.434 9219.851 6041.409 5972.696 8905.439 ## 179 180 181 182 183 184 185 186 ## 1 6655.967 5895.308 10772.24 1505.914 4995.748 11489.11 1574.826 5478.182 ## 187 188 189 190 191 192 193 194 ## 1 1804.091 3107.748 9102.648 4738.493 4968.988 4041.569 13159.31 5478.182 ## 195 196 197 198 199 200 201 202 ## 1 3295.754 3295.754 556.5173 788.7212 10113.11 5101.577 9633.051 9633.051 ## 203 204 205 206 207 208 209 210 ## 1 9633.051 9645.464 9645.464 9645.464 9645.464 9633.051 9633.051 6001.071 ## 211 212 213 214 215 216 217 218 ## 1 5606.02 4718.064 4041.569 4887.462 4885.475 1543.604 1510.665 1559.537 ## 219 220 221 222 223 224 225 226 ## 1 4944.579 4949.291 4188.983 3525.506 6046.467 5452.211 5317.048 5317.048 ## 227 228 229 230 231 232 233 234 ## 1 5317.048 5317.048 5317.048 5317.048 5317.048 4963.868 6272.114 5376.342 ## 235 236 237 238 239 240 241 242 ## 1 4738.493 5818.335 6634.905 4925.352 11559.4 11584.02 5058.497 5058.497 ## 243 244 245 246 247 248 249 250 ## 1 5058.497 5058.497 5101.577 5131.313 5101.577 5131.313 5131.313 5125.567 ## 251 252 253 254 255 256 257 258 ## 1 11845.44 6549.779 6549.779 6529.533 6549.779 6549.779 6529.533 4808.089 ## 259 260 261 262 263 264 265 266 ## 1 4968.988 11845.44 4774.109 4361.855 1129.672 1302.289 1302.289 1320.727 ## 267 268 269 270 271 272 273 274 ## 1 3344.664 4341.78 1332.226 1122.057 5297.203 11934.59 12026.51 3002.79 ## 275 276 277 278 279 280 281 282 ## 1 6483.465 5784.828 3383.088 3166.965 11584.02 2920.565 1677.06 2312.611 ## 283 284 285 286 287 288 289 290 ## 1 5837.072 5735.345 5737.21 5837.072 5837.072 4958.337 1128.534 9233.39 ## 291 292 293 294 295 296 297 298 ## 1 2059.118 7833.931 1114.85 1092.164 1092.164 1122.057 1092.164 4661.76 ## 299 300 301 302 303 304 305 306 ## 1 2205.285 3361.814 2738.453 3026.324 3508.075 3522.959 3522.959 3610.322 ## 307 308 309 310 311 312 313 ## 1 3610.322 3639.371 3377.222 3522.959 2724.716 597.3575 3532.616 Our output shows the calculations for the first school and the distances between the school and every fast-food outlet. Because we manually overwrote the values for all one-way streets as well as that we extracted the larges connected graph only, we currently should not have any NA values. Tip The dodgr vignette notes that a distance matrix obtained from running dodgr_distances on graph_connected should generally contain no NA values, although some points may still be effectively unreachable due to one-way connections (or streets). Thus, routing on the largest connected component of a directed graph ought to be expected to yield the minimal number of NA values, which may sometimes be more than zero. Note further that spatial routing points (expressed as from and/or to arguments) will in this case be mapped to the nearest vertices of graph_connected, rather than the potentially closer nearest points of the full graph. The next step of processing all depends on what you are trying to assess. Here we want to understand which schools have a higher accessibility of fast-food outlets compared to others, quantified by how many outlets are within walking distance of specific distances. We will therefore look to count how many outlets are with walking distance from each school and store this as a new column within our ports_school data frame. # fastfood outlets within 400m ports_schools$ff_within_400m &lt;- rowSums(sch_to_ff_calc &lt;= 400) # fastfood outlets within 800m ports_schools$ff_within_800m &lt;- rowSums(sch_to_ff_calc &lt;= 800) # fastfood outlets within 1000m ports_schools$ff_within_1km &lt;- rowSums(sch_to_ff_calc &lt;= 1000) We can then look at our outputs quickly again using the plot() function. # set CRS for Portsmouth schools ports_schools &lt;- st_set_crs(ports_schools, 4326) # plot results plot(ports_schools) Just from this simple plot, we can see across our distances some clear geographical patterns in accessibility of fast-food outlets for schools. We can improve this plot by making a proportional symbols map that show the different counts of fast-food outlets for each school in Portsmouth with a background of the Portsmouth City outline that you loaded at the beginning of this practical. # create proportional symbol map tmap_mode(&quot;plot&quot;) tm_shape(portsmouth_city) + tm_fill(palette = &quot;grey&quot;) + tm_shape(ports_schools) + tm_bubbles( size = &quot;ff_within_400m&quot;, col = &quot;skyblue4&quot;, style = &quot;pretty&quot;, scale = 1, border.col = &quot;white&quot;, title.size = &quot;Total Count&quot; ) + tm_layout( legend.position = c(&quot;left&quot;, &quot;top&quot;), legend.text.size = 1, main.title = &quot;Fast-food outlets within 400m of a school&quot;, main.title.size = 1 ) + tm_compass(type = &quot;arrow&quot;, position = c(&quot;right&quot;, &quot;top&quot;)) + tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) + tm_credits(&quot;© OpenStreetMap contributors&quot;) The map shows that areas with greater access/exposure to fast-food outlets appear to be within the city centre and in the south, whereas those schools in the north have less exposure. However, with additional contextual information one would also be able to see that these two areas correlate quite well with the more commercial areas within Portsmouth, the high street and an area known as Gunwharf Quays. This suggests there are complexities in understanding accessibility as well as trying to apply specific policies such as banning new fast-food takeaways within a 400m range of school, particularly if these schools are in commercial areas. 10.2.4 Tutorial task Now you have calculated the number of fast-food outlets within specific distances from every school in Portsmouth, your task is to estimate the accessibility of fast-food outlets at the LSOA scale and compare this to the 2019 Index of Multiple Deprivation. Note This skills and steps required for this analysis are not just based on this week’s practical, but you will have to combine all your knowledge of coding and spatial analysis you have gained over the past weeks. One way of doing this, is by taking some of the following steps: Download and extract the 2011 LSOA boundaries of Portsmouth. Download the 2019 Index of Multiple Deprivation scores. Decide on an accessibility measure, such as: The average number of fast-food restaurants within x meters of a school within each LSOA. The average distance a fast-food restaurant is from a school within each LSOA. The (average) shortest distance a fast-food restaurant is from a school within each LSOA. The minimum shortest distance a fast-food outlet is from a school within each LSOA. Create a choropleth map of aggregate accessibility to visualise the results. Join the 2019 Index of Multiple Deprivation data to your LSOA dataset. For each IMD decile, calculate the average for your chosen aggregate measure and produce a table. Using your approach what do you think: are fast-food restaurants, on average, more accessible for students at schools that are located within LSOAs with a lower IMD decile when compared to students at schools that are located within LSOAs with a higher IMD decile? 10.3 Want more? [Optional] We have now conducted some basic accessibility analysis, however, there is some additional fundamental challenges to consider in the context of transport network and accessibility analysis: How do the different weight profiles of the dodgr package work? How would one go about creating your own weight profile? How would using a different weight profiles affect the results of your analysis? Why do we have unconnected segments in the extracted transport network? How would you inspect these unconnected segments? Would they need to be connected? If so, how would one do this? Why you think all Origins and Destinations are mapped onto the closest network points? Is this always the best option? What alternative methods could you think of and how would you implement these? 10.4 Before you leave Having finished this tutorial on transport network analysis and, hopefully, having been able to independently conduct some further area-profiling using IMD deciles, you have now reached the end of this week’s content as well as the end of Geocomputation! "],["data-sources.html", "11 Data Sources 11.1 Open Data 11.2 Safeguarded Data", " 11 Data Sources Below you will find a list of resources that you might want to explore when sourcing data for your coursework assignment or your dissertation. This is by no means an exhaustive list, but simply contains some suggestions of websites that you may want to use. Note You are not limited to using these datasets for your coursework assignment or your dissertation. 11.1 Open Data The following websites contain Open Data or link to Open Data from several respectable data providers: AirBnB Data Bike Docking Data (ready for R) Bing Maps worldwide road detections Camden Air Action Consumer Data Research Centre DEFRA DIVA-GIS Edina (e.g. OS mastermap) EU Tourism Data Eurostat Geofabrik (OSM data) Global Weather Data Google Dataset Search Johns Hopkins COVID19 Data (ready for R King’s College Data on Air Pollution London Data Store London Tube PM2.5 Levels National Public Transport Access Nodes (NaPTAN) NASA EARTHDATA NASA SocioEconomic Data and Applications Center (SEDAC) NHS Data (ready for R) nomis Official Census and Labour Market Statistics Office for National Statistics Geoportal Office for National Statistics Open Topography Planetary Computer Data Catalog Tesco Store Data (London) TfL Cycling Data TfL Open Data Tidy Tuesday Data (not exclusively spatial data) Uber Travel Time Data UK COVID19 Data UK Data Service US Census Data US City Open Data Census USGS Earth Explorer WorldPop GitHub WorldPop Some other websites that could be helpful: Awesome Public Datasets; general collection of datasets, although not limited to spatial data. Free GIS data; long list with lots of GIS datasets on many different topics and covering many different areas. 11.2 Safeguarded Data Undergraduate students can also apply for a Safeguarded dataset held by the Consumer Data Research Centre. There is a process to access these Safeguarded datasets, which is detailed on the CDRC website. Please be aware that it normally takes 4-5 weeks for your application to be processed. As part of the process, you will need to say in your application why you want that specific dataset and what you are planning to do with it. You will also need to have at least thought about the ethical implications of using that data and provide this with your data application (alongside your standard ethics application). Some of the datasets held by the CDRC that you can apply for are: Bicycle Sharing System Docking Station Observations CDRC Modelled Ethnicity Proportions - LSOA Geography FCA Financial Lives Survey Local Data Company - SmartStreetSensor Footfall Data – Research Aggregated data NHS Hospital Admission Rates by Ethnic Group and other Characteristics Speedchecker Broadband Internet Speed Tests Tip Given that the application can take several weeks, the Safeguarded CDRC datasets may be useful for your dissertation work but probably not for the GEOG0030 coursework assignment. However, any of the CDRC datasets that are marked as Open Data do not require this application process and you can download these datasets directly after registering on the website. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
